<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yes游-智慧旅游的新星</title>
  
  
  <link href="https://billysturate.github.io/atom.xml" rel="self"/>
  
  <link href="https://billysturate.github.io/"/>
  <updated>2023-01-28T12:48:27.211Z</updated>
  <id>https://billysturate.github.io/</id>
  
  <author>
    <name>yes游旅行公司</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VSCode去掉拷贝来的代码前的行号</title>
    <link href="https://billysturate.github.io/posts/5c68951c.html"/>
    <id>https://billysturate.github.io/posts/5c68951c.html</id>
    <published>2022-09-12T09:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.211Z</updated>
    
    <content type="html"><![CDATA[<p>当我们从某些地方复制代码过来的时候，代码前面常常会显示行号，就像下面这样,真的很烦人呢</p><p><img src="https://img-blog.csdnimg.cn/eb894ace94374e1e87e68378f6d0c67e.png#pic_center" alt=""></p><blockquote><p>下面我来介绍一种方法，废话不多说</p></blockquote><p>在VSCode中用快捷键<code>Alt+Shift</code>的同时，选中前面的行号(光标最好先移动到要删除的第一行的上面一行)开始往下选中，这样会更好操作一些，效果就像下面这样：</p><p><img src="https://img-blog.csdnimg.cn/185918b4881a466494ebe6b1a4d892b9.png#pic_center" alt=""></p><p>然后直接按删除键</p><p><img src="https://img-blog.csdnimg.cn/9c4961327dcf463a848ea3a6782ceb0e.png#pic_center" alt=""></p><p>这样就大功告成啦，是不是很简单呢</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我们从某些地方复制代码过来的时候，代码前面常常会显示行号，就像下面这样,真的很烦人呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/eb894ace94374e1e87e68378f6d0c67e.png#pic_center&quot;</summary>
      
    
    
    
    <category term="VScode" scheme="https://billysturate.github.io/categories/VScode/"/>
    
    
    <category term="VSCode" scheme="https://billysturate.github.io/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>【HTML基础】基础认知 + HTML标签</title>
    <link href="https://billysturate.github.io/posts/f5f81e3d.html"/>
    <id>https://billysturate.github.io/posts/f5f81e3d.html</id>
    <published>2022-09-08T10:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-HTML基础结构标签">1.HTML基础结构标签</h2><p>每个网页都会有一个基础的结构标签（骨架标签：4组），页面内容也是在这些基础标签上书写的。</p><blockquote><p>HTML 页面也称为 HTML 文档。</p></blockquote><p>【HTML 基础结构】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>标签名</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;html&gt;</code> <code>&lt;/html&gt;</code></td><td>根标签</td><td>页面中最大的标签（最基础的标签）</td></tr><tr><td><code>&lt;head&gt;</code> <code>&lt;/head&gt;</code></td><td>头部标签</td><td>在 head 标签中我们必须要设置 title 标签</td></tr><tr><td><code>&lt;title&gt;</code> <code>&lt;/title&gt;</code></td><td>标题标签</td><td>页面自己的网页标题</td></tr><tr><td><code>&lt;body&gt;</code> <code>&lt;/body&gt;</code></td><td>主体标签</td><td>包含文档的所有内容</td></tr></tbody></table><blockquote><p>在VsCode中按快捷键<code>!</code>号即可快速生成基础结构,如下图所示</p></blockquote><p><img src="https://img-blog.csdnimg.cn/e881437e5a4348d1848c6a6a6b7ef9c4.png#pic_center" alt=""></p><h2 id="2-HTML中的注释">2.HTML中的注释</h2><p>如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的文字，就需要使用注释标签。</p><p>HTML 中的注释以：<code>&lt;!--</code> 开头，以 <code>--&gt;</code> 结束。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释语句 --&gt;</span></span><br></pre></td></tr></table></figure><p>一句话：注释标签里面的内容是给程序员看的，这个代码是不执行不显示到页面中的。</p><blockquote><p>注释是为了更好地解释代码功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的。</p><p>VsCode中的快捷键是Ctrl+/</p></blockquote><h2 id="3-HTML常用标签">3.HTML常用标签</h2><h3 id="3-1-标题标签和段落标签">3.1 标题标签和段落标签</h3><p><strong>标题标签</strong>:</p><p>为了使网页更具有语义化，我们经常会在页面中用到标题标签。</p><p>HTML 提供了 6 个等级的网页标题，即：<code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code>。</p><blockquote><p>VsCode中快捷键为h1+Tab</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单词 head 的缩写，意为：头部、标题。</p></blockquote><p><strong>段落标签</strong>:</p><p>在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示，在 HTML 标签中，<code>&lt;p&gt;</code> 标签用于定义段落，它可以将整个网页分为若干个段落。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个段落标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单词 paragraph 的缩写，意为：段落。</p></blockquote><h3 id="3-2-换行标签和分割线标签">3.2 换行标签和分割线标签</h3><p><strong>换行标签</strong>:</p><p>在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。</p><p>如果希望某段文本强制换行显示，就需要使用换行标签  <code>&lt;br&gt;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单词 break 的缩写，意为：打断、换行。</p></blockquote><p><strong>分割线标签</strong>:<br>分割线标签：<code>&lt;hr&gt;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 某些时候需要对内容块进行分割时会用到分割线标签 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-文本格式化标签">3.3 文本格式化标签</h3><p>在网页中，有时需要为文字设置粗体、斜体或下划线等效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的方式显示。</p><p>**标签语义：**突出重要性，比普通文字更重要。</p><table><thead><tr><th>语义</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>加粗</td><td><code>&lt;strong&gt;</code> <code>&lt;/strong&gt;</code> 或 <code>&lt;b&gt;</code> <code>&lt;/b&gt;</code></td><td>介于可读性、搜索引擎优化及屏幕阅读器适配推荐使用前者</td></tr><tr><td>倾斜</td><td><code>&lt;em&gt;</code> <code>&lt;/em&gt;</code> 或 <code>&lt;i&gt;</code> <code>&lt;/i&gt;</code></td><td>介于可读性、搜索引擎优化及屏幕阅读器适配推荐使用前者</td></tr><tr><td>删除线</td><td><code>&lt;del&gt;</code> <code>&lt;/del&gt;</code> 或 <code>&lt;s&gt;</code> <code>&lt;/s&gt;</code></td><td>介于可读性、搜索引擎优化及屏幕阅读器适配推荐使用前者</td></tr><tr><td>下划线</td><td><code>&lt;ins&gt;</code> <code>&lt;/ins&gt;</code> 或 <code>&lt;u&gt;</code> <code>&lt;/u&gt;</code></td><td>介于可读性、搜索引擎优化及屏幕阅读器适配推荐使用前者</td></tr></tbody></table><h3 id="3-4-图像标签">3.4 图像标签</h3><p>在 HTML 标签中，<code>&lt;img&gt;</code> 标签用于定义 HTML 页面中的图像。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单词 image 的缩写，意为图像。</p></blockquote><p><code>src</code> 是 <code>&lt;img&gt;</code> 标签的必须属性，它用于指定图像文件的路径和文件名。</p><p><code>URL</code> 是 <code>统一资源定位符</code>（通俗理解：地址、网址）。</p><p>所谓属性：简单理解就是属于这个图像标签的特性。</p><p><strong>图像标签的其他属性：</strong></p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td><code>src</code></td><td>图片路径</td><td>必须属性</td></tr><tr><td><code>alt</code></td><td>文本</td><td>替换文本，图像显示失败时显示（为了提高 SEO 及适配屏幕阅读器，建议都把 alt 写上）</td></tr><tr><td><code>title</code></td><td>文本</td><td>提示文本，鼠标放到图片上，显示的提示文字</td></tr><tr><td><code>width</code></td><td>像素</td><td>设置图像的宽度（了解，后面通过 CSS 设置）</td></tr><tr><td><code>height</code></td><td>像素</td><td>设置图像的高度（了解，后面通过 CSS 设置）</td></tr><tr><td><code>border</code></td><td>像素</td><td>设置图像的边框粗细（了解，后面通过 CSS 设置）</td></tr></tbody></table><blockquote><p>设置图像的宽度与高度时：一般设置其中之一便可，另外一个会自动按比例适配</p></blockquote><h3 id="3-5-音频标签">3.5 音频标签</h3><ul class="lvl-0"><li class="lvl-2"><p>场景：在页面中插入音频</p></li><li class="lvl-2"><p>代码：<code>&lt;audio src=&quot;./music.mp3&quot; controls&gt;&lt;/audio&gt;</code></p></li><li class="lvl-2"><p>常见属性:</p><ul class="lvl-2"><li class="lvl-4">src音频的路径</li><li class="lvl-4">controls      显示播放的控件</li><li class="lvl-4">autoplay      自动播放(部分浏览器不支持)</li><li class="lvl-4">loop              循环播放</li></ul></li><li class="lvl-2"><p>注意点：</p><ul class="lvl-2"><li class="lvl-4">音频标签目前支持三种格式：Mp3,Wav,Ogg</li></ul></li></ul><h3 id="3-6-视频标签">3.6 视频标签</h3><ul class="lvl-0"><li class="lvl-2"><p>场景：在页面中插入视频</p></li><li class="lvl-2"><p>代码：<code>&lt;video src=&quot;./video.mp4&quot; controls&gt;&lt;/video&gt;</code></p></li><li class="lvl-2"><p>常见属性:</p><ul class="lvl-2"><li class="lvl-4">src音频的路径</li><li class="lvl-4">controls      显示播放的控件</li><li class="lvl-4">autoplay      自动播放(谷歌浏览器需配合muted实现静音播放)</li><li class="lvl-4">loop              循环播放</li></ul></li><li class="lvl-2"><p>注意点：</p><ul class="lvl-2"><li class="lvl-4">音频标签目前支持三种格式：Mp4,WebM,Ogg</li></ul></li></ul><h3 id="3-7-超链接标签">3.7 超链接标签</h3><p>在 HTML 标签中，<code>&lt;a&gt;</code> 标签用于定义超链接，作用是从一个页面链接到另一个页面。</p><p><strong>（1）链接的语法格式</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;跳转目标&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span>文本、图像或其他内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单词 <strong>anchor</strong> 的缩写，意为：锚。</p></blockquote><p><strong>两个属性的作用如下：</strong></p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>href</code></td><td>用于指定链接目标的 url 地址，（必须属性）当标签应用 href 属性时，它就具有了超链接的功能</td></tr><tr><td><code>target</code></td><td>用于指定链接页面的打开方式，其中 <code>_self</code> 在当前页面打开的方式（为默认值），<code>_blank</code> 在新窗口中打开的方式</td></tr></tbody></table><h2 id="4-列表标签">4.列表标签</h2><p>列表最大的特点就是：整齐、整洁、有序、它作为布局会更加自由和方便。</p><p>在实际开发中凡是遇到排列整齐的简洁内容，都可以使用列表来进行布局。</p><p>合理的使用列表布局可以有效提高 SEO。</p><p>根据使用情景不同，列表可以分为三大类：<code>无序列表</code>、<code>有序列表</code> 和 <code>自定义列表</code>。</p><table><thead><tr><th>标签名</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;ul&gt;</code> <code>&lt;/ul&gt;</code></td><td>无序标签</td><td>里面<strong>只包含 li</strong>，没有顺序，使用较多，li 里面可以包含任何标签</td></tr><tr><td><code>&lt;ol&gt;</code> <code>&lt;/ol&gt;</code></td><td>有序标签</td><td>里面<strong>只包含 li</strong>，有顺序，使用相对较少，li 里面可以包含任何标签</td></tr><tr><td><code>&lt;dl&gt;</code> <code>&lt;/dl&gt;</code></td><td>自定义标签</td><td>里面<strong>只能包含 dt 和 dd</strong>，dt 和 dd 里面可以放任何标签，dd 一般作为对 dt 的细分描述</td></tr></tbody></table><h3 id="4-1-无序列表">4.1 无序列表</h3><p><code>&lt;ul&gt;</code> 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 <code>&lt;li&gt;</code> 标签定义（开发中经常使用）。</p><p><strong>无序列表的基本语法格式如下：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>火龙果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>无序列表的各个列表项之间没有顺序级别之分，是并列的</p></li><li class="lvl-2"><p><code>&lt;ul&gt;</code> <code>&lt;/ul&gt;</code> 中只能嵌套 <code>&lt;li&gt;</code> <code>&lt;/li&gt;</code>，直接在 <code>&lt;ul&gt;</code> <code>&lt;/ul&gt;</code> 标签中输入其他标签或者文字的做法是不被允许的，列表中的任何内容都应该放在 <code>li</code> 中</p></li><li class="lvl-2"><p><code>&lt;li&gt;</code> 与 <code>&lt;/li&gt;</code> 之间相当于一个容器，可以容纳所有的元素</p></li><li class="lvl-2"><p>无序列表会带有自己的样式属性（比如圆点），但在实际开发中，我们会使用 CSS 来设置</p></li></ul><p>效果演示:</p><p><img src="https://img-blog.csdnimg.cn/74fc2a70b9d14f248cc7c21742784951.png#pic_center" alt=""></p><h3 id="4-2-有序列表">4.2 有序列表</h3><p>有序列表即为有序排列顺序的列表，其各个列表项会按照一定的顺序排列定义（开发中不太常用）。</p><p>在 HTML 标签中，<code>&lt;ol&gt;</code> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <code>&lt;li&gt;</code> 标签来定义列表项。</p><p><strong>有序列表的基本语法格式如下：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>100<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>80<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>70<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;ol&gt;</code> <code>&lt;/ol&gt;</code> 中只能嵌套 <code>&lt;li&gt;</code> <code>&lt;/li&gt;</code>，直接在 <code>&lt;ol&gt;</code> <code>&lt;/ol&gt;</code> 标签中输入其他标签或者文字的做法是不被允许的</p></li><li class="lvl-2"><p><code>&lt;li&gt;</code> 与 <code>&lt;/li&gt;</code> 之间相当于一个容器，可以容纳所有的元素</p></li><li class="lvl-2"><p>有序列表会带有自己样式属性（比如序号），但在实际使用时，我们会使用 CSS 来设置</p></li></ul><p>效果演示:</p><p><img src="https://img-blog.csdnimg.cn/2478d0821d2d4eafb4edd7dc36d3f7e9.png#pic_center" alt=""></p><h3 id="4-3-自定义列表">4.3 自定义列表</h3><p><strong>自定义列表的使用场景：</strong></p><p>自定义列表常用于对术语或名词进行解释、描述和展开，定义列表的列表项前没有任何项目符号（开发中常用）。</p><p>在 HTML 标签中，<code>&lt;dl&gt;</code> 标签用于定义描述列表（或定义列表），该标签会与 <code>&lt;dt&gt;</code>（定义项目/名字）和 <code>&lt;dd&gt;</code>（描述每一个项目/名字）一起使用。</p><p>其基本语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>帮助中心<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>账户管理<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>用户指南<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;dl&gt;</code> <code>&lt;/dl&gt;</code> 里面只包含 <code>&lt;dt&gt;</code>、<code>&lt;dd&gt;</code></p></li><li class="lvl-2"><p><code>&lt;dt&gt;</code> 和 <code>&lt;dd&gt;</code> 个数没有限制，经常是一个 <code>&lt;dt&gt;</code> 对应多个 <code>&lt;dd&gt;</code></p></li><li class="lvl-2"><p><code>dd</code>前会默认显示缩进效果</p></li></ul><p><img src="https://img-blog.csdnimg.cn/a7398317a0e94b34a35bdd58d4242a0b.png#pic_center" alt=""></p><h2 id="5-表格标签">5.表格标签</h2><h3 id="5-1-表格的基本语法">5.1 表格的基本语法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;table&gt;</code> <code>&lt;/table&gt;</code> 是用于定义表格的标签</p></li><li class="lvl-2"><p><code>&lt;tr&gt;</code> <code>&lt;/tr&gt;</code> 用于定义表格中的行，必须嵌套在 <code>&lt;table&gt;</code> <code>&lt;/table&gt;</code> 标签中</p></li><li class="lvl-2"><p><code>&lt;td&gt;</code> <code>&lt;/td&gt;</code> 用于定义表格中的单元格，必须嵌套在 <code>&lt;tr&gt;</code> <code>&lt;/tr&gt;</code> 标签中</p></li><li class="lvl-2"><p>字母 td 指表格数据（table data），即：数据单元格的内容</p></li><li class="lvl-2"><p>单元格 td 里面可以放任何的元素</p></li></ul><h3 id="5-2-表头单元格和表格标题">5.2 表头单元格和表格标题</h3><p>一般表头单元格位于表格的第一行或第一列，作用是：突出重要性，表头单元格里面的文本内容<strong>默认加粗居中</strong>显示。</p><p><code>&lt;th&gt;</code> 标签表示 HTML 表格的表头部分（table head 的缩写）。</p><p><code>&lt;caption&gt;</code>标签表示表格整体大标题，默认在表格整体顶部剧中位置设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 表格 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生成绩单<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">th</span>&gt;</span>评语<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>小哥哥<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>小姐姐<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>总结<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码展示：</p><p><img src="https://img-blog.csdnimg.cn/63b0f5c81b0d4b019bc1480dafee4ac1.png#pic_center" alt=""></p><h3 id="5-3-表格属性">5.3 表格属性</h3><p>**注意：**表格标签的属性在实际开发中并不常用，而是通过后面的 CSS 来设置，这里了解即可。</p><p>以下属性都写在 table 开始标签内，多个属性之间用空格隔开。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">属性值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>align</code></td><td style="text-align:left"><code>left</code>、<code>center</code>、<code>right</code></td><td style="text-align:left">规定表格相对周围元素的对齐方式（默认 left），注意指的是整个表格的对齐方式（表格是在父盒子中默认往左靠，还是居中或是往右靠），而不是指单元格内容的对齐方式（单元格内容对齐可以通过：<code>style=&quot;text-align: center;&quot;</code> 设置）（了解）</td></tr><tr><td style="text-align:left"><code>border</code></td><td style="text-align:left"><code>1</code> 或 <code>&quot;&quot;</code></td><td style="text-align:left">规定表格单元是否拥有边框，默认为 “”，表示没有边框（了解）</td></tr><tr><td style="text-align:left"><code>cellpadding</code></td><td style="text-align:left">像素值</td><td style="text-align:left">规定单元边沿与其内容之间的空白，默认 1 像素（了解）</td></tr><tr><td style="text-align:left"><code>cellspacing</code></td><td style="text-align:left">像素值</td><td style="text-align:left">规定单元格之间的空白，默认 2 像素（了解）</td></tr><tr><td style="text-align:left"><code>width</code></td><td style="text-align:left">像素值 或 百分比</td><td style="text-align:left">规定表格的宽度（了解）</td></tr><tr><td style="text-align:left"><code>height</code></td><td style="text-align:left">像素值 或 百分比</td><td style="text-align:left">规定表格的高度（了解）</td></tr></tbody></table><h3 id="5-4-表格的结构标签">5.4 表格的结构标签</h3><p>场景：让表格的内容结构分组，突出表格的不同部分(头部，主体，底部)，使语义更加清晰</p><p>结构标签:</p><table><thead><tr><th><strong>标签名</strong></th><th>名称</th></tr></thead><tbody><tr><td>thead</td><td>表格头部</td></tr><tr><td>tbody</td><td>表格主题</td></tr><tr><td>tfoot</td><td>表格底部</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生成绩单<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>评语<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>小哥哥<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>小姐姐<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>总结<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4274f0a208c24134b7688e7dd042ba94.png#pic_center" alt=""></p><h3 id="5-5-合并单元格">5.5 合并单元格</h3><p>特殊情况下，可以把多个单元格合并为一个单元格，这里会最简单的合并单元格即可。</p><p><strong>合并单元格的方式：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>跨行合并（上下合并）：<code>rowspan=&quot;合并单元格的个数&quot;</code></p></li><li class="lvl-2"><p>跨列合并（左右合并）：<code>colspan=&quot;合并单元格的个数&quot;</code></p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>优秀学生信息表格<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年纪<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>班级<span class="tag">&lt;/<span class="name">th</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>高三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>110<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>三年二班<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>赵四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>120<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>三年二班<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>评语<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>你们都很优秀<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7b3979e98b24465d823acc4b28bf8392.png#pic_center" alt=""></p><h2 id="6-表单标签">6.表单标签</h2><h3 id="6-1-input系列标签">6.1 input系列标签</h3><p>在英文单词中，input 是输入的意思，而在表单元素中 <code>&lt;input&gt;</code> 标签用于收集用户信息，如：登录页，注册页。</p><p>在 <code>&lt;input&gt;</code> 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本、字段、复选框、掩码后的文本控件、单选按钮、按钮等）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;input /&gt;</code> 标签为单标签</p></li><li class="lvl-2"><p>type 属性设置不同的属性值用来指定不同的控件类型</p></li></ul><p><strong>type 属性的属性值及其描述如下：</strong></p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>button</code></td><td>定义可点击按钮，默认无功能（多数情况下，用于通过 JavaScript 启动脚本）</td></tr><tr><td><code>checkbox</code></td><td>定义复选框，即：多选框，在一组多选中，要求它们必须拥有相同的 name</td></tr><tr><td><code>file</code></td><td>定义输入字段和 “浏览” 按钮，供文件上传，只能单文件，加上multiple属性值，可以实现多文件</td></tr><tr><td><code>hidden</code></td><td>定义隐藏的输入字段</td></tr><tr><td><code>image</code></td><td>定义图像形式的提交按钮</td></tr><tr><td><code>password</code></td><td>定义密码字段，该字段中的字符被掩码</td></tr><tr><td><code>radio</code></td><td>定义单选按钮，在一组单选按钮中，要求它们必须拥有相同的 name</td></tr><tr><td><code>reset</code></td><td>定义重置按钮，重置按钮会清除表单中的所有数据</td></tr><tr><td><code>submit</code></td><td>定义提交按钮，提交按钮会把表单数据发送到服务器</td></tr><tr><td><code>text</code></td><td>定义单行的输入字段，用户可在其中输入文本，默认宽度为 20 个字符</td></tr></tbody></table><p><strong>除 type 属性外，<code>&lt;input&gt;</code> 标签还有很多其他属性，其常用属性如下：</strong></p><table><thead><tr><th>属性名</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>name</code></td><td>由用户自定义</td><td>定义 input 元素的名称</td></tr><tr><td><code>value</code></td><td>由用户自定义</td><td>规定 input 元素的值，也就是提交到服务器的值</td></tr><tr><td><code>checked</code></td><td>checked</td><td>规定此 input 元素首次加载时应当被选中</td></tr><tr><td><code>maxlength</code></td><td>正整数</td><td>规定输入字段中的字符的最大长度</td></tr><tr><td><code>placeholder</code></td><td>由用户自定义</td><td>占位符，提示用户输入内容的文本</td></tr><tr><td><code>multiple</code></td><td>file</td><td>常用于type值为file时，进行多文件选择</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入账号&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;normal button&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/62e47b505070481ab5bcbeb9898ca0d1.png#pic_center" alt=""></p><p><strong>&lt;1&gt;、有些表单元素刚打开页面就须要默认显示几个文字怎么做？</strong></p><p>答：可以给这些表单元素设置 <code>value属性=&quot;值&quot;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名：<span class="tag">&lt;<span class="name">iuput</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;请输入用户名&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>&lt;2&gt;、页面中的表单元素很多，如何区别不同的表单元素？</strong></p><p>答：name 属性：当前 input 表单的名字，后台可以通过这个 name 属性找到这个表单，页面中的表单很多，name 的主要作用就是用于区别不同的表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;请输入用户名&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>name 属性后面的值是自定义的</p></li><li class="lvl-2"><p>radio（或者 checkbox）如果是一组，我们必须给他们命名相同的名字</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span>女</span><br></pre></td></tr></table></figure><p><strong>&lt;3&gt;、如果页面一打开就让某个单选按钮或者复选框是选中状态？</strong></p><p>答：checked 属性：表示默认选中状态，用于单选按钮和复选按钮。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">性 别：</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> &gt;</span>女</span><br></pre></td></tr></table></figure><h3 id="6-2-label标签">6.2 label标签</h3><blockquote><p>VsCode快捷键：alt+shift+↑/↓ 复制当前行在下方插入</p></blockquote><p><code>&lt;label&gt;</code> 标签为 input 元素定义标注（标签）。</p><p><code>&lt;label&gt;</code> 标签用于绑定一个表单元素，当点击 <code>&lt;label&gt;</code> 标签内的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，用来增加用户体验。</p><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一种写法：</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">第二种写法：</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>核心：</strong> <code>&lt;label&gt;</code> 标签的 for 属性应当与相关元素的 id 属性相同。</p><h3 id="6-3-button按钮标签">6.3 button按钮标签</h3><p>场景：在网页中显示用户点击的按钮</p><p>type属性值(同input的按钮系列)</p><table><thead><tr><th>type属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>reset</code></td><td>定义重置按钮，重置按钮会清除表单中的所有数据</td></tr><tr><td><code>submit</code></td><td>定义提交按钮，提交按钮会把表单数据发送到服务器</td></tr><tr><td><code>button</code></td><td>普通按钮，默认无功能</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>普通按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/26fd6f4c6325499d9f76ce5a513f94f0.png#pic_center" alt=""></p><h3 id="6-4-select下拉单标签">6.4 select下拉单标签</h3><p>**使用场景：**在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用 <code>&lt;select&gt;</code> 标签控件定义下拉列表。</p><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;select&gt;</code> 中至少包含一对 <code>&lt;option&gt;</code></p></li><li class="lvl-2"><p>在 <code>&lt;option&gt;</code> 中定义 <code>selected=&quot;selected&quot;</code> 时，当前项即为默认选中项</p></li></ul><p>每个 <code>&lt;option&gt;</code> 元素都应该有一个 value 属性，其中包含选择该选项时要提交给服务器的数据值。如果不包含 value 属性，则 value 默认为元素内包含的文本。可以在 <code>&lt;option&gt;</code> 元素上包含 selected 属性，以使其在页面首次加载时默认选中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">selected</span>&gt;</span>南京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>东京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>西京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6cb73924e0ec4ce78bdad78b2948e14b.png#pic_center" alt=""></p><h3 id="6-5-textarea文本域标签">6.5 textarea文本域标签</h3><p>**使用场景：**当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 <code>&lt;textarea&gt;</code> 标签</p><p>在表单元素中，<code>&lt;textarea&gt;</code> 标签是用于定义多行文本输入的控件。</p><p>使用多行文本输入控件，可以输入更多的文字，该控件常用于留言板、评论。</p><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;3&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line">文本内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通过 <code>&lt;textarea&gt;</code> 标签可以轻松地创建多行文本输入框</p></li><li class="lvl-2"><p><code>cols=&quot;每行中的字符数&quot;</code>，<code>rows=&quot;显示的行数&quot;</code>，我们在实际开发中不会使用，都是用 CSS 来改变大小</p></li><li class="lvl-2"><p>如果要禁止拉伸文本框大小，则：<code>style=&quot;resize: none&quot; </code></p></li></ul><p><img src="https://img-blog.csdnimg.cn/71fc1ddbc017474fbfb4a4c31c8fe4ad.png#pic_center" alt=""></p><h3 id="6-6-表单域标签">6.6 表单域标签</h3><p><strong>表单域是一个包含表单元素的区域。</strong></p><p>在 HTML 标签中，<code>&lt;form&gt;</code> 标签用于定义表单域，以实现用户信息的收集和传递。</p><p><code>&lt;form&gt;</code> 会把它范围内的表单元素信息提交给服务器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单域名称&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 各种表单元素控件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>常用属性：</strong></p><table><thead><tr><th>属性名</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td><code>action</code></td><td><code>url</code> 地址</td><td>用于指定接收并处理表单数据的服务器程序的 url 地址</td></tr><tr><td><code>method</code></td><td><code>get</code> / <code>post</code></td><td>用于设置表单数据的提交方式，其取值为 get 或 post</td></tr><tr><td><code>name</code></td><td>名称</td><td>用于指定表单的名称，以区分同一个页面中的多个表单域</td></tr></tbody></table><p>注意：对于 HTML 基础的学习来说，暂时不用考虑提交数据，只需写上 form 标签即可，后面学习服务端编程阶段会重新讲解。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;normal button&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**注意：**如果不加form,那么提交或者重置的时候没有效果，因为不知道重置哪些内容</p><h2 id="7-字符实体">7.字符实体</h2><p>在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。</p><table><thead><tr><th style="text-align:left">特殊字符</th><th style="text-align:left">描述</th><th style="text-align:left">字符的代码</th></tr></thead><tbody><tr><td style="text-align:left"><code> </code></td><td style="text-align:left">空格符</td><td style="text-align:left"><code>&amp;nbsp;</code></td></tr><tr><td style="text-align:left"><code>&lt;</code></td><td style="text-align:left">小于号</td><td style="text-align:left"><code>&amp;lt;</code></td></tr><tr><td style="text-align:left"><code>&gt;</code></td><td style="text-align:left">大于号</td><td style="text-align:left"><code>&amp;gt;</code></td></tr><tr><td style="text-align:left"><code>&amp;</code></td><td style="text-align:left">和号</td><td style="text-align:left"><code>&amp;amp;</code></td></tr><tr><td style="text-align:left"><code>±</code></td><td style="text-align:left">正负号</td><td style="text-align:left"><code>&amp;plusmn;</code></td></tr><tr><td style="text-align:left"><code>×</code></td><td style="text-align:left">乘号</td><td style="text-align:left"><code>&amp;times;</code></td></tr><tr><td style="text-align:left"><code>÷</code></td><td style="text-align:left">除号</td><td style="text-align:left"><code>&amp;divide;</code></td></tr><tr><td style="text-align:left"><code>²</code></td><td style="text-align:left">上标</td><td style="text-align:left"><code>&amp;sup2;</code></td></tr></tbody></table><h2 id="8-综合案例">8.综合案例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>青春不常在，抓紧谈恋爱<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        昵称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入昵称&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        性别：</span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">checked</span>&gt;</span> 男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span> 女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        所在城市：</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">selected</span>&gt;</span>南京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>东京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        喜欢的类型：</span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span> 可爱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>&gt;</span> 萝莉<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span> 御姐<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        个人介绍：</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;60&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我承诺<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>年满18岁，单身<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>抱着严肃的态度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>真诚寻找另一半<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span> 我同意所有条款</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7ec9e538f34d4dceb40f2ef4afe0f59a.png#pic_center" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-HTML基础结构标签&quot;&gt;1.HTML基础结构标签&lt;/h2&gt;
&lt;p&gt;每个网页都会有一个基础的结构标签（骨架标签：4组），页面内容也是在这些基础标签上书写的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTML 页面也称为 HTML 文档。&lt;/p&gt;
&lt;/blockq</summary>
      
    
    
    
    <category term="HTML" scheme="https://billysturate.github.io/categories/HTML/"/>
    
    
    <category term="HTML" scheme="https://billysturate.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程之线程同步</title>
    <link href="https://billysturate.github.io/posts/75206e58.html"/>
    <id>https://billysturate.github.io/posts/75206e58.html</id>
    <published>2022-09-07T10:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-线程同步的概念">1.线程同步的概念</h2><p>同步即协同步调，按预定的先后次序运行。</p><p><strong>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</strong></p><p>假设有 4 个线程 A、B、C、D，当前一个线程 A 对内存中的共享资源进行访问的时候，其他线程 B, C, D 都不可以对这块内存进行操作，直到线程 A 对这块内存访问完毕为止，B，C，D 中的一个才能访问这块内存，剩余的两个需要继续阻塞等待，以此类推，直至所有的线程都对这块内存操作完毕。 线程对内存的这种访问方式就称之为线程同步，通过对概念的介绍，我们可以了解到<mark>所谓的同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行的</mark>。如果不按照这种规则，就会产生数据混乱。</p><h2 id="2-数据混乱原因">2.数据混乱原因</h2><ol><li class="lvl-3"><p>资源共享（独享资源则不会）</p></li><li class="lvl-3"><p>调度随机（意味着数据访问会出现竞争）</p></li><li class="lvl-3"><p>线程间缺乏必要的同步机制。</p></li></ol><p>以上 3 点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p><h2 id="3-互斥量mutex">3.互斥量mutex</h2><p>Linux 中提供一把互斥锁<code>mutex</code>（也称之为互斥量）。 <mark>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作</mark>，操作结束解锁。 资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。但应注意：<mark>同一时刻，只能有一个线程持有该锁。</mark> 当 A 线程对某个全局变量加锁访问，B 在访问前尝试加锁，拿不到锁，B 阻塞。C 线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。 所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。因此，即使有了<code>mutex</code>，如果有线程不按规则来访问数据，依然会造成数据混乱。</p><p><img src="https://img-blog.csdnimg.cn/78e4d0d7474047bcbfb55e7c4116cd8a.png#pic_center" alt=""></p><p><strong>主要应用的函数</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>pthread_mutex_init </code>函数</p></li><li class="lvl-2"><p><code>pthread_mutex_destroy</code> 函数</p></li><li class="lvl-2"><p><code>pthread_mutex_lock </code>函数</p></li><li class="lvl-2"><p><code>pthread_mutex_trylock </code>函数</p></li><li class="lvl-2"><p><code>pthread_mutex_unlock </code>函数</p></li></ul><blockquote><p>以上 5 个函数的返回值都是：成功返回 0， 失败返回错误号。 <code>pthread_mutex_t </code>类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。下面具体介绍这些函数：</p></blockquote><p>在 Linux 中互斥锁的类型为 <code>pthread_mutex_t</code>，创建一个这种类型的变量就得到了一把互斥锁：</p><p><code>pthread_mutex_t  mutex;</code></p><p>变量mutex 只有两种取值 1、0</p><h3 id="3-1-初始化和销毁函数">3.1 初始化和销毁函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放互斥锁资源            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数:</p><ul class="lvl-2"><li class="lvl-4">mutex: 传出参数，互斥锁变量的地址，调用时应传 &amp;mutex</li><li class="lvl-4">restrict 关键字：是一个关键字, 用来修饰指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。 不能通过除本指针以外的其他变量或指针修改</li><li class="lvl-4">attr: 互斥锁的属性，一般使用默认属性即可，这个参数指定为 NULL</li></ul></li></ul><blockquote><ol><li class="lvl-3"><p>静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了 static 关键字修饰），可以直接使用宏进行初始化。</p><p><code>pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</code></p></li><li class="lvl-3"><p>动态初始化：局部变量应采用动态初始化。</p><p><code>pthread_mutex_init(&amp;mutex, NULL)</code></p></li></ol></blockquote><h3 id="3-1-pthread-mutex-lock-函数">3.1 pthread_mutex_lock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>这个函数被调用，首先会判断参数 mutex 互斥锁中的状态是不是锁定状态:</p><ul class="lvl-0"><li class="lvl-2"><p>没被锁定，是打开的，这个线程可以加锁成功，这个这个锁中会记录是哪个线程加锁成功了</p></li><li class="lvl-2"><p>如果被锁定了，其他线程加锁就失败了，这些线程都会阻塞在这把锁上</p></li><li class="lvl-2"><p>当这把锁被解开之后，这些阻塞在锁上的线程就解除阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的线程继续阻塞</p></li></ul><h3 id="3-2-pthread-mutex-trylock-函数">3.2 pthread_mutex_trylock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数对互斥锁变量加锁还是有两种情况:</p><ul class="lvl-0"><li class="lvl-2"><p>如果这把锁没有被锁定是打开的，线程加锁成功</p></li><li class="lvl-2"><p>如果锁变量被锁住了，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号</p></li></ul><h3 id="3-3-pthread-mutex-unlock-函数">3.3 pthread_mutex_unlock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对互斥锁解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>不是所有的线程都可以对互斥锁解锁，哪个线程加的锁，哪个线程才能解锁成功。</p><h3 id="3-4-互斥锁使用">3.4 互斥锁使用</h3><blockquote><p>案例：两个线程交替数数（每个线程数 50 个数，交替数到 100）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一把互斥锁</span></span><br><span class="line"><span class="comment">// 全局变量, 多个线程共享</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcA_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果线程A加锁成功, 不阻塞</span></span><br><span class="line">        <span class="comment">// 如果B加锁成功, 线程A阻塞</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcB_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// a加锁成功, b线程访问这把锁的时候是锁定的</span></span><br><span class="line">        <span class="comment">// 线程B先阻塞, a线程解锁之后阻塞解除</span></span><br><span class="line">        <span class="comment">// 线程B加锁成功了</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="comment">// 线程销毁之后, 再去释放互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>互斥锁使用技巧:</strong></p><p>注意事项：</p><p>​    尽量保证锁的粒度， 越小越好。（访问共享数据前，加锁。访问结束立即解锁。）</p><p>​    互斥锁，本质是结构体。 我们可以看成整数。 初值为 1。（pthread_mutex_init() 函数调用成功。）</p><p>​    加锁： --操作， 小于0，阻塞线程。</p><p>​    解锁： ++操作， 唤醒阻塞在锁上的线程。</p><p>​    try锁：尝试加锁，成功–。失败，返回直接返回错误号</p><h2 id="4-死锁">4. 死锁</h2><p>当多个线程访问共享资源，需要加锁，如果锁使用不当，就会造成死锁这种现象。如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。</p><p>造成死锁的场景有如下几种：</p><ol><li class="lvl-3"><p>线程试图对同一个互斥量 A 加锁两次。</p></li><li class="lvl-3"><p>线程 1 拥有 A 锁，请求获得 B 锁；线程 2 拥有 B 锁，请求获得 A 锁</p></li><li class="lvl-3"><p>加锁之后忘记解锁</p></li></ol><p><img src="https://img-blog.csdnimg.cn/92fd75b62d8a49ba8d9d145d29573ae7.png#pic_center" alt=""></p><h2 id="5-读写锁">5.读写锁</h2><p>与互斥量类似，但读写锁允许更高的并行性。其特性为：<mark>写独占，读共享。</mark></p><p><strong>读写锁的状态</strong>:</p><p>特别强调：<mark>读写锁只有一把</mark>，但其具备两种状态：</p><ol><li class="lvl-3"><p>读模式下加锁状态 (读锁)</p></li><li class="lvl-3"><p>写模式下加锁状态 (写锁)</p></li></ol><p><strong>读写锁的特性</strong></p><ol><li class="lvl-3"><p>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</p></li><li class="lvl-3"><p>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</p></li><li class="lvl-3"><p>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。<mark>读锁、写锁并行阻塞，写锁优先级高</mark></p></li></ol><p>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是<code>以共享模式锁住的</code>；当它以写模式锁住时，它是<code>以独 占模式锁住的</code>。写独占、读共享。读写锁非常适合于对数据结构读的次数远大于写的情况。</p><p><strong>主要应用的函数</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>pthread_rwlock_init</code> 函数</p></li><li class="lvl-2"><p><code>pthread_rwlock_destroy</code> 函数</p></li><li class="lvl-2"><p><code>pthread_rwlock_rdlock</code> 函数</p></li><li class="lvl-2"><p><code>pthread_rwlock_wrlock</code> 函数</p></li><li class="lvl-2"><p><code>pthread_rwlock_tryrdlock</code> 函数</p></li><li class="lvl-2"><p><code>pthread_rwlock_trywrlock </code>函数</p></li><li class="lvl-2"><p><code>pthread_rwlock_unlock</code> 函数</p></li></ul><blockquote><p>以上 7 个函数的返回值都是：成功返回 0， 失败直接返回错误号。下面具体介绍这些函数</p></blockquote><p>读写锁是一把锁，锁的类型为 <code>pthread_rwlock_t</code>，有了类型之后就可以创建一把互斥锁了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br></pre></td></tr></table></figure><h3 id="5-1-初始化和销毁函数">5.1 初始化和销毁函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放读写锁占用的系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数:</p><ul class="lvl-2"><li class="lvl-4"><code>rwlock</code>: 读写锁的地址，传出参数</li><li class="lvl-4"><code>attr</code>: 读写锁属性，一般使用默认属性，指定为 NULL</li></ul></li></ul><h3 id="5-2-pthread-rwlock-rdlock-函数">5.2 pthread_rwlock_rdlock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加读锁, 锁定的是读操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数的线程会被阻塞。</p><h3 id="5-3-pthread-rwlock-tryrdlock-函数">5.3 pthread_rwlock_tryrdlock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加读锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应的线程不会被阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</p><h3 id="5-4-pthread-rwlock-wrlock-函数">5.4 pthread_rwlock_wrlock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加写锁, 锁定的是写操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数的线程会被阻塞。</p><h3 id="5-5-pthread-rwlock-trywrlock-函数">5.5 pthread_rwlock_trywrlock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加写锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</p><h3 id="5-6-pthread-rwlock-unlock-函数">5.6 pthread_rwlock_unlock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁, 不管锁定了读还是写都可用解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h3 id="5-7-读写锁的使用">5.7 读写锁的使用</h3><blockquote><p>8 个线程操作同一个全局变量，3 个线程不定时写同一全局资源，5 个线程不定时读同一全局资源</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义读写锁</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写的线程的处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writeNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur ++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++写操作完毕, number : %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">// 添加sleep目的是要看到多个线程交替工作</span></span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程的处理函数</span></span><br><span class="line"><span class="comment">// 多个线程可以如果处理动作相同, 可以使用相同的处理函数</span></span><br><span class="line"><span class="comment">// 每个线程中的栈资源是独享</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">readNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--全局变量number = %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化读写锁</span></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3个写线程, 5个读的线程</span></span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">3</span>];</span><br><span class="line">    <span class="type">pthread_t</span> rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;wtid[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;rtid[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(wtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(rtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-条件变量">6.条件变量</h2><p>条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</p><p><strong>主要应用的函数</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>pthread_cond_init</code> 函数</p></li><li class="lvl-2"><p><code>pthread_cond_destroy </code>函数</p></li><li class="lvl-2"><p><code>pthread_cond_wait </code>函数</p></li><li class="lvl-2"><p><code>pthread_cond_timedwait</code> 函数</p></li><li class="lvl-2"><p><code>pthread_cond_signal</code> 函数</p></li><li class="lvl-2"><p><code>pthread_cond_broadcast</code> 函数</p></li></ul><blockquote><p>以上 6 个函数的返回值都是：成功返回 0， 失败直接返回错误号。下面具体介绍这些函数</p></blockquote><p>条件变量类型对应的类型为 <code>pthread_cond_t</code>，这样就可以定义一个条件变量类型的变量了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br></pre></td></tr></table></figure><p>被条件变量阻塞的线程的线程信息会被记录到这个变量中，以便在解除阻塞的时候使用。</p><h3 id="6-1-初始化和销毁函数">6.1 初始化和销毁函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 销毁释放资源        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数:</p><ul class="lvl-2"><li class="lvl-4">cond: 条件变量的地址</li><li class="lvl-4">attr: 条件变量属性，一般使用默认属性，指定为 NULL</li></ul></li></ul><blockquote><ol><li class="lvl-3"><p>静态初始化：可以直接使用宏进行初始化。<code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code></p></li><li class="lvl-3"><p>动态初始化：局部变量应采用动态初始化。<code>pthread_mutex_init(&amp;cond, NULL)</code></p></li></ol></blockquote><h3 id="6-2-pthread-cond-wait-函数">6.2 pthread_cond_wait()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><p>函数作用：</p><ol><li class="lvl-3"><p>阻塞等待条件变量 cond（参 1）满足</p></li><li class="lvl-3"><p>释放已掌握的互斥锁（解锁互斥量）相当于 <code>pthread_mutex_unlock(&amp;mutex)</code>; 1.2.两步为一个原子操作。</p></li><li class="lvl-3"><p>当被唤醒，<code>pthread_cond_wait</code> 函数返回时，解除阻塞并重新申请获取互斥锁 <code>pthread_mutex_lock(&amp;mutex)</code>;</p></li></ol><p><img src="https://img-blog.csdnimg.cn/1f5c8f75c5e24a2c90d2c10f143260ac.png#pic_center" alt=""></p><h3 id="6-3-pthread-cond-timedwait-函数">6.3 pthread_cond_timedwait()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds 秒*/</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds 纳秒 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure><p>这个函数的前两个参数和 <code>pthread_cond_wait</code> 函数是一样的，第三个参数表示线程阻塞的时长，但是需要额外注意一点：<code>struct timespec</code> 这个结构体中记录的时间是从1971.1.1到某个时间点的时间，总长度使用秒/纳秒表示。因此赋值方式相对要麻烦一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如：time(<span class="literal">NULL</span>)返回的就是绝对时间。而 alarm(<span class="number">1</span>)是相对时间，相对当前时间定时 <span class="number">1</span> 秒钟。 </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span> =</span> &#123;<span class="number">1</span>, <span class="number">0</span>&#125;; </span><br><span class="line">pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 只能定时到 <span class="number">1970</span> 年 <span class="number">1</span> 月 <span class="number">1</span> 日 <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> 秒(早已经过去)</span><br><span class="line">正确用法： </span><br><span class="line">  <span class="type">time_t</span> cur = time(<span class="literal">NULL</span>); 获取当前时间。 </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span> 定义 timespec 结构体变量t </span><br><span class="line">  t.tv_sec = cur+<span class="number">1</span>; 定时 <span class="number">1</span> 秒</span><br><span class="line">pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 传参</span><br></pre></td></tr></table></figure><h3 id="6-4-唤醒函数">6.4 唤醒函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><p>调用上面两个函数中的任意一个，都可以唤醒被 <code>pthread_cond_wait</code> 或者 <code>pthread_cond_timedwait</code> 阻塞的线程，区别就在于 <code>pthread_cond_signal</code> 是唤醒至少一个被阻塞的线程（总个数不定），<code>pthread_cond_broadcast</code> 是唤醒所有被阻塞的线程。</p><h3 id="6-5-生产者消费者条件变量模型">6.5 生产者消费者条件变量模型</h3><p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定 有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p><p><img src="https://img-blog.csdnimg.cn/28a56993e7b047538a7b7672ea0b9c10.png#pic_center" alt=""></p><blockquote><p>小案例：使用条件变量实现生产者和消费者模型，生产者有 5 个，往链表头部添加节点，消费者也有 5 个，删除链表头部的节点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义条件变量, 控制消费者线程</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产了任务, 通知消费者消费</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 一直消费, 删除链表中的一个节点</span></span><br><span class="line"><span class="comment">//        if(head == NULL)   // 这样写有bug</span></span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 任务队列, 也就是链表中已经没有节点可以消费了</span></span><br><span class="line">            <span class="comment">// 消费者线程需要阻塞</span></span><br><span class="line">            <span class="comment">// 线程加互斥锁成功, 但是线程阻塞在这行代码上, 锁还没解开</span></span><br><span class="line">            <span class="comment">// 其他线程在访问这把锁的时候也会阻塞, 生产者也会阻塞 ==&gt; 死锁</span></span><br><span class="line">            <span class="comment">// 这函数会自动将线程拥有的锁解开</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">            <span class="comment">// 当消费者线程解除阻塞之后, 会自动将这把锁锁上</span></span><br><span class="line">            <span class="comment">// 这时候当前这个线程又重新拥有了这把互斥锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);        </span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-条件变量的优点：">6.6 条件变量的优点：</h3><p>相较于<code>mutex</code> 而言，条件变量可以减少竞争。 如直接使用<code>mutex</code>，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p><h2 id="7-信号量">7.信号量</h2><p>进化版的互斥锁（1 --&gt; N） 由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。 信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p><p><strong>主要应用函数</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>sem_init</code> 函数</p></li><li class="lvl-2"><p><code>sem_destroy</code> 函数</p></li><li class="lvl-2"><p><code>sem_wait</code> 函数</p></li><li class="lvl-2"><p><code>sem_trywait</code> 函数</p></li><li class="lvl-2"><p><code>sem_timedwait</code> 函数</p></li><li class="lvl-2"><p><code>sem_post</code> 函数</p></li></ul><p>以上 6 个函数的返回值都是：成功返回 0， 失败返回-1，同时设置 errno。(注意，它们没有 pthread 前缀)</p><p><code>信号量（信号灯）</code>与互斥锁和条件变量的主要不同在于” 灯” 的概念，灯亮则意味着资源可用，灯灭则意味着不可用。信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</p><p>信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为<code>sem_t</code>对应的头文件为 <code>&lt;semaphore.h&gt;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br></pre></td></tr></table></figure><h3 id="7-1-初始化和销毁函数">7.1 初始化和销毁函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化信号量/信号灯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">// 资源释放, 线程销毁之后调用这个函数即可</span></span><br><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数:</p><ul class="lvl-2"><li class="lvl-4"><code>sem</code>：信号量变量地址</li><li class="lvl-4"><code>pshared</code>：<ul class="lvl-4"><li class="lvl-6">0：线程同步</li><li class="lvl-6">非 0：进程同步</li></ul></li><li class="lvl-4"><code>value</code>：初始化当前信号量拥有的资源数（&gt;=0），如果资源数为 0，线程就会被阻塞了。</li></ul></li></ul><h3 id="7-2-sem-wait-函数">7.2 sem_wait()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，因此线程也就被阻塞了。</p><h3 id="7-3-sem-trywait-函数">7.3 sem_trywait()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>当线程调用这个函数，并且 <code>sem</code> 中的资源数 &gt;0，线程不会阻塞，线程会占用 <code>sem</code> 中的一个资源，因此资源数 - 1，直到<code>sem</code>中的资源数减为 0 时，资源被耗尽，但是线程不会被阻塞，直接返回错误号，因此可以在程序中添加判断分支，用于处理获取资源失败之后的情况。</p><h3 id="7-4-sem-timedwait-函数">7.4 sem_timedwait()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用该函数线程获取sem中的一个资源，当资源数为0时，线程阻塞，在阻塞abs_timeout对应的时长之后，解除阻塞。</span></span><br><span class="line"><span class="comment">// abs_timeout: 阻塞的时间长度, 单位是s, 是从1970.1.1开始计算的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure><p>该函数的参数 <code>abs_timeout</code> 和<code> pthread_cond_timedwait</code> 的最后一个参数是一样的，使用方法不再过多赘述。当线程调用这个函数，并且 <code>sem</code> 中的资源数 &gt;0，线程不会阻塞，线程会占用 <code>sem</code> 中的一个资源，因此资源数 - 1，直到 <code>sem</code> 中的资源数减为 0 时，资源被耗尽，线程被阻塞，当阻塞指定的时长之后，线程解除阻塞。</p><h3 id="7-5-sem-post-函数">7.5 sem_post()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用该函数给sem中的资源数+1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>调用该函数会将 <code>sem</code> 中的资源数 +1，如果有线程在调用<code> sem_wait</code>、<code>sem_trywait</code>、<code>sem_timedwait</code> 时因为 <code>sem</code> 中的资源数为 0 被阻塞了，这时这些线程会解除阻塞，获取到资源之后继续向下运行。</p><h3 id="7-6-生产者消费者信号量模型">7.6 生产者消费者信号量模型</h3><blockquote><p>小案例：使用信号量实现生产者和消费者模型，生产者有 5 个，往链表头部添加节点，消费者也有 5 个，删除链表头部的节点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-线程同步的概念&quot;&gt;1.线程同步的概念&lt;/h2&gt;
&lt;p&gt;同步即协同步调，按预定的先后次序运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。&lt;/strong</summary>
      
    
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="线程同步" scheme="https://billysturate.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程之守护进程、线程</title>
    <link href="https://billysturate.github.io/posts/88cb41b.html"/>
    <id>https://billysturate.github.io/posts/88cb41b.html</id>
    <published>2022-09-05T10:13:54.000Z</published>
    <updated>2023-01-28T15:45:19.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-守护进程">1.守护进程</h2><p>守护进程（Daemon Process），也就是通常说的Daemon(精灵)进程，是 Linux 中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理 某些发生的事件。一般采用以 d 结尾的名字。</p><p>Linux 后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp 服务器；nfs 服务器等。</p><p>创建守护进程，最关键的一步是调用 <code>setsid</code> 函数创建一个新的 Session，并成为 Session Leader。</p><h3 id="1-1-进程组">1.1 进程组</h3><p>多个进程的集合就是进程组，也称之为作业。BSD 于 1980 年前后向 Unix 中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程组。在<code>waitpid</code>函数和 <code>kill</code> 函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。</p><p>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组 ID == 第一个进程 ID(组长进程)。 所以，组长进程标识：其进程组 ID == 其进程 ID</p><p>可以使用 <code>kill -SIGKILL -进程组 ID(负的)</code>来将整个进程组内的进程全部杀死。组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</p><p>进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。</p><p>一个进程可以为自己或子进程设置进程组 ID</p><p>下面介绍几个常用的进程组函数：</p><blockquote><p>得到当前进程所在的进程组的组 ID</p></blockquote><p><code>pid_t getpgrp(void);</code></p><blockquote><p>获取指定的进程所在的进程组的组 ID，参数 pid 就是指定的进程</p></blockquote><p><code>pid_t getpgid(pid_t pid);</code></p><blockquote><p>将某个进程移动到其他进程组中或者创建新的进程组</p></blockquote><p><code>int setpgid(pid_t pid, pid_t pgid);</code></p><p><strong>函数参数:</strong></p><p><code>pid: </code>某个进程的进程 ID</p><p><code>pgid:</code> 某个进程组的组 ID</p><p>如果 pgid 对应的进程组存在，pid 对应的进程会移动到这个组中，pid != pgid</p><p>如果 pgid 对应的进程组不存在，会创建一个新的进程组，因此要求 pid == pgid, 当前进程就是组长了</p><p><strong>函数返回值：</strong></p><p>函数调用成功返回 0，失败返回 - 1</p><h3 id="1-2-会话">1.2 会话</h3><p>会话 (session) 是由一个或多个进程组组成的，一个会话可以对应一个控制终端，也可以没有。一个普通的进程可以调用 <code>setsid() </code>函数使自己成为新 session 的领头进程(会长)，并且这个 session 领头进程还会被放入到一个新的进程组中。先来看一下 setsid() 函数的原型:</p><h3 id="1-3-setsid-函数">1.3 setsid()函数</h3><p>创建一个会话，并以自己的 ID 设置进程组 ID，同时也是新会话的 ID。</p><p><strong>函数原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数返回值</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>成功：返回调用进程的会话 ID</p></li><li class="lvl-2"><p>失败：-1，设置 errno</p></li></ul><h3 id="1-4-getsid-函数">1.4 getsid()函数</h3><p>获取进程所属的会话 ID</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数返回值</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>成功：返回调用进程的会话 ID</p></li><li class="lvl-2"><p>失败：-1，设置 errno</p></li></ul><p><mark>pid 为 0 表示察看当前进程 session ID</mark></p><blockquote><p>使用这两个函数的注意事项:</p><p>1.调用这个函数的进程不能是组长进程，如果是,该函数调用失败，如何保证这个函数能调用成功呢？</p><ul class="lvl-1"><li class="lvl-2"><p>先 fork () 创建子进程，终止父进程，让子进程调用这个函数</p></li></ul><p>2.如果调用这个函数的进程不是进程组长，会话创建成功</p><ul class="lvl-1"><li class="lvl-2"><p>这个进程会变成当前会话中的第一个进程，同时也会变成新的进程组的组长</p></li><li class="lvl-2"><p>该函数调用成功之后，当前进程就脱离了控制终端，因此不会阻塞终端</p></li></ul></blockquote><h3 id="1-5-创建守护进程">1.5 创建守护进程</h3><ol><li class="lvl-3"><p>创建子进程，父进程退出</p></li><li class="lvl-3"><p>在子进程中创建新会话 <code>setsid()函数</code> 使子进程完全独立出来，脱离控制</p></li><li class="lvl-3"><p>改变当前目录位置 <code>chdir()函数</code> 防止占用可卸载的文件系统, 也可以换成其它路径</p></li><li class="lvl-3"><p>重设文件权限掩码 <code>umask()</code>函数 防止继承的文件创建屏蔽字拒绝某些权限,增加守护进程灵活性</p></li><li class="lvl-3"><p>通常根据需要，关闭/重定向 文件描述符</p></li><li class="lvl-3"><p>开始执行守护进程业务逻辑，通常是while()循环</p></li></ol><p><strong>小案例</strong></p><blockquote><p>写一个守护进程，每隔 2s 获取一次系统时间，并将得到的时间写入到磁盘文件中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeFile</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 得到系统时间</span></span><br><span class="line">    <span class="type">time_t</span> seconds = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 时间转换, 总秒数 -&gt; 可以识别的时间字符串</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">loc</span> =</span> localtime(&amp;seconds);</span><br><span class="line">    <span class="comment">// sprintf();</span></span><br><span class="line">    <span class="type">char</span>* curtime = asctime(loc); <span class="comment">// 自带换行</span></span><br><span class="line">    <span class="comment">// 打开一个文件, 如果文件不存在, 就创建, 文件需要有追加属性</span></span><br><span class="line">    <span class="comment">// ./对应的是哪个目录? /home/robin</span></span><br><span class="line">    <span class="comment">// 0664 &amp; ~022</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./time+++++++.log&quot;</span>, O_WRONLY|O_CREAT|O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd, curtime, <span class="built_in">strlen</span>(curtime));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  perror(str);  </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 1. 创建子进程, 杀死父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程终止</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// kill(getpid(), 9); raise(9); abort();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 子进程, 将其变成会话, 脱离当前终端</span></span><br><span class="line">    pid = setsid();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      sys_err(<span class="string">&quot;setsid error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 修改进程的工作目录, 修改到一个不能被修改和删除的目录中 /home/robin</span></span><br><span class="line">    ret = chdir(<span class="string">&quot;/home/robin&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      sys_err(<span class="string">&quot;chdir error\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 设置掩码, 在进程中创建文件的时候这个掩码就起作用了</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 重定向和终端关联的文件描述符 -&gt; /dev/null</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    dup2(fd, STDIN_FILENO);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 委托内核捕捉并处理将来发生的信号-SIGALRM(14)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = writeFile;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 设置定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-线程">2.线程</h2><h3 id="2-1-什么是线程">2.1 什么是线程?</h3><p>线程是轻量级的进程（LWP：light weight process），在 Linux 环境下线程的本质仍是进程。在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。操作系统会以进程为单位，分配系统资源，可以这样理解，<mark>进程是资源分配的最小单位，线程是操作系统调度执行的最小单位</mark>。</p><p>进程：独立地址空间，拥有 PCB</p><p>线程：有独立的 PCB，但没有独立的地址空间(共享)</p><p>区别：在于是否共享地址空间。 独居(进程)；合租(线程)。</p><p><img src="https://img-blog.csdnimg.cn/2c7ecc24d9c04aed91526d59c2f436d1.png#pic_center" alt=""></p><h3 id="2-2-Linux-内核线程实现原理-了解即可">2.2 Linux 内核线程实现原理(了解即可)</h3><p>类 Unix 系统中，早期是没有“线程”概念的，80 年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p><ol><li class="lvl-3"><p>轻量级进程(light-weight process)，也有 PCB，创建线程使用的底层函数和进程一样，都是 clone</p></li><li class="lvl-3"><p>从内核里看进程和线程是一样的，都有各自不同的 PCB，但是 PCB 中指向内存资源的三级页表是相同的</p></li><li class="lvl-3"><p>进程可以蜕变成线程</p></li><li class="lvl-3"><p>线程可看做寄存器和栈的集合</p></li><li class="lvl-3"><p>在 linux 下，线程最是小的执行单位；进程是最小的分配资源单位查看 LWP 号：<code>ps –Lf pid</code> 查看指定线程的 lwp 号(线程号)。</p></li></ol><p>三级映射：进程 PCB --&gt; 页目录(可看成数组，首地址位于 PCB 中) --&gt; 页表 --&gt; 物理页面 --&gt; 内存单元对于进程来说，相同的地址(同一个虚拟地址)在不同的进程中，反复使用而不冲突。原因是他们虽虚拟地址一样，但，页目录、页表、物理页面各不相同。相同的虚拟地址，映射到不同的物理页面内存单元，最终访问不同的物理页面。但！线程不同！两个线程具有各自独立的 PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个 PCB 共享一个地址空间。 实际上，无论是创建进程的 fork，还是创建线程的 pthread_create，底层实现都是调用同一个内核函数 clone。 如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。 因此：<mark>Linux 内核是不区分进程和线程的</mark>。只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p><p><img src="https://img-blog.csdnimg.cn/432c1e93d9994c2b85b6a4193b0082d9.png#pic_center" alt=""></p><h3 id="2-4-线程共享资源和非共享资源">2.4 线程共享资源和非共享资源</h3><p><strong>共享资源</strong></p><p>1.文件描述符表</p><p>2.每种信号的处理方式</p><p>3.当前工作目录</p><p>4.用户 ID 和组 ID</p><p>5.内存地址空间 (.text/.data/.bss/heap/共享库)</p><p><strong>非共享资源</strong></p><p>1.线程 id</p><p>2.处理器现场和栈指针(内核栈)</p><p>3.独立的栈空间(用户空间栈)</p><p>4.errno 变量</p><p>5.信号屏蔽字</p><p>6.调度优先级</p><p><strong>线程优缺点</strong></p><p>优点： 1. 提高程序并发性 2. 开销小 3. 数据通信、共享数据方便</p><p>缺点： 1. 库函数，不稳定 2. 调试、编写困难、gdb 不支持 3. 对信号支持不好</p><p>优点相对突出，缺点均不是硬伤。Linux 下由于实现方法导致进程、线程差别不是很大。</p><h2 id="3-创建线程">3.创建线程</h2><h3 id="3-1-线程函数">3.1 线程函数</h3><p>每一个线程都有一个唯一的线程 ID，ID 类型为 <code>pthread_t</code>，这个 ID 是一个无符号长整形数(%lu)，如果想要得到当前线程的线程 ID，可以调用如下函数：</p><p><code>pthread_t pthread_self(void);// 返回当前线程的线程ID</code></p><p>在一个进程中调用线程创建函数，就可得到一个子线程，和进程不同，需要给每一个创建出的线程指定一个处理函数，否则这个线程无法工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数:</p><ul class="lvl-2"><li class="lvl-4">thread: 传出参数，是无符号长整形数，线程创建成功，会将线程 ID 写入到这个指针指向的内存中</li><li class="lvl-4">attr: 线程的属性，一般情况下使用默认属性即可，写 NULL</li><li class="lvl-4">start_routine: 函数指针，创建出的子线程的处理动作，也就是该函数在子线程中执行。</li><li class="lvl-4">arg: 作为实参传递到 start_routine 指针指向的函数内部</li></ul></li><li class="lvl-2"><p>返回值：线程创建成功返回 0，创建失败直接返回对应的错误号，不会设置errono，所以用<code>perror()</code>是行不通的，这点要注意，应直接用<code>strerror()</code></p></li></ul><p><strong>小案例</strong></p><blockquote><p>循环创建多个子线程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = *((<span class="type">int</span> *)arg);<span class="comment">//接收从主线程传递过来的地址，因此后面的i读取的都是主线程中的i</span></span><br><span class="line">sleep(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am %dth thread:pid = %d, tid = %lu\n&quot;</span>, i+<span class="number">1</span>, getpid(), pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, (<span class="type">void</span> *)&amp;i);<span class="comment">//将主线程的i的地址传递进去，会出错</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span> ,<span class="string">&quot;create error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">sleep(i);<span class="comment">//主线程执行完之后，就销毁了整个进程的地址空间，子线程就会无法打印，所以应该让主线程睡一会，等待子线程的执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am main pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/d25699f6eb9143d39b60c01421ee64e7.png#pic_center" alt=""></p><p>可以看到，不符合我们的预期想法，错误原因在于，子线程将主线程中i的地址传递了进去，因此子线程运行时会去读取主线程里的i值，而主线程里的i是动态变化的，不固定。所以，应该传递值而不是地址。</p><p>修改的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = (<span class="type">long</span>)arg;<span class="comment">//注意这里要强转成long类型，因为64位linux系统，指针占8个字节，int占4个字节，如果强转成int会造成精度的丢失</span></span><br><span class="line">sleep(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am %dth thread:pid = %d, tid = %lu\n&quot;</span>, i+<span class="number">1</span>, getpid(), pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, (<span class="type">void</span> *)i);<span class="comment">//按值进行传递</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span> ,<span class="string">&quot;create error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">sleep(i);<span class="comment">//主线程执行完之后，就销毁了整个进程的地址空间，子线程就会无法打印，所以应该让主线程睡一会，等待子线程的执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am main pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/4225514e3dd3404e86320a840b55fcc1.png#pic_center" alt=""></p><p><strong>注意</strong></p><p>编译时，要指定参数<code>-lpthread</code><a href="http://xn--libpthread-c42qx27fysin8ewtn.so">指定动态库libpthread.so</a></p><h3 id="3-2-线程间全局变量共享">3.2 线程间全局变量共享</h3><blockquote><p>直接看个代码，在子线程里更改全局变量，看主线程里的该变量有啥变化：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/229bc3a046ca4e9aa7784942f6d85001.png#pic_center" alt=""></p><p>编译运行，结果如下</p><p><img src="https://img-blog.csdnimg.cn/017f140f5e7f472284e9965e106e5d78.png#pic_center" alt=""></p><p>可以看到，子线程里更改全局变量后，主线程里也跟着发生变化。</p><h2 id="3-线程退出">3.线程退出</h2><p>在编写多线程程序的时候，如果想要让线程退出，但是不会导致虚拟地址空间的释放（针对于主线程），我们就可以调用线程库中的线程退出函数，只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数：线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为 NULL</p></li></ul><p><strong>注意区别三者</strong></p><ul class="lvl-0"><li class="lvl-2"><p>exit();  退出当前进程。</p></li><li class="lvl-2"><p>return: 返回到调用者那里去。</p></li><li class="lvl-2"><p>pthread_exit(): 退出当前线程。</p></li></ul><blockquote><p>下面是线程退出的示例代码，可以在任意线程的需要的位置调用该函数：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);<span class="comment">// 直接退出子线程</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用退出函数退出, 地址空间不会被释放</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下:</p><p><img src="https://img-blog.csdnimg.cn/629237f76abb4fc787aa8db7ffa83f5e.png#pic_center" alt=""></p><h2 id="4-线程回收">4.线程回收</h2><h3 id="4-1线程回收函数">4.1线程回收函数</h3><p>线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做 <code>pthread_join()</code>，这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p><p>另外通过线程回收函数还可以获取到子线程退出时传递出来的数据，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这是一个阻塞函数, 子线程在运行这个函数就阻塞</span></span><br><span class="line"><span class="comment">// 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数:</p><ul class="lvl-2"><li class="lvl-4">thread: 要被回收的子线程的线程 ID</li><li class="lvl-4">retval: 二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了 pthread_exit () 传递出的数据，如果不需要这个参数，可以指定为 NULL</li></ul></li><li class="lvl-2"><p>返回值：线程回收成功返回 0，回收失败返回错误号。</p></li></ul><h3 id="4-2-回收子线程数据">4.2 回收子线程数据</h3><p>在子线程退出的时候可以使用 pthread_exit() 的参数将数据传出，在回收这个子线程的时候可以通过 phread_join() 的第二个参数来接收子线程传递出的数据。接收数据有很多种处理方式，下面来举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span> <span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">working</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 使用全局变量</span></span><br><span class="line">p.age = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">p.id = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">pthread_exit(&amp;p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"><span class="comment">// 1. 创建一个子线程</span></span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line"><span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line"><span class="type">void</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line"><span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">pthread_join(tid, &amp;ptr);</span><br><span class="line"><span class="comment">// 打印信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> *<span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion *)ptr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/c83fd72f42924e67b59ade17e67dae43.png#pic_center" alt=""></p><h2 id="5-线程分离">5.线程分离</h2><p>在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用<code> pthread_join()</code> 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。</p><p>在线程库函数中为我们提供了线程分离函数<code> pthread_detach()</code>，调用这个函数之后<code>指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了</code>。线程分离之后在主线程中使用 <code>pthread_join()</code> 就回收不到子线程资源了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p><strong>小案例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子线程和主线程分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程自己退出即可</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-线程取消">6.线程取消</h2><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//杀死一个线程。需要到达取消点（保存点）,即进行一次系统调用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数：</p><ul class="lvl-2"><li class="lvl-4"><code>thread:</code> 待杀死的线程id</li></ul></li><li class="lvl-2"><p>返回值：</p><ul class="lvl-2"><li class="lvl-4">成功：0</li><li class="lvl-4">失败：直接返回错误号errno</li></ul></li></ul><p>如果，子线程没有到达取消点(即系统调用)， 那么 <code>pthread_cancel</code> 无效。   我们可以在程序中，手动添加一个取消点。使用 <code>pthread_testcancel()</code>; 成功被 <code>pthread_cancel() </code>杀死的线程，返回 -1.使用<code>pthead_join</code> 回收。</p><p><strong>小案例</strong></p><blockquote><p>主线程调用pthread_cancel杀死子线程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread: pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());  </span><br><span class="line">        sleep(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;  </span><br><span class="line">    <span class="type">pthread_t</span> tid;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);  </span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error:%s\n&quot;</span>, strerror(ret));  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());  </span><br><span class="line">  </span><br><span class="line">    sleep(<span class="number">5</span>);  </span><br><span class="line">  </span><br><span class="line">    ret = pthread_cancel(tid);          <span class="comment">// 终止线程  </span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_cancel error:%s\n&quot;</span>, strerror(ret));  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>编译运行，结果如下</p><p><img src="https://img-blog.csdnimg.cn/3d93b29b9d074154ac2fd90705bc726c.png#pic_center" alt=""></p><p><strong>终止线程方式</strong>：</p><p>总结：终止某个线程而不终止整个进程，有三种方法：</p><ol><li class="lvl-3"><p>从线程主函数 <code>return</code>。这种方法对主控线程不适用，从main 函数 return 相当于调用 exit。</p></li><li class="lvl-3"><p>一个线程可以调用 <code>pthread_cancel</code> 终止同一进程中的另一个线程。</p></li><li class="lvl-3"><p>线程可以调用 <code>pthread_exit </code>终止自己。</p></li></ol><h2 id="7-控制原语对比">7.控制原语对比</h2><p><img src="https://img-blog.csdnimg.cn/ccbdcb3511a64de895cd6edc527ce4ce.png#pic_center" alt=""></p><h2 id="8-线程属性">8.线程属性</h2><h3 id="8-1-基本概念">8.1 基本概念</h3><p>linux 下线程的属性是可以根据实际项目需要，进行设置。之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> detachstate; <span class="comment">//线程的分离状态</span></span><br><span class="line">    <span class="type">int</span> schedpolicy; <span class="comment">//线程的调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>　<span class="title">sched</span> <span class="title">schedparam</span>;</span><span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="type">int</span> inheritsched; <span class="comment">//线程的继承性</span></span><br><span class="line">    <span class="type">int</span> scope; <span class="comment">//线程的作用域</span></span><br><span class="line">    <span class="type">size_t</span> guardsize; <span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="type">int</span> stackaddr_set; <span class="comment">//线程栈的设置</span></span><br><span class="line">    <span class="type">void</span>* stackaddr; <span class="comment">//线程栈的启始位置</span></span><br><span class="line">    <span class="type">size_t</span> stacksize; <span class="comment">//线程栈大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure><p>主要结构体成员：</p><ol><li class="lvl-3"><p>线程分离状态</p></li><li class="lvl-3"><p>线程栈大小（默认平均分配）</p></li><li class="lvl-3"><p>线程栈警戒缓冲区大小（位于栈末尾）</p></li></ol><p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为 <code>pthread_attr_init</code>，这个函数必须在 <code>pthread_create </code>函数之前调用。之后须用 <code>pthread_attr_destroy</code> 函数来释放资源。</p><p>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、 分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</p><h3 id="8-1线程属性设置分离线程">8.1线程属性设置分离线程</h3><p>1 .<code>pthread_attr_t attr</code>   创建一个线程属性结构体变量</p><p>2 .<code>pthread_attr_init(&amp;attr); </code> 初始化线程属性</p><p>3 .<code>pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</code>   设置线程属性为 分离态</p><p>4 .<code>pthread_create(&amp;tid, &amp;attr, tfn, NULL);</code> 借助修改后的 设置线程属性 创建为分离态的新线程</p><p>5 .<code>pthread_attr_destroy(&amp;attr); </code> 销毁线程属性</p><p><strong>小案例</strong></p><blockquote><p>调整线程状态，使线程创建出来就是分离态，代码如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread: pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">pthread_t</span> tid;  </span><br><span class="line"></span><br><span class="line"><span class="type">pthread_attr_t</span> attr;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = pthread_attr_init(&amp;attr);  </span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;attr_init error:%s\n&quot;</span>, strerror(ret));  </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">ret = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);      <span class="comment">// 设置线程属性为 分离属性  </span></span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;attr_setdetachstate error:%s\n&quot;</span>, strerror(ret));  </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">ret = pthread_create(&amp;tid, &amp;attr, tfn, <span class="literal">NULL</span>);  </span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line">perror(<span class="string">&quot;pthread_create error&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">ret = pthread_attr_destroy(&amp;attr);  </span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;attr_destroy error:%s\n&quot;</span>, strerror(ret));  </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">ret = pthread_join(tid, <span class="literal">NULL</span>);  </span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error:%s\n&quot;</span>, strerror(ret));  </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main: pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());  </span><br><span class="line"></span><br><span class="line">pthread_exit((<span class="type">void</span> *)<span class="number">0</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译运行，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/5f6ca946b7134cc485cc88b0d46c705e.png#pic_center" alt=""></p><p>如图，<code>pthread_join</code>报错，说明线程已经自动回收，设置分离成功。</p><h2 id="9-线程使用注意事项">9.线程使用注意事项</h2><ol><li class="lvl-3"><p>主线程退出其他线程不退出，主线程应调用 <code>pthread_exit</code></p></li><li class="lvl-3"><p>避免僵尸线程</p><p><code>pthread_join </code></p><p><code>pthread_detach </code></p><p><code>pthread_create</code> 指定分离属性</p><p>被 join 线程可能在 join 函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;</p></li><li class="lvl-3"><p><code>malloc</code> 和<code>mmap </code>申请的内存可以被其他线程释放</p></li><li class="lvl-3"><p>应避免在多线程模型中调用 <code>fork</code> 除非，马上 <code>exec</code>，子进程中只有调用 <code>fork</code> 的线程存在，其他线程在子进程中均 <code>pthread_exit</code></p></li><li class="lvl-3"><p>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</p></li></ol>]]></content>
    
    
    <summary type="html">Linux系统编程之守护进程、线程</summary>
    
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="守护进程" scheme="https://billysturate.github.io/tags/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="https://billysturate.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程之信号</title>
    <link href="https://billysturate.github.io/posts/8ab680c7.html"/>
    <id>https://billysturate.github.io/posts/8ab680c7.html</id>
    <published>2022-09-01T10:13:54.000Z</published>
    <updated>2023-01-29T08:09:07.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-信号的概念">1.信号的概念</h2><p>信号在我们的生活中随处可见， 如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪… 他们都有<strong>共性</strong>：1. <code>简单</code> 2. <code>不能携带大量信息</code> 3.</p><p><code>满足某个特设条件才发送</code>。</p><p>信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</p><p>Unix 早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T 都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1 对可靠信号例程进行了标准化。</p><h2 id="2-信号的机制">2.信号的机制</h2><p>A 给 B 发送信号，B 收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行， 去处理信号，处理完毕再继续执行。与硬件中断类</p><p>似——<code>异步模式</code>。但信号是<code>软件层面上实现的中断</code>，早期常被称 为<code>“软中断”</code>。</p><p><strong>信号的特质：</strong> 由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。</p><p><mark>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</mark></p><h2 id="3-与信号相关的事件和状态">3.与信号相关的事件和状态</h2><p><strong>产生信号:</strong></p><ol><li class="lvl-3"><p>按键产生，如：<code>Ctrl+c</code>、<code>Ctrl+z</code>、<code>Ctrl+\ </code></p></li><li class="lvl-3"><p>系统调用产生，如：<code>kill</code>、<code>raise</code>、<code>abort </code></p></li><li class="lvl-3"><p>软件条件产生，如：定时器 <code>alarm </code></p></li><li class="lvl-3"><p>硬件异常产生，如：非法访问内存(段错误)、除 0(浮点数例外)、内存对齐出错(总线错误)</p></li><li class="lvl-3"><p>命令产生，如：<code>kill</code> 命令</p></li></ol><p><strong>递达：</strong> 递送并且到达进程。</p><p><strong>未决：</strong> 产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。</p><p><strong>信号的处理方式:</strong></p><ol><li class="lvl-3"><p>执行默认动作</p></li><li class="lvl-3"><p>忽略(丢弃)</p></li><li class="lvl-3"><p>捕捉(调用户处理函数)</p></li></ol><h2 id="4-信号屏蔽字和未决信号集">4.信号屏蔽字和未决信号集</h2><p>Linux 内核的进程控制块 <code>PCB</code> 是一个结构体，<code>task_struct,</code> 除了包含进程 id，状态，工作目录，用户 id，组 id， 文件描述符表，还包含了信号相关的信息，主要指<code>阻塞信号集</code>和<code>未决信号集</code>。</p><p><strong>阻塞信号集(信号屏蔽字)：</strong></p><p>本质：位图。用来记录信号的屏蔽状态。一旦被屏蔽的信号，在解除屏蔽前，一直处于未决态。</p><p><strong>未决信号集:</strong></p><ol><li class="lvl-3"><p>本质：位图。</p></li><li class="lvl-3"><p>信号产生,未决信号集中描述该信号的位立刻翻转为 1，表信号处于未决状态。当信号被处理对应位翻转回为 0。这一时刻往往非常短暂。</p></li><li class="lvl-3"><p>信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</p></li></ol><blockquote><p>阻塞信号集和未决信号集在内核中的结构是相同的，它们都是一个整形数组 (被封装过的), 一共 128 字节 （int [32] == 1024 bit），1024 个标志位，其中前 31 个标志位，每一个都对应一个 Linux 中的标准信号，通过标志位的值来标记当前信号在信号集中的状态。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/6adf7f79ed39494cb0ff6b6ef4bc9456.png#pic_center" alt=""></p><h2 id="5-信号四要素和常规信号一览">5.信号四要素和常规信号一览</h2><h3 id="5-1-信号的编号">5.1 信号的编号</h3><p>可以使用 <code>kill –l</code> 命令查看当前系统可使用的信号有哪些。</p><p><img src="https://img-blog.csdnimg.cn/5cca8b1728c64a4f875916ec278a2026.png#pic_center" alt=""></p><p>不存在编号为 0 的信号。其中 1-31 号信号称之为<code>常规信号（也叫普通信号或标准信号）</code>，34-64 称之为<code>实时信号</code>，驱动编程与硬件相关。名字上区别不大。而前 32 个名字各不相同。</p><h3 id="5-2-信号-4-要素">5.2 信号 4 要素</h3><p>与变量三要素类似的，每个信号也有其必备 4 要素，分别是：</p><ol><li class="lvl-3"><p>编号 2. 名称 3. 事件 4. 默认处理动作</p></li></ol><p><strong>注意：</strong> 信号使用之前，应先确定其4要素，而后再用！！！</p><p>可通过<code>man 7 signal </code>查看帮助文档获取。</p><p><img src="https://img-blog.csdnimg.cn/ef182349353d43d0b8ad8f2b3d672275.png#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/ce60102d722149d9b4fb73f10f2f1e94.png#pic_center" alt=""></p><p>默认动作：</p><ul class="lvl-0"><li class="lvl-2"><p>Term：终止进程</p></li><li class="lvl-2"><p>Ign： 忽略信号 (默认即时对该种信号忽略操作)</p></li><li class="lvl-2"><p>Core：终止进程，生成 Core 文件。(查验进程死亡原因， 用于 gdb 调试)</p></li><li class="lvl-2"><p>Stop：停止（暂停）进程</p></li><li class="lvl-2"><p>Cont：继续运行进程</p></li></ul><p>这里特别强调了 <mark>9) SIGKILL</mark> 和 <mark>19) SIGSTOP</mark>信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</p><p><strong>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！！</strong></p><h3 id="5-3-Linux-常规信号一览表">5.3 Linux 常规信号一览表</h3><ol><li class="lvl-3"><p>SIGHUP: 当用户退出 shell 时，由该 shell 启动的所有进程将收到这个信号，默认动作为终止进程</p></li><li class="lvl-3"><p>SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。</p></li><li class="lvl-3"><p>SIGQUIT：当用户按下&lt;ctrl+\&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。</p></li><li class="lvl-3"><p>SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生 core 文件</p></li><li class="lvl-3"><p>SIGTRAP：该信号由断点指令或其他 trap 指令产生。默认动作为终止里程 并产生 core 文件。</p></li><li class="lvl-3"><p>SIGABRT: 调用 abort 函数时产生该信号。默认动作为终止进程并产生 core 文件。</p></li><li class="lvl-3"><p>SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生 core 文件。</p></li><li class="lvl-3"><p>SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等所有的算法错误。默认动作为终止进程并产生 core 文件。</p></li><li class="lvl-3"><p>SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。</p></li><li class="lvl-4"><p>SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生 core 文件。</p></li><li class="lvl-4"><p>SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGPIPE：Broken pipe 向一个没有读端的管道写数据。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGALRM: 定时器超时，超时的时间 由系统调用 alarm 设置。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGTERM：程序结束信号，与 SIGKILL 不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行 shell 命令 Kill 时，缺省产生这个信号。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGSTKFLT：Linux 早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGCHLD：子进程状态发生变化时，父进程会收到这个信号。默认动作为忽略这个信号。</p></li><li class="lvl-4"><p>SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。</p></li><li class="lvl-4"><p>SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。</p></li><li class="lvl-4"><p>SIGTSTP：停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号。默认动作为暂停进程。</p></li><li class="lvl-4"><p>SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。</p></li><li class="lvl-4"><p>SIGTTOU: 该信号类似于 SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。</p></li><li class="lvl-4"><p>SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。</p></li><li class="lvl-4"><p>SIGXCPU：进程执行时间超过了分配给该进程的 CPU 时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGVTALRM：虚拟时钟超时时产生该信号。类似于 SIGALRM，但是该信号只计算该进程占用 CPU 的使用时间。默认动作为终止进程。</p></li><li class="lvl-4"><p>SGIPROF：类似于 SIGVTALRM，它不公包括该进程占用 CPU时间还包括执行系统调用时间。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。</p></li><li class="lvl-4"><p>SIGIO：此信号向进程指示发出了一个异步 IO 事件。默认动作为忽略。</p></li><li class="lvl-4"><p>SIGPWR：关机。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGSYS：无效的系统调用。默认动作为终止进程并产生 core 文件。</p></li><li class="lvl-4"><p>SIGRTMIN ～ (64) SIGRTMAX：LINUX 的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。</p></li></ol><h2 id="6-信号的产生">6.信号的产生</h2><h3 id="6-1-终端按键产生信号">6.1 终端按键产生信号</h3><p><code>Ctrl + c</code> → 2) <code>SIGINT</code>（终止/中断） “INT” ----Interrupt</p><p><code>Ctrl + z</code>→ 20) <code>SIGTSTP</code>（暂停/停止） “T” ----Terminal 终端。</p><p><code>Ctrl + \</code>→ 3) <code>SIGQUIT</code>（退出）</p><h3 id="6-2-硬件异常产生信号">6.2 硬件异常产生信号</h3><p>除 0 操作 → 8) <code>SIGFPE</code> (浮点数例外)</p><p>非法访问内存 → 11) <code>SIGSEGV</code> (段错误)</p><p>总线错误 → 7) <code>SIGBUS</code></p><h3 id="6-4-kill-函数-命令产生信号">6.4 kill 函数/命令产生信号</h3><p><strong>函数原型:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 给某一个进程发送一个信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数：</strong></p><p>​pid: &gt; 0：发送信号给指定进程</p><p>​= 0：发送信号给跟调用kill函数的那个进程处于同一进程组的进程。</p><p>​&lt; -1：取绝对值，发送信号给该绝对值所对应的进程组的所有组员。</p><p>​= -1：发送信号给，有权限发送的所有进程。</p><p>​signum：待发送的信号</p><p><strong>函数返回值：</strong></p><p>​成功： 0</p><p>​失败： -1 errno</p><p><strong>小案例</strong></p><blockquote><p>子进程发送信号kill父进程：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/55ab221a96504e2da8b8147e4179ebeb.png#pic_center" alt=""></p><p>​</p><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/b10af39467f14c88be9c81bb79c6a8e3.png#pic_center" alt=""></p><blockquote><p>kill -9 -groupname  杀一个进程组</p></blockquote><h2 id="7-定时器">7.定时器</h2><h3 id="7-1-alarm-函数">7.1 alarm()函数</h3><p>设置定时器(闹钟)。在指定 seconds 后，内核会给当前进程发送 <code>14）SIGALRM 信号</code>。进程收到该信号，默认动作终止。<mark>每个进程都有且只有唯一个定时器。</mark></p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数：</strong></p><p>倒计时 seconds 秒，倒计时完成发送一个信号 <code>SIGALRM</code> , 当前进程会收到这个信号，这个信号默认的处理动作是中断当前进程</p><p><strong>函数返回值：</strong></p><p>大于 0 表示倒计时还剩多少秒，返回值为 0 表示倒计时完成，信号被发出</p><p><strong>小案例:</strong></p><blockquote><p>使用这个定时器函数，检测一下当前计算机 1s 钟之内能数多少个数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 设置一个定时器, 定时1s</span></span><br><span class="line">    alarm(<span class="number">1</span>);<span class="comment">// 1s之后会发出一个信号, 这个信号将中断当前进程</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 time 命令查看程序执行的时间。 程序运行的瓶颈在于 IO，优化程序，首选优化 IO。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接通过终端输出</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">time ./a.out</span></span><br><span class="line">real    0m1.013s# 实际数数用的总时间</span><br><span class="line">user    0m0.060s# 用户区代码使用的时间</span><br><span class="line">sys     0m0.324s# 内核区使用的时间</span><br><span class="line"></span><br><span class="line">real = user + sys + 消耗的时间(频率的从用户区到内核区进程切换)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不直接写终端, 将数据重定向到磁盘文件中</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">time ./a.out &gt; a.txt</span></span><br><span class="line">Alarm clock</span><br><span class="line"></span><br><span class="line">real    0m1.002s    # 用户实际数数的时间变长了</span><br><span class="line">user    0m0.740s</span><br><span class="line">sys     0m0.236s</span><br></pre></td></tr></table></figure><p><mark>实际执行时间 = 系统时间 + 用户时间 + 等待时间</mark></p><h3 id="7-2-setitimer-函数">7.2 setitimer()函数</h3><p>设置定时器(闹钟)。 可代替 <code>alarm</code> 函数。精度微秒 us，可以实现周期定时。</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以实现周期性定时, 每个一段固定的时间, 发出一个特定的定时器信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, </span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>which</code>：指定定时方式</p><p>① 自然定时：<code>ITIMER_REAL</code> → 14）SIGLARM 计算自然时间</p><p>② 虚拟空间计时(用户空间)：<code>ITIMER_VIRTUAL</code> → 26）SIGVTALRM 只计算进程占用 cpu 的时间</p><p>③ 运行时计时(用户+内核)：<code>ITIMER_PROF </code>→ 27）SIGPROF 计算占用 cpu 及执行系统调用的时间</p></li><li class="lvl-2"><p><code>new_value: </code>给定时器设置定时秒数，传入参数</p></li><li class="lvl-2"><p><code>old_value:</code> 上一次给定时器设置的定时信息，传出参数，如果不需要这个信息，指定为 NULL</p></li></ul><p><strong>函数返回值：</strong></p><p>​成功： 0</p><p>​失败： -1 errno</p><p><strong>类型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line"><span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;it_interval;---&gt; 用于设定两个定时任务之间的间隔时间</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span>      tv_sec;         </span><br><span class="line"><span class="type">suseconds_t</span> tv_usec;        </span><br><span class="line">&#125;it_value;  ---&gt; 第一次定时秒数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以理解为有2个定时器</p><ul class="lvl-0"><li class="lvl-2"><p>一个用于第一个闹钟什么时候触发打印</p></li><li class="lvl-2"><p>一个用于之后间隔多少时间再次触发闹钟。</p></li></ul><p><strong>小案例</strong></p><blockquote><p>使用setitimer定时，向屏幕打印信息：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/530127108e5f459b88e4f2661c9c54da.png#pic_center" alt=""></p><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/44bc3eaa9b39435b8ffcf24c1da9e529.png#pic_center" alt=""></p><p>第一次信息打印是两秒间隔，之后都是5秒间隔打印一次</p><h2 id="8-信号集操作函数">8.信号集操作函数</h2><p>内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字 mask 可以影响未决信号集。而我们可以在应 用程序中自定义 set 来改变mask。已达到屏蔽指定</p><p>信号的目的。因为用户是不能直接操作内核中的阻塞信号集和未决信号集的，必须要调用系统函数，关于阻塞信号集可以通过系统函数进行读写操作，未决信号集</p><p>只能对其进行读操作。</p><p><img src="https://img-blog.csdnimg.cn/496e997a408c479ab33f9665a5b16102.png#pic_center" alt=""></p><h3 id="8-1-信号集设定">8.1 信号集设定</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 如果在程序中读写 sigset_t 类型的变量</span></span><br><span class="line"><span class="comment">// 阻塞信号集和未决信号集都存储在 sigset_t 类型的变量中, 这个变量对应一块内存</span></span><br><span class="line"><span class="comment">// 阻塞信号集和未决信号集, 对应的内存中有1024bit = 128字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将set集合中所有的标志位设置为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;成功：<span class="number">0</span>；失败：<span class="number">-1</span></span><br><span class="line"><span class="comment">// 将set集合中所有的标志位设置为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;成功：<span class="number">0</span>；失败：<span class="number">-1</span></span><br><span class="line"><span class="comment">// 将set集合中某一个信号(signum)对应的标志位设置为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;成功：<span class="number">0</span>；失败：<span class="number">-1</span></span><br><span class="line"><span class="comment">// 将set集合中某一个信号(signum)对应的标志位设置为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;成功：<span class="number">0</span>；失败：<span class="number">-1</span></span><br><span class="line"><span class="comment">// 判断某个信号在集合中对应的标志位到底是0还是1, 如果是0返回0, 如果是1返回1(相当于判断某个信号是否在集合中)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;返回值：在集合：<span class="number">1</span>；不在：<span class="number">0</span>； 出错：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><code>sigset_t</code> 类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</p><h3 id="8-2-sigprocmask-函数">8.2 sigprocmask()函数</h3><p>用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB 中) 严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 使用这个函数修改内核中的阻塞信号集</span></span><br><span class="line"><span class="comment">// sigset_t 被封装之后得到的数据类型, 原型:int[32], 里边一共有1024个标志位, 每一个信号对应一个标志位</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数:</strong><br><code>how:</code></p><ul class="lvl-0"><li class="lvl-2"><p><code>SIG_BLOCK:</code> 当 how设置为此值，set 表示需要屏蔽的信号。相当于 mask = mask|set</p></li><li class="lvl-2"><p><code>SIG_UNBLOCK:</code> 当 how设置为此，set 表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~set</p></li><li class="lvl-2"><p><code>SIG_SETMASK: </code>使用参数 set 集合中的数据覆盖内核的阻塞信号集数据</p></li></ul><p><code>set:</code></p><p>传入参数，是一个位图，set 中哪位置 1，就表示当前进程屏蔽哪个信号。</p><p><code>oldset:</code></p><p>传出参数，保存旧的信号屏蔽集，如果不需要可以指定为 NULL</p><p><strong>函数返回值：</strong></p><p>函数调用成功返回 0，调用失败返回 - 1</p><h3 id="8-4-sigpending-函数">8.4 sigpending() 函数</h3><p>读取当前进程的未决信号集</p><p><code>int sigpending(sigset_t *set);</code>  set 传出参数。 返回值：成功：0；失败：-1，设置 errno</p><p><strong>小案例</strong></p><blockquote><p>需求:<br>在阻塞信号集中设置某些信号阻塞, 通过一些操作产生这些信号, 然后读未决信号集, 最后再解除这些信号的阻塞假设阻塞这些信号:</p><ul class="lvl-1"><li class="lvl-2">2号信号: SIGINT: ctrl+c</li><li class="lvl-2">3号信号: SIGQUIT: ctrl+\</li><li class="lvl-2">9号信号: SIGKILL: 通过shell命令给进程发送这个信号 kill -9 PID</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    <span class="comment">// 设置阻塞的信号</span></span><br><span class="line">    sigaddset(&amp;myset, SIGINT);  <span class="comment">// 2</span></span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT); <span class="comment">// 3</span></span><br><span class="line">    sigaddset(&amp;myset, SIGKILL); <span class="comment">// 9 测试不能被阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将初始化的信号集中的数据设置给内核</span></span><br><span class="line">    <span class="type">sigset_t</span> old;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, &amp;old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 让进程一直运行, 在当前进程中产生对应的信号</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 读内核的未决信号集</span></span><br><span class="line">        <span class="type">sigset_t</span> curset;</span><br><span class="line">        sigpending(&amp;curset);</span><br><span class="line">        <span class="comment">// 遍历这个信号集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret = sigismember(&amp;curset, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 解除阻塞, 重新设置阻塞信号集</span></span><br><span class="line">            <span class="comment">//sigprocmask(SIG_UNBLOCK, &amp;myset, NULL);</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;old, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/ae723be5aa8a4726aba321385881098a.png#pic_center" alt=""></p><p><mark>通过测试最终得到结论：程序中对 9 号信号的阻塞是无效的，因为它无法被阻塞。</mark></p><h2 id="9-信号捕捉">9.信号捕捉</h2><p>Linux 中的每个信号产生之后都会有对应的默认处理行为，如果想要忽略这个信号或者修改某些信号的默认行为就需要在程序中捕捉该信号。程序中进行信号捕捉可以看做是一个注册的动作，提前告诉应用程序信号产生之后做什么样的处理，当进程中对应的信号产生了，这个处理动作也就被调用了。</p><h3 id="9-1-signal-函数">9.1 signal()函数</h3><p>使用<code> signal()</code> 函数可以捕捉进程中产生的信号，并且修改捕捉到的函数的行为，这个信号的自定义处理动作是一个回调函数，内核通过 <code>signal()</code> 得到这个回调函数的地址，在信号产生之后该函数会被内核调用。</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 在程序中什么时候产生信号, 程序猿是不知道的, 因此不能在信号产生之后再去处理</span></span><br><span class="line"><span class="comment">// 在信号产生之前, 提供一个注册函数, 用来捕捉信号</span></span><br><span class="line"><span class="comment">//  - 假设在将来这个信号产生了, 就委托内核进行捕捉, 这个信号的默认动作就不能被执行</span></span><br><span class="line"><span class="comment">//  - 执行什么样的处理动作 ==&gt; 在signal函数中指定的处理动作</span></span><br><span class="line"><span class="comment">//  - 如果这个信号不产生, 回调函数永远不会被调用</span></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;   </span><br></pre></td></tr></table></figure><p><strong>函数参数:</strong></p><p><code>signum:</code> 需要捕捉的信号</p><p><code>handler:</code> 信号捕捉到之后的处理动作，这是一个函数指针，函数原型<code>typedef void (*sighandler_t)(int);</code></p><p><mark>这个回调函数是需要程序猿写的，但是程序猿不调用，由内核调用，内核调用回调函数的时候，会给它传递一个实参，这个实参的值就是捕捉的那个信号值。</mark></p><p><strong>小案例</strong></p><blockquote><p>下面的测试程序中使用 signal () 函数来捕捉定时器产生的信号 SIGALRM：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">doing</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前捕捉到的信号是: %d\n&quot;</span>, arg);</span><br><span class="line">    <span class="comment">// 打印当前的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册要捕捉哪一个信号, 执行什么样的处理动作</span></span><br><span class="line">    signal(SIGALRM, doing);</span><br><span class="line">    <span class="comment">// 1. 调用定时器函数设置定时器函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">newact</span>;</span></span><br><span class="line">    <span class="comment">// 3s之后发出第一个定时器信号, 之后每隔1s发出一个定时器信号</span></span><br><span class="line">    newact.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    newact.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    newact.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">    newact.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个函数也不是阻塞函数, 函数调用成功, 倒计时开始</span></span><br><span class="line">    <span class="comment">// 倒计时过程中程序是继续运行的</span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;newact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写一个业务处理, 阻止当前进程自己结束, 让当前进程被发出的信号杀死</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下:</p><p><img src="https://img-blog.csdnimg.cn/b6371a8887794bd6b1734ee65ec86bd4.png#pic_center" alt=""></p><h3 id="9-2-sigaction-函数">9.2 sigaction()函数</h3><p><code>sigaction ()</code> 函数和 <code>signal ()</code> 函数的功能是一样的，用于捕捉进程中产生的信号，并将用户自定义的信号行为函数（回调函数）注册给内核，内核在信号产生之后调用这个处理动作。<code>sigaction ()</code> 可以看做是 <code>signal ()</code> 函数是加强版，函数参数更多更复杂，函数功能也更强一些。</p><p><strong>函数原型:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数:</strong></p><p><code>signum:</code> 要捕捉的信号</p><p><code>act:</code> 捕捉到信号之后的处理动作</p><p><code>oldact:</code> 上一次调用该函数进行信号捕捉设置的信号处理动作，该参数一般指定为 NULL</p><p><strong>函数返回值：</strong></p><p>函数调用成功返回 0，失败返回 - 1</p><p>该函数的参数是一个结构体类型，结构体原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);    <span class="comment">// 指向一个函数(回调函数)</span></span><br><span class="line"><span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line"><span class="type">sigset_t</span>   sa_mask;             <span class="comment">// 初始化为空即可, 处理函数执行期间不屏蔽任何信号</span></span><br><span class="line"><span class="type">int</span>        sa_flags;        <span class="comment">// 0</span></span><br><span class="line"><span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);  <span class="comment">//不用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sa_restorer</code>：该元素是过时的，不应该使用，POSIX.1 标准将不指定该元素。(弃用)</p><p><code>sa_sigaction</code>：当 <code>sa_flags</code> 被指定为 <code>SA_SIGINFO</code>标志时，使用该信号处理程序。(很少使用)</p><p><mark>重点掌握：</mark></p><p>① <code>sa_handler</code>：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为 <code>SIG_IGN</code>表忽略 或 <code>SIG_DFL</code> 表执行默认动作</p><p>② <code>sa_mask</code>: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</p><p>③ <code>sa_flags</code>：通常设置为 0，表使用默认属性。</p><p><strong>小案例</strong>：</p><blockquote><p>通过 sigaction () 捕捉阻塞信号集中解除阻塞的信号</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前捕捉的信号: %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    <span class="comment">// 设置阻塞的信号</span></span><br><span class="line">    sigaddset(&amp;myset, SIGINT);  <span class="comment">// 2</span></span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT); <span class="comment">// 3</span></span><br><span class="line">    sigaddset(&amp;myset, SIGKILL); <span class="comment">// 9 测试不能被阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当阻塞的信号被解除阻塞, 该信号就可以被捕捉到了</span></span><br><span class="line">    <span class="comment">// 如果信号被捕捉到之后, 马上就被处理掉了 --&gt; 递达状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = callback;</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 和sigint的处理动作相同</span></span><br><span class="line">    sigaction(SIGQUIT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGKILL, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将初始化的信号集中的数据设置给内核</span></span><br><span class="line">    <span class="type">sigset_t</span> old;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, &amp;old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 让进程一直运行, 在当前进程中产生对应的信号</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 读内核的未决信号集</span></span><br><span class="line">        <span class="type">sigset_t</span> curset;</span><br><span class="line">        sigpending(&amp;curset);</span><br><span class="line">        <span class="comment">// 遍历这个信号集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret = sigismember(&amp;curset, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 解除阻塞, 重新设置阻塞信号集</span></span><br><span class="line">            <span class="comment">//sigprocmask(SIG_UNBLOCK, &amp;myset, NULL);</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;old, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/e34f30b1f71f4040966f80b5dc068b4e.png#pic_center" alt=""></p><h3 id="9-3-信号捕捉的特性">9.3 信号捕捉的特性</h3><p>信号捕捉特性：</p><ol><li class="lvl-3"><p>捕捉函数执行期间，信号屏蔽字 由 mask --&gt; sa_mask , 捕捉函数执行结束。 恢复回mask</p></li><li class="lvl-3"><p>捕捉函数执行期间，本信号自动被屏蔽(sa_flgs = 0).其他信号不屏蔽，如需屏蔽则调用sigsetadd函数修改</p></li><li class="lvl-3"><p>捕捉函数执行期间，被屏蔽信号多次发送，解除屏蔽后只处理一次！</p></li></ol><h2 id="10-内核实现信号捕捉简析">10.内核实现信号捕捉简析</h2><p><img src="https://img-blog.csdnimg.cn/966b608837434932af7ff37393b4bfe4.png#pic_center" alt=""></p><h2 id="11-SIGCHLD-信号">11.SIGCHLD 信号</h2><h3 id="11-1-SIGCHLD-的产生条件">11.1 SIGCHLD 的产生条件</h3><ul class="lvl-0"><li class="lvl-2"><p>子进程终止时</p></li><li class="lvl-2"><p>子进程接收到SIGSTOP</p></li><li class="lvl-2"><p>子进程处于停止态，接收到SIGCONT后唤醒时</p></li></ul><h3 id="11-2-借助-SIGCHLD-信号回收子进程">11.2 借助 SIGCHLD 信号回收子进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收子进程处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">recycle</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号是: %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 子进程的资源回收, 非阻塞</span></span><br><span class="line">    <span class="comment">// SIGCHLD信号17号信号, 1-31号信号不支持排队</span></span><br><span class="line">    <span class="comment">// 如果这些信号同时产生多个, 最终处理的时候只处理一次</span></span><br><span class="line">    <span class="comment">// 假设多个子进程同时退出, 父进程同时收到了多个sigchld信号</span></span><br><span class="line">    <span class="comment">// 父进程只会处理一次这个信号, 因此当前函数被调用了一次, waitpid被调用一次</span></span><br><span class="line">    <span class="comment">// 相当于只回收了一个子进程, 但是是同时死了多个子进程, 因此就出现了僵尸进程</span></span><br><span class="line">    <span class="comment">// 解决方案: 循环回收即可</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是阻塞回收, 就回不到另外一个处理逻辑上去了</span></span><br><span class="line">        <span class="type">pid_t</span> pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child died, pid = %d\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有死亡的子进程, 直接退出当前循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;所有子进程都回收完毕了, 拜拜...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置sigchld信号阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    sigaddset(&amp;myset, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环创建多个子进程 - 20</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 注册信号捕捉, 捕捉sigchld</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags  =<span class="number">0</span>;</span><br><span class="line">        act.sa_handler = recycle;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        <span class="comment">// 注册信号捕捉, 委托内核处理将来产生的信号</span></span><br><span class="line">        <span class="comment">// 当信号产生之后, 当前进程优先处理信号, 之前的处理动作会暂停</span></span><br><span class="line">        <span class="comment">// 信号处理完毕之后, 回到原来的暂停的位置继续运行</span></span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解除sigcld信号的阻塞</span></span><br><span class="line">        <span class="comment">// 信号被阻塞之后,就捕捉不到了, 解除阻塞之后才能捕捉到这个信号</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程执行其他业务逻辑就可以了</span></span><br><span class="line">        <span class="comment">// 默认父进程执行这个while循环, 但是信号产生了, 这个执行逻辑或强迫暂停</span></span><br><span class="line">        <span class="comment">// 父进程去处理信号的处理函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SIGCHLD 信号注意问题</strong></p><ol><li class="lvl-3"><p>子进程继承父进程的信号屏蔽字和信号处理动作，但子进程没有继承未决信号集 spending。</p></li><li class="lvl-4"><p>注意注册信号捕捉函数的位置。</p></li><li class="lvl-4"><p>应该在 fork 之前，阻塞 SIGCHLD 信号。注册完捕捉函数后解除阻塞。</p></li></ol>]]></content>
    
    
    <summary type="html">Linux系统编程之信号</summary>
    
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="信号" scheme="https://billysturate.github.io/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程之进程间通信(IPC)</title>
    <link href="https://billysturate.github.io/posts/666d535d.html"/>
    <id>https://billysturate.github.io/posts/666d535d.html</id>
    <published>2022-08-28T10:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-IPC-方法">1.IPC 方法</h2><p>Linux 环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另 一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区， 进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为<code>进程间通信</code>（IPC，InterProcess Communication）。</p><p><img src="https://img-blog.csdnimg.cn/a3316833835a44c5b1c03c42af5cb4d7.png#pic_center" alt=""></p><p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套 接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：</p><p>① 管道 (使用最简单)</p><p>② 信号 (开销最小)</p><p>③ 共享映射区 (无血缘关系)</p><p>④ 本地套接字 (最稳定)</p><p>下面重点介绍管道，其余方式后续会再讲。</p><h2 id="2-匿名管道">2.匿名管道</h2><h3 id="2-1-什么是匿名管道">2.1 什么是匿名管道</h3><p>匿名管道是管道的一种，既然是匿名也就是说这个管道没有名字，但其本质是不变的，就是位于内核中的一块内存，匿名管道拥有上面介绍的管道的所有特性，额外的我们需要知道，匿名管道只能实现有血缘关系的进程间通信，什么叫<code>有血缘的进程关系</code>呢，比如：<code>父子进程</code>，<code>兄弟进程</code>，<code>爷孙进程</code>，<code>叔侄进程</code>。最后说一下创建匿名管道的函数<code>pipe()</code>，函数如下：</p><h3 id="2-2-pipe-函数">2.2 pipe() 函数</h3><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个匿名的管道, 得到两个可用的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数</strong>：</p><p>传出参数，需要传递一个整形数组的地址，数组大小为 2，也就是说最终会传出两个元素</p><ul class="lvl-0"><li class="lvl-2"><p>pipefd[0]: 对应管道读端的文件描述符，通过它可以将数据从管道中读出</p></li><li class="lvl-2"><p>pipefd[1]: 对应管道写端的文件描述符，通过它可以将数据写入到管道中</p></li></ul><p>向管道文件读写数据其实是在读写内核缓冲区。</p><p><strong>函数返回值</strong></p><p>成功返回 0，失败返回 -1</p><h3 id="2-3-管道特性">2.3 管道特性</h3><ol><li class="lvl-3"><p>其本质是一个伪文件(实为内核缓冲区,不占用磁盘大小)</p></li><li class="lvl-3"><p>有两个文件描述符引用，一个表示读端，一个表示写端。</p></li><li class="lvl-3"><p>规定数据从管道的写端流入管道，从读端流出。</p><p>管道的原理: 管道实为内核使用<code>环形队列机制</code>，借助<code>内核缓冲区(4k)实现</code>。</p><p>管道的局限性：</p><p>① 数据不能进程自己写，自己读。</p><p>② 管道中数据不可反复读取。一旦读走，管道中不再存在。</p><p>③ 采用<code>半双工通信方式</code>，数据只能在单方向上流动。</p><p>④ 只能在有公共祖先的进程间使用管道。</p><p>常见的通信方式有，<code>单工通信</code>、<code>半双工通信</code>、<code>全双工通信</code>。</p></li></ol><p>管道在内核中，不能直接对其进行操作，我们通过什么方式去读写管道呢？其实管道操作就是文件 IO 操作，内核中管道的两端分别对应两个文件描述符，通过写端的文件描述符把数据写入到管道中，通过读端的文件描述符将数据从管道中读出来。读写管道的函数就是 Linux 中的文件 IO 函数     <mark>点击查看</mark>-&gt; <a href="https://blog.csdn.net/qq_59084325/article/details/126471807?spm=1001.2014.3001.5501">read()/write()函数详解</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读管道</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">// 写管道的函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-4-父子进程间通信">2.4 父子进程间通信</h3><p><strong>父子进程通信原理</strong></p><p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？ 通常可以采用如下步骤：</p><p><img src="https://img-blog.csdnimg.cn/f040b683531c4b489caf6532dc8d7bf6.png#pic_center" alt=""></p><ol><li class="lvl-3"><p>父进程调用 <code>pipe </code>函数创建管道，得到两个文件描述符 fd[0]、fd[1]指向管道的读端和写端。</p></li><li class="lvl-3"><p>父进程调用 <code>fork</code> 创建子进程，那么子进程也有两个文件描述符指向同一管道。</p></li><li class="lvl-3"><p>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p></li></ol><p><strong>小练习</strong></p><blockquote><p>父进程往管道里写，子进程从管道读，然后打印读取的内容</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *str = <span class="string">&quot;hello pipe\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读段</span></span><br><span class="line">  <span class="comment">// sleep(3);  //防止终端提示和输出混杂在一起</span></span><br><span class="line">write(fd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd[<span class="number">1</span>]); <span class="comment">// 子进程关闭写段</span></span><br><span class="line">ret = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child read ret = %d\n&quot;</span>, ret);</span><br><span class="line">write(STDOUT_FILENO, buf, ret);</span><br><span class="line"></span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/510faf6738a7410cb1a142eb6aca135f.png#pic_center" alt=""></p><h3 id="2-5-管道读写行为">2.5 管道读写行为</h3><p><strong>读管道：</strong></p><p>1 .管道有数据，read返回实际读到的字节数。</p><p>2 .管道无数据：</p><ul class="lvl-0"><li class="lvl-2"><p>没有写端，read返回0 （类似读到文件尾）</p></li><li class="lvl-2"><p>有写端，read阻塞等待。</p></li></ul><p><strong>写管道：</strong></p><p>1 .没有读端， 异常终止。 （SIGPIPE导致的）</p><p>2 .有读端：</p><ul class="lvl-0"><li class="lvl-2"><p>管道已满， 阻塞等待</p></li><li class="lvl-2"><p>管道未满， 返回写出的字节个数。</p></li></ul><p><strong>小案例</strong></p><blockquote><p>1.使用管道实现父子进程间通信，完成：ls | wc –l。假定父进程实现 wc，子进程实现 ls</p></blockquote><p><mark>分析</mark>:</p><p>ls命令正常会将结果集写到stdout，但现在会写入管道写端</p><p>wc -l命令正常应该从stdin读取数据，但此时会从管道的读端读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">ret = pipe(fd); <span class="comment">// 父进程先创建一个管道,持有管道的读端和写端</span></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sys_err(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid = fork(); <span class="comment">// 子进程同样持有管道的读和写端</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123; <span class="comment">// 父进程 读, 关闭写端</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">dup2(fd[<span class="number">0</span>], STDIN_FILENO);<span class="comment">// 重定向 stdin 到 管道的 读端</span></span><br><span class="line">execlp(<span class="string">&quot;wc&quot;</span>, <span class="string">&quot;wc&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 执行 wc -l 程序</span></span><br><span class="line">sys_err(<span class="string">&quot;exclp wc error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">dup2(fd[<span class="number">1</span>], STDOUT_FILENO); <span class="comment">// 重定向 stdout 到 管道写端</span></span><br><span class="line">execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);<span class="comment">// 子进程执行 ls 命令</span></span><br><span class="line">sys_err(<span class="string">&quot;exclp ls error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/0614df6815f24409a664530cf3de34c9.png#pic_center" alt=""></p><p>直接执行命令，如下：</p><p><img src="https://img-blog.csdnimg.cn/c0f9f32049b74ce9b5e955a0fd58fb33.png#pic_center" alt=""></p><blockquote><p>2.使用管道实现兄弟进程间通信。 兄：ls 弟： wc -l 父：等待回收子进程。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> ret, i;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sys_err(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123; <span class="comment">// 表达式2 出口,仅限父进程使用</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 子进程,出口</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">&#123;  <span class="comment">// 父进程 . 不参与管道使用.</span></span><br><span class="line">close(fd[<span class="number">0</span>]); <span class="comment">// 关闭管道的 读端/写端.</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">wait(<span class="literal">NULL</span>); <span class="comment">// 回收子进程</span></span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">&#123; <span class="comment">// xiong</span></span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">dup2(fd[<span class="number">1</span>], STDOUT_FILENO); <span class="comment">// 重定向stdout</span></span><br><span class="line">execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">sys_err(<span class="string">&quot;exclp ls error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">&#123; <span class="comment">//弟弟</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">dup2(fd[<span class="number">0</span>], STDIN_FILENO); <span class="comment">// 重定向 stdin</span></span><br><span class="line">execlp(<span class="string">&quot;wc&quot;</span>, <span class="string">&quot;wc&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">sys_err(<span class="string">&quot;exclp wc error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-管道缓冲区大小">2.6 管道缓冲区大小</h3><p>可以使用 <code>ulimit –a</code> 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。(默认4096)</p><p><img src="https://img-blog.csdnimg.cn/b4906b45a28840e1b08c32213bbf4983.png#pic_center" alt=""><br>也可以使用 <code>fpathconf()</code> 函数，借助参数 选项来查看。使用该宏应引入头文件<code>&lt;unistd.h&gt;</code><br><code>long fpathconf(int fd, int name);</code> 成功：返回管道的大小 失败：-1，设置 <code>errno</code></p><h3 id="2-7-管道的优劣">2.7 管道的优劣</h3><p><strong>优点：</strong></p><p>简单，相比信号，套接字实现进程间通信，简单很多。</p><p><strong>缺点：</strong></p><ul class="lvl-0"><li class="lvl-3"><p>只能单向通信，双向通信需建立两个管道。</p></li><li class="lvl-2"><p>只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用 fifo 有名管道解决。</p></li></ul><h2 id="3-有名管道">3.有名管道</h2><p>有名管道拥有管道的所有特性，之所以称之为有名是因为管道在磁盘上有实体文件，文件类型为 <code>p</code> ，<code>有名管道文件大小永远为 0，因为有名管道也是将数据存储到内存的缓冲区中，打开这个磁盘上的管道文件就可以得到操作有名管道的文件描述符，通过文件描述符读写管道存储在内核中的数据。</code></p><h3 id="3-1-mkfifio-函数">3.1 mkfifio()函数</h3><p>有名管道也可以称为 fifo (first in first out)，使用有名管道既可以进行有血缘关系的进程间通信，也可以进行没有血缘关系的进程间通信。创建有名管道的方式有两种，一种是通过命令，一种是通过函数。</p><p><strong>通过命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> 有名管道的名字</span></span><br></pre></td></tr></table></figure><p><strong>通过函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">// int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><p><code>pathname: </code>要创建的有名管道的名字</p><p><code>mode:</code> 文件的操作权限，和 open () 的第三个参数一个作用，最终权限: (mode &amp; ~umask)</p><p><strong>返回值</strong>:</p><p>创建成功返回 0，失败返回 -1</p><p>一旦使用<code>mkfifo</code> 创建了一个 <code>FIFO</code>，就可以使用 <code>open</code> 打开它，常见的文件 <code>I/O函数</code>都可用于 <code>fifo</code>。如：<code>close</code>、<code>read</code>、 <code>write</code>、<code>unlink </code>等。</p><h3 id="3-2-fifo-实现非血缘关系进程间通信">3.2 fifo()实现非血缘关系进程间通信</h3><p>下面这个例子，一个写fifo，一个读fifo，操作起来就像文件一样的：</p><p><img src="https://img-blog.csdnimg.cn/16a397c7d0a04c6083a8d8466a6f9f9f.png#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/1cb929d808ce404b888ff9b799d4de8d.png#pic_center" alt=""></p><p>编译执行，如图：</p><p><img src="https://img-blog.csdnimg.cn/77efc3cf7e924c2aa542f293391eb017.png#pic_center" alt=""></p><h2 id="4-文件用于进程间通信">4.文件用于进程间通信</h2><p>文件实现进程间通信：</p><p>​打开的文件是内核中的一块缓冲区。多个无血缘关系的进程，可以同时访问该文件。</p><p><img src="https://img-blog.csdnimg.cn/b4c3ee9203744c78b10200cf27982070.png#pic_center" alt=""></p><p>文件通信有没有血缘关系都行，</p><ul class="lvl-0"><li class="lvl-2"><p>只是有血缘关系的进程对于同一个文件，使用的同一个文件描述符，</p></li><li class="lvl-2"><p>没有血缘关系的进程，对同一个文件使用的文件描述符可能不同。</p></li><li class="lvl-2"><p>这些都不是问题，打开的是同一个文件就行。</p></li><li class="lvl-2"><p>用文件通信没有阻塞等管道的特性，可能会遇到问题</p></li></ul><h2 id="5-内存映射-mmap">5.内存映射 (mmap)</h2><h3 id="5-1-存储映射-I-O">5.1 存储映射 I/O</h3><p>存储映射<code>I/O (Memory-mapped I/O)</code>使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用<code>read</code>和<code>write</code> 函数的情况下，使用地址（指针）完成 <code>I/O 操作</code>。 使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过<code>mmap 函数</code>来实现。</p><p><img src="https://img-blog.csdnimg.cn/4863df153e784ba7ae3c9ebb2a1e669e.png#pic_center" alt=""></p><h3 id="5-2-mmap-munmap-函数">5.2 mmap() /munmap()函数</h3><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建内存映射区</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数:</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>addr:</code> 从动态库加载区的什么位置开始创建内存映射区，一般指定为 <code>NULL</code>, 委托内核分配</p></li><li class="lvl-2"><p><code>length</code>: 创建的内存映射区的大小（单位：字节），实际上这个大小是按照 <code>4k </code>的整数倍去分配的</p></li><li class="lvl-2"><p><code>prot</code>: 对内存映射区的操作权限</p><ul class="lvl-2"><li class="lvl-4"><code>PROT_READ:</code> 读内存映射区</li><li class="lvl-4"><code>PROT_WRITE: </code>写内存映射区</li><li class="lvl-4">如果要对映射区有读写权限: <code>PROT_READ | PROT_WRITE</code></li></ul></li><li class="lvl-2"><p><code>flags:</code></p><ul class="lvl-2"><li class="lvl-4"><code>MAP_SHARED</code>: 多个进程可以共享数据，进行映射区数据同步</li><li class="lvl-4"><code>MAP_PRIVATE</code>: 映射区数据是私有的，不能同步给其他进程</li></ul></li><li class="lvl-2"><p><code>fd</code>: 文件描述符，对应一个打开的磁盘文件，内存映射区通过这个文件描述符和磁盘文件建立关联</p></li><li class="lvl-2"><p><code>offset</code>: 磁盘文件的偏移量，文件从偏移到的位置开始进行数据映射，使用这个参数需要注意两个问题：</p><ul class="lvl-2"><li class="lvl-4">偏移量必须是 4k 的整数倍，写 0 代表不偏移</li><li class="lvl-4">这个参数必须是大于 0 的</li></ul></li></ul><p><strong>函数返回值</strong></p><ul class="lvl-0"><li class="lvl-2"><p>成功：返回一个内存映射区的起始地址</p></li><li class="lvl-2"><p>失败: <code>MAP_FAILED (that is, (void *) -1)</code></p></li></ul><blockquote><p>mmap () 函数的参数相对较多，在使用该函数创建用于进程间通信的内存映射区的时候，各<strong>参数的指定</strong>都有一些注意事项，具体如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 第一个参数 addr 指定为 <span class="literal">NULL</span> 即可</span><br><span class="line"><span class="number">2.</span> 第二个参数 length 必须要 &gt; <span class="number">0</span></span><br><span class="line"><span class="number">3.</span> 第三个参数 prot，进程间通信需要对内存映射区有读写权限，因此需要指定为：PROT_READ | PROT_WRITE</span><br><span class="line"><span class="number">4.</span> 第四个参数 flags，如果要进行进程间通信, 需要指定 MAP_SHARED</span><br><span class="line"><span class="number">5.</span> 第五个参数 fd，打开的文件必须大于<span class="number">0</span>，进程间通信需要文件操作权限和映射区操作权限相同</span><br><span class="line">     - 内存映射区创建成功之后, 关闭这个文件描述符不会影响进程间通信</span><br><span class="line"><span class="number">6.</span> 第六个参数 offset，不偏移指定为<span class="number">0</span>，如果偏移必须是<span class="number">4</span>k的整数倍</span><br></pre></td></tr></table></figure><p>内存映射区使用完之后也需要释放，释放函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数:</strong></p><ul class="lvl-0"><li class="lvl-2"><p>addr: mmap () 的返回值，创建的内存映射区的起始地址</p></li><li class="lvl-2"><p>length: 和 mmap () 第二个参数相同即可</p></li></ul><p><strong>函数返回值</strong></p><ul class="lvl-0"><li class="lvl-2"><p>函数调用成功返回 0，失败返回 -1</p></li></ul><blockquote><p>总结：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建映射区的过程中，隐含着一次对映射文件的读操作。</span><br><span class="line"><span class="number">2.</span> 当MAP_SHARED 时，要求：映射区的权限应 &lt;= 文件打开的权限(出于对映射区的保护)。而 MAP_PRIVATE 则无所谓，因为mmap 中的权限是对内存的限制。</span><br><span class="line"><span class="number">3.</span> 映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。</span><br><span class="line"><span class="number">4.</span> 特别注意，当映射文件大小为 <span class="number">0</span> 时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！ mmap 使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。如，<span class="number">400</span> 字节大小的文件， 在建立映射区时 offset <span class="number">4096</span> 字节，则会报出总线错。</span><br><span class="line"><span class="number">5.</span> munmap传入的地址一定是mmap 的返回地址。坚决杜绝指针++操作。</span><br><span class="line"><span class="number">6.</span> 如果文件偏移量必须为<span class="number">4096</span>的整数倍（MMU 映射的最小单位 <span class="number">4</span>k ）</span><br><span class="line"><span class="number">7.</span> mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</span><br><span class="line"><span class="number">8.</span> 映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。</span><br><span class="line"><span class="number">9.</span> 映射区访问权限为 “私有”MAP_PRIVATE, 只需要open文件时，有读权限，用于创建映射区即可。</span><br><span class="line"><span class="number">10.</span> 映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。</span><br><span class="line"><span class="number">11.</span> 映射区访问权限为 “私有”MAP_PRIVATE, 只需要open文件时，有读权限，用于创建映射区即可。</span><br></pre></td></tr></table></figure><p><strong>小案例:使用mmap建立映射区</strong></p><p>下面这个示例代码，使用mmap创建一个映射区（共享内存），并往映射区里写入内容：</p><p><img src="https://img-blog.csdnimg.cn/a16179d09a804f129c44750452356add.png#pic_center" alt=""></p><p>编译运行，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/b4643d53cebd435b8cc968d6850b599d.png#pic_center" alt=""></p><h3 id="5-3-父子进程间mmap通信">5.3 父子进程间mmap通信</h3><p>父子等有血缘关系的进程之间也可以通过<code>mmap</code> 建立的映射区来完成数据通信。但相应的要在创建映射区的时 候指定对应的标志位参数 <code>flags</code>：</p><ul class="lvl-0"><li class="lvl-2"><p><code>MAP_PRIVATE</code>:(私有映射) 父子进程各自独占映射区；</p></li><li class="lvl-2"><p><code>MAP_SHARED</code>: (共享映射) 父子进程共享映射区；</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 先创建内存映射区, 得到一个起始地址, 假设使用ptr指针保存这个地址</span></span><br><span class="line"><span class="comment">    2. 通过fork() 创建子进程 -&gt; 子进程中也就有一个内存映射区, 子进程中也有一个ptr指针指向这个地址</span></span><br><span class="line"><span class="comment">    3. 父进程往自己的内存映射区写数据, 数据同步到了磁盘文件中, 磁盘文件数据又同步到子进程的映射区中</span></span><br><span class="line"><span class="comment">       子进程从自己的映射区往外读数据, 这个数据就是父进程写的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 2. 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, <span class="number">4000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                     MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程, 写数据</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;我是你爹, 你是我儿子吗???&quot;</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ptr, pt, <span class="built_in">strlen</span>(pt)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 读数据</span></span><br><span class="line">        usleep(<span class="number">1</span>);<span class="comment">// 内存映射区不阻塞, 为了让子进程读出数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从映射区读出的数据: %s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(ptr, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-无血缘关系进程间mmap通信">5.4 无血缘关系进程间mmap通信</h3><p>实质上<code>mmap</code> 是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核 空间多进程共享，因此无血缘关系的进程间也可使用<code>mmap</code> 来完成通信。只要设置相应的标志位参数 <code>flags </code>即可。若想实现共享，当然应该使用<code>MAP_SHARED </code>了。 值得注意的是：<code>MAP_ANON </code>和 <code>/dev/zero </code>都不能应用于非血缘关系进程间通信。只能用于亲子进程间。</p><p><strong>A代码(进行写操作)：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 2. 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, <span class="number">4000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                     MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;==================我是你爹, 你是我儿子吗???****************&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, pt, <span class="built_in">strlen</span>(pt)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(ptr, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B代码(进行读操作)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 2. 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, <span class="number">4000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                     MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读内存映射区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从映射区读出的数据: %s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(ptr, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-匿名映射">5.5 匿名映射</h3><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要 open 一个 temp 文件，创建好了再 unlink、close 掉，比较麻烦。可以直接使用匿名映射来代替。其实 Linux 系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数 flags 来指定。</p><p>使用<code>MAP_ANONYMOUS</code> (或<code>MAP_ANON</code>)， 如:<code>int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code></p><p>需注意的是，<code>MAP_ANONYMOUS 和 MAP_ANON 这两个宏是 Linux 操作系统特有的宏</code>。<code>在类 Unix 系统中如无该宏定义</code>，可使用如下两步来完成匿名映射区的建立。</p><p>① <code>fd = open(&quot;/dev/zero&quot;, O_RDWR);</code></p><p>② <code>p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0);</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-IPC-方法&quot;&gt;1.IPC 方法&lt;/h2&gt;
&lt;p&gt;Linux 环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另 一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区， 进程</summary>
      
    
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="IPC" scheme="https://billysturate.github.io/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程之虚拟地址空间和文件描述符</title>
    <link href="https://billysturate.github.io/posts/b93c9a9c.html"/>
    <id>https://billysturate.github.io/posts/b93c9a9c.html</id>
    <published>2022-08-27T10:13:54.000Z</published>
    <updated>2023-01-28T15:47:23.310Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://subingwen.cn/linux/file-descriptor/">原文链接</a></p><h2 id="1-虚拟地址空间">1.虚拟地址空间</h2><blockquote><p>虚拟地址空间是一个非常抽象的概念，先根据字面意思进行解释：</p><ul class="lvl-1"><li class="lvl-2">它可以用来加载程序数据（数据可能被加载到物理内存上，空间不够就加载到虚拟内存中）</li><li class="lvl-2">它对应着一段连续的内存地址，起始位置为 0。</li><li class="lvl-2">之所以说虚拟是因为这个起始的 0 地址是被虚拟出来的， 不是物理内存的 0 地址。</li></ul></blockquote><p>虚拟地址空间的大小也由操作系统决定，<code>32位的操作系统虚拟地址空间的大小为</code> 2<sup>32</sup> 字节，也就是 <code>4G</code>，64 位的操作系统虚拟地址空间大小为 264 字节，这是一个非常大的数，感兴趣可以自己计算一下。<code>当我们运行磁盘上一个可执行程序, 就会得到一个进程，内核会给每一个运行的进程创建一块属于自己的虚拟地址空间，并将应用程序数据装载到虚拟地址空间对应的地址上</code>。</p><p>进程在运行过程中，程序内部所有的指令都是通过 CPU 处理完成的，CPU 只进行数据运算并不具备数据存储的能力，其处理的数据都加载自物理内存，那么进程中的数据是如何进出入到物理内存中的呢？其实是通过 CPU 中的内存管理单元 MMU（Memory Management Unit）从进程的虚拟地址空间中映射过去的。</p><p><img src="https://subingwen.cn/linux/file-descriptor/image-20210130092825532.png" alt=""></p><h3 id="1-1-存在的意义">1.1 存在的意义</h3><p>通过上边的介绍大家会感觉到一头雾水， 为什么操作系统不直接将数据加载到物理内存中而是将数据加载到虚拟地址空间中，在通过 CPU 的 MMU 映射到物理内存中呢？</p><p>先来看一下如果直接将数据加载到物理内存会发生什么事情：</p><p><img src="https://subingwen.cn/linux/file-descriptor/image-20210130093119238.png" alt=""></p><blockquote><p>假设计算机的物理内存大小为 1G, 进程 A 需要 100M 内存因此直接在物理内存上从 0 地址开始分配 100M, 进程 B 启动需要 250M 内存，因此继续在物理内存上为其分配 250M 内存，并且进程 A 和进程 B 占用的内存是连续的。之后再启动其他进程继续按照这种方法进行物理内存的分配。。。</p><p>使用这种方式分配内存会有如下几个问题：</p></blockquote><p>1.<code>每个进程的地址不隔离，有安全风险。</code></p><p>由于程序都是直接访问物理内存，所以恶意程序可以通过内存寻址随意修改别的进程对应的内存数据，以达到破坏的目的。虽然有些时候是非恶意的，但是有些存在 bug 的程序可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。</p><p>2.<code>内存效率低。</code></p><p>如果直接使用物理内存的话，一个进程对应的内存块就是作为一个整体操作的，如果出现物理内存不够用的时候，我们一般的办法是将不常用的进程拷贝到磁盘的交换分区（虚拟内存）中，以便腾出内存，因此就需要将整个进程一起拷走，如果数据量大，在内存和磁盘之间拷贝时间就会很长，效率低下。</p><p>3.<code>进程中数据的地址不确定，每次都会发生变化。</code></p><p>由于物理内存的使用情况一直在动态的变化，我们无法确定内存现在使用到哪里了，如果直接将程序数据加载到物理内存，内存中每次存储数据的起始地址都是不一样的，这样数据的加载都需要使用相对地址，加载效率低（静态库是使用绝对地址加载的）。</p><blockquote><p>有了虚拟地址空间之后就可以完美的解决上边提到的所有问题了，<code>虚拟地址空间就是一个中间层，相当于在程序和物理内存之间设置了一个屏障，将二者隔离开来。程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上</code>。这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p></blockquote><h3 id="1-2-分区">1.2 分区</h3><p>从操作系统层级上看，虚拟地址空间主要分为两个部分<code>内核区</code>和<code>用户区</code>。</p><ul class="lvl-0"><li class="lvl-2"><p>内核区：</p><ul class="lvl-2"><li class="lvl-4">内核空间为内核保留，<code>不允许应用程序读写该区域的内容或直接调用内核代码定义的函数</code>。</li><li class="lvl-4">内核总是驻留在内存中，是操作系统的一部分。</li><li class="lvl-4">系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）。</li></ul></li><li class="lvl-2"><p>用户区：存储用户程序运行中用到的各种数据。</p></li></ul><p>我们先来看一下进程对应的虚拟地址空间的各个分区，再来详细介绍用户区的组成（以 32 位系统的虚拟地址空间为例）。</p><p><img src="https://subingwen.cn/linux/file-descriptor/image-20210130093015907.png" alt=""></p><p>每个进程的虚拟地址空间都是从 0 地址开始的，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，程序是无法直接访问物理内存的。虚拟地址空间中用户区地址范围是 0~3G，里边分为多个区块：</p><ul class="lvl-0"><li class="lvl-2"><p><code>保留区</code>: 位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针（NULL）指向的就是这块内存地址。</p></li><li class="lvl-2"><p><code>.text段</code>: 代码段也称正文段或文本段，通常用于存放程序的执行代码 (即 CPU 执行的机器指令)，代码段一般情况下是只读的，这是对执行代码的一种保护机制。</p></li><li class="lvl-2"><p><code>.data段</code>: 数据段通常用于存放程序中已初始化且初值不为 0 的全局变量和静态变量。数据段属于静态内存分配 (静态存储区)，可读可写。</p></li><li class="lvl-2"><p><code>.bss段</code>: 未初始化以及初始为 0 的全局变量和静态变量，操作系统会将这些未初始化变量初始化为 0</p></li><li class="lvl-2"><p><code>堆(heap)</code>：用于存放进程运行时动态分配的内存。</p><ul class="lvl-2"><li class="lvl-4">堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。</li><li class="lvl-4">堆向高地址扩展 (即 “向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</li></ul></li><li class="lvl-2"><p><code>内存映射区(mmap)</code>：作为内存映射区加载磁盘文件，或者加载程序运作过程中需要调用的动态库。</p></li><li class="lvl-2"><p><code>栈(stack)</code>: 存储函数内部声明的非静态局部变量，函数参数，函数返回地址等信息，栈内存由编译器自动分配释放。栈和堆相反地址 “向下生长”，分配的内存是连续的。</p></li><li class="lvl-2"><p><code>命令行参数</code>：存储进程执行的时候传递给 main() 函数的参数，argc，argv []</p></li><li class="lvl-2"><p><code>环境变量</code>: 存储和进程相关的环境变量，比如：工作路径，进程所有者等信息</p></li></ul><h2 id="2-文件描述符">2.文件描述符</h2><h3 id="2-1-文件描述符">2.1 文件描述符</h3><p>在 Linux 操作系统中的一切都被抽象成了文件，那么一个打开的文件是如何与应用程序进行对应呢？解决方案是使用<code>文件描述符（file descriptor，简称fd），当在进程中打开一个现有文件或者创建一个新文件时，内核向该进程返回一个文件描述符，用于对应这个打开/新建的文件</code>。这些文件描述符都存储在内核为每个进程维护的一个文件描述符表中。</p><p>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p><blockquote><p>在 Linux 系统中一切皆文件，系统中一切都被抽象成了文件。对这些文件的读写都需要通过文件描述符来完成。标准 C 库的文件 IO 函数使用的文件指针 <code>FILE*</code> 在 Linux 中也需要通过文件描述符的辅助才能完成读写操作。<code>FILE</code> 其实是一个结构体，其内部有一个成员就是文件描述符（下面结构体的第 25 行）。</p></blockquote><p><strong>FILE 结构体在 Linux 头文件中的定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux c FILE结构体定义： /usr/include/libio.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> _fileno;<span class="comment">// 文件描述符</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"> </span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文件: /usr/include/stdio.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure><h3 id="2-2文件描述符表">2.2文件描述符表</h3><p>前面讲到启动一个进程就会得到一个对应的虚拟地址空间，这个虚拟地址空间分为两大部分，在内核区有专门用于进程管理的模块。Linux 的进程控制块 PCB（process control block）本质是一个叫做 <code>task_struct</code> 的结构体，里边包括管理进程所需的各种信息，其中有一个结构体叫做 <code>file</code> ，我们将它叫做文件描述符表，里边有一个整形索引表，用于存储文件描述符。</p><p>内核为每一个进程维护了一个文件描述符表，索引表中的值都是从 0 开始的，所以在不同的进程中你会看到相同的文件描述符，但是它们指向的不一定是同一个磁盘文件。</p><p><img src="https://subingwen.cn/linux/file-descriptor/image-20210130123339157.png" alt=""></p><blockquote><p>知识小科普：</p><p>Linux 中用户操作的每个终端都被视作一个设备文件，当前操作的终端文件可以使用 /dev/tty 表示。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><strong>打开的最大文件数</strong></p><p>每一个进程对应的文件描述符表能够存储的打开的文件数是有限制的，默认为 1024 个，这个默认值是可以修改的，支持打开的最大文件数据取决于操作系统的件配置。</p></li><li class="lvl-2"><p><strong>默认分配的文件描述符</strong></p><p>当一个进程被启动之后，内核 PCB 的文件描述符表中就已经分配了三个文件描述符，这三个文件描述符对应的都是当前启动这个进程的终端文件（Linux 中一切皆文件，终端就是一个设备文件，在 /dev 目录中）</p><ul class="lvl-2"><li class="lvl-4"><p><code>STDIN_FILENO</code>：标准输入，可以通过这个文件描述符将数据输入到终端文件中，宏值为 0。</p></li><li class="lvl-4"><p><code>STDOUT_FILENO</code>：标准输出，可以通过这个文件描述符将数据通过终端输出出来，宏值为 1。</p></li><li class="lvl-4"><p><code>STDERR_FILENO</code>：标准错误，可以通过这个文件描述符将错误信息通过终端输出出来，宏值为 2。这三个默认分配的文件描述符是可以通过 close() 函数关闭掉，但是关闭之后当前进程也就不能和当前终端进行输入或者输出的信息交互了。</p></li></ul></li><li class="lvl-2"><p><strong>给新打开的文件分配文件描述符</strong></p><ul class="lvl-2"><li class="lvl-4">因为进程启动之后，文件描述符表中的 <code>0</code>,<code>1</code>,<code>2</code> 就被分配出去了，因此从 <code>3</code> 开始分配</li><li class="lvl-4">在进程中每打开一个文件，就会给这个文件分配一个新的文件描述符，比如：<ul class="lvl-4"><li class="lvl-6">通过 <code>open()</code> 函数打开 <code>/hello.txt</code>，文件描述符 3 被分配给了这个文件，保持这个打开状态，再次通过 <code>open()</code> 函数打开 <code>/hello.txt</code>，文件描述符 4 被分配给了这个文件，也就是说一个进程中不同的文件描述符打开的磁盘文件可能是同一个。</li><li class="lvl-6">通过 <code>open()</code> 函数打开 <code>/hello.txt</code>，文件描述符 3 被分配给了这个文件，将打开的文件关闭，此时文件描述符 3 就被释放了。再次通过 <code>open()</code> 函数打开 <code>/hello.txt</code>，文件描述符 3 被分配给了这个文件，也就是说打开的新文件会关联文件描述符表中最小的没有被占用的文件描述符。</li></ul></li></ul></li></ul><blockquote><p>总结:</p><ul class="lvl-1"><li class="lvl-2">每个进程对应的文件描述符表默认支持打开的最大文件数为 1024，可以修改</li><li class="lvl-2">每个进程的文件描述符表中都已经默认分配了三个文件描述符，对应的都是当前终端文件（/dev/tty）</li><li class="lvl-2">每打开新的文件，内核会从进程的文件描述符表中找到一个空闲的没有别占用的文件描述符与其进行关联</li><li class="lvl-2">文件描述符表中不同的文件描述符可以对应同一个磁盘文件</li><li class="lvl-2">每个进程文件描述符表中的文件描述符值是唯一的，不会重复</li></ul></blockquote>]]></content>
    
    
    <summary type="html">Linux系统编程之虚拟地址空间和文件描述符</summary>
    
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="虚拟地址空间" scheme="https://billysturate.github.io/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
    
    <category term="文件描述符" scheme="https://billysturate.github.io/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程之进程</title>
    <link href="https://billysturate.github.io/posts/94cc42f5.html"/>
    <id>https://billysturate.github.io/posts/94cc42f5.html</id>
    <published>2022-08-26T10:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-进程相关概念">1.进程相关概念</h2><h3 id="1-1-程序和进程">1.1 程序和进程</h3><p>程序：是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、 设备、锁…)，是一个静态的概念 。</p><p>进程：被执行之后的程序叫做进程，不占用磁盘空间，需要消耗系统的内存，CPU资源，每个运行的进程的都对应一个属于自己的虚拟地址空间，这是一个动态的概念。</p><p>程序 → 剧本(纸)</p><p>进程 → 戏(舞台、演员、灯光、道具…)</p><p>同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响)<br>如：同时开两个终端。各自都有一个 bash 但彼此 ID 不同。</p><h3 id="1-2-并行和并发">1.2 并行和并发</h3><p><strong>并发</strong></p><ul class="lvl-0"><li class="lvl-2"><p>并发的同时运行是一个假象， CPU 在某一个时间点只能为某一个个体来服务，因此不可能同时处理多任务，这是通过计算机CPU的时间片快速切换实现的。</p></li><li class="lvl-2"><p>并发是针对某一个硬件资源而言的，在某个时间段之内处理的任务的总量，量越大效率越高。</p></li></ul><p><strong>并行</strong></p><ul class="lvl-0"><li class="lvl-2"><p>并行的多进程同时运行是真实存在的，可以在同一时刻同时运行多个进程</p></li><li class="lvl-2"><p>并行需要依赖多个硬件资源，单个是无法实现的。</p></li></ul><h3 id="1-3-PCB进程控制块">1.3 PCB进程控制块</h3><blockquote><p>PCB - 进程控制块（Processing Control Block），Linux 内核的进程控制块本质上是一个叫做 task_struct 的结构体。在这个结构体中记录了进程运行相关的一些信息，下面介绍一些常用的信息：</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>进程 id：每一个进程都一个唯一的进程 ID，类型为 pid_t, 本质是一个整形数</p></li><li class="lvl-2"><p>进程的状态：进程有不同的状态，状态是一直在变化的，有就绪、运行、挂起、停止等状态。</p></li><li class="lvl-2"><p>进程对应的虚拟地址空间的信息。</p></li><li class="lvl-2"><p>描述控制终端的信息，进程在哪个终端启动默认就和哪个终端绑定。</p></li><li class="lvl-2"><p>当前工作目录：默认情况下，启动进程的目录就是当前的工作目录</p></li><li class="lvl-2"><p>umask 掩码：在创建新文件的时候，通过这个掩码屏蔽某些用于对文件的操作权限。</p></li><li class="lvl-2"><p>文件描述符表：每个被分配的文件描述符都对应一个已经打开的磁盘文件和信号相关的信息：在 Linux 中 调用函数 , 键盘快捷键 , 执行shell命令等操作都会产生信号。</p></li><li class="lvl-2"><p>阻塞信号集：记录当前进程中阻塞哪些已产生的信号，使其不能被处理</p></li><li class="lvl-2"><p>未决信号集：记录在当前进程中产生的哪些信号还没有被处理掉。</p></li><li class="lvl-2"><p>用户 id 和组 id：当前进程属于哪个用户，属于哪个用户组</p></li><li class="lvl-2"><p>会话（Session）和进程组：多个进程的集合叫进程组，多个进程组的集合叫会话。</p></li><li class="lvl-2"><p>进程可以使用的资源上限：可以使用 shell 命令 ulimit -a 查看详细信息。</p></li></ul><h3 id="1-4-单道程序设计和多道程序设计">1.4 单道程序设计和多道程序设计</h3><p><strong>单道程序设计</strong></p><p>所有进程一个一个排对执行。若 A 阻塞，B 只能等待，即使 CPU 处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p><p><strong>多道程序设计</strong></p><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。<strong>时钟中断</strong>即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出 cpu 资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。在多道程序设计模型中，多个进程轮流使用 CPU (分时复用 CPU资源)。而当下常见 CPU为纳秒级，1 秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</p><h3 id="1-5-进程状态">1.5 进程状态</h3><p><a href="https://subingwen.cn/linux/process/#1-4-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81">参考链接</a></p><p>进程一共有五种状态分别为：<code>创建态</code>，<code>就绪态</code>，<code>运行态</code>，<code>阻塞态(挂起态)</code>，<code>退出态(终止态)</code> 其中创建态和退出态维持的时间是非常短的，稍纵即逝。我们主要是需要将<code>就绪态</code> ,<code>运行态</code>, <code>挂起态</code>，三者之间的状态切换搞明白。</p><p><img src="https://img-blog.csdnimg.cn/da67e5d956884ffc8c7a4be647e8e6fe.png#pic_center" alt=""></p><p>就绪态：</p><ul class="lvl-0"><li class="lvl-2"><p>进程被创建出来了，有运行的资格但是还没有运行，需要抢 CPU 时间片</p></li><li class="lvl-2"><p>得到 CPU 时间片，进程开始运行，从就绪态转换为运行态。</p></li><li class="lvl-2"><p>进程的 CPU 时间片用完了，再次失去 CPU, 从运行态转换为就绪态。</p></li></ul><p>运行态：</p><ul class="lvl-0"><li class="lvl-2"><p>获取到 CPU 资源的进程，进程只有在这种状态下才能运行</p></li><li class="lvl-2"><p>运行态不会一直持续，进程的 CPU 时间片用完之后，再次失去 CPU，从运行态转换为就绪态</p></li><li class="lvl-2"><p>只要进程还没有退出，就会在就绪态和运行态之间不停的切换。</p></li></ul><p>阻塞态：</p><ul class="lvl-0"><li class="lvl-2"><p>进程被强制放弃 CPU，并且没有抢夺 CPU 时间片的资格</p></li><li class="lvl-2"><p>比如：在程序中调用了某些函数（比如: sleep ()），进程由运行态转换为阻塞态（挂起态）</p></li><li class="lvl-2"><p>当某些条件被满足了（比如：sleep()睡醒了），进程的阻塞状态也就被解除了，进程从阻塞态转换为就绪态。</p></li></ul><p>退出态：</p><ul class="lvl-0"><li class="lvl-2"><p>进程被销毁，占用的系统资源被释放了</p></li><li class="lvl-2"><p>任何状态的进程都可以直接转换为退出态。</p></li></ul><h3 id="1-6-环境变量">1.6 环境变量</h3><p><code>echo $PATH</code>  查看环境变量</p><p>path环境变量里记录了一系列的值，当运行一个可执行文件时，系统会去环境变量记录的位置里查找这个文件并执行。</p><p><code>echo $TERM</code> 查看终端</p><p><code>echo $LANG</code> 查看语言</p><p><code>env</code>     查看所有环境变量</p><p><strong>补充</strong></p><p><code>ps aux</code> 返回结果里，第二列是进程id号</p><h2 id="2-进程创建">2.进程创建</h2><h3 id="2-1-getpid-getppid-fork-函数原型">2.1 getpid()/getppid()/fork()函数原型</h3><p>Linux 中进程 ID 为 pid_t 类型，其本质是一个正整数，通过上边的 ps aux 命令可以查看每个进程的进程ID号。PID 为 1 的进程是 Linux 系统中创建的第一个进程。</p><p>获取当前进程的进程 ID（PID）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>获取当前进程的父进程 ID（PPID）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>创建一个新的进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-fork-函数返回值">2.2 fork()函数返回值</h3><p><code>fork ()</code> 调用成功之后，会返回两个值，父子进程的返回值是不同的。</p><p>父进程的虚拟地址空间中将该返回值标记为一个大于 0 的数（其实记录的是子进程的进程 ID）</p><p>子进程的虚拟地址空间中将该返回值标记 0</p><p>在程序中需要通过 fork () 的返回值来判断当前进程是子进程还是父进程。</p><h3 id="2-3-fork-函数创建子进程示例">2.3 fork()函数创建子进程示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在父进程中创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程fork()的返回值: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程执行的逻辑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程执行的逻辑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d, 我爹是: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// pid == -1</span></span><br><span class="line">    &#123;</span><br><span class="line">    perror(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建子进程失败了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不加判断, 父子进程都会执行这个循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，如下所示</p><p><img src="https://img-blog.csdnimg.cn/4960546b2a1144d58a2b6b04a9490122.png#pic_center" alt=""></p><p>代码理解：我们在父进程中成功创建了子进程，子进程就拥有父进程代码区的所有代码，那么子进程中的代码是在什么位置开始运行的呢？父进程肯定是从 main () 函数开始运行的，子进程是在父进程中调用 fork () 函数之后被创建，子进程就从 fork () 之后开始向下执行代码。上代码演示了父子进程中代码的执行流程，可以看到如果在程序中对 fork() 的返回值做了判断，就可以控制父子进程的行为，如果没有做任何判断这个代码块父子进程都可以执行。在编写多进程程序的时候，一定要将代码想象成多份进行分析，因为直观上看代码就一份，但实际上数据都是多份，并且多份数据中变量名都相同，但是他们的值却不一定相同。</p><h3 id="2-4-循环创建多个子进程">2.4 循环创建多个子进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程pid: %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/1726df02995e4f1984f69e995727f5f3.png#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/4f4aaaebd1454220962c9adc2a2cbbb4.png#pic_center" alt=""></p><p>可以看出，这和我们预想的不一样，为什么呢，明明我用for循环只想创建出5个进程，但是却fork创建了这么多的子进程，这是因为在循环中创建出的子进程还会创建出孙子进程，孙子进程会创建出重孙进程，所以才会创建出这么多的进程，下面给出解决方法，我们可以只让父进程创建子进程，如果是子进程不让其继续创建子进程，因此只需要在程序中添加关于父子进程的判断即可，如果fork()==0，说明是子进程，那么我们就直接让子进程break出for循环，下面给出改进过后的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i am parent\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i am %dth child\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/f9ebe2c4c83043c1b06f8e3f408d9f80.png#pic_center" alt=""></p><p>看到如上代码，可能有的人或许有疑惑，为什么要调用sleep()函数，因为如果我们不调用sleep()函数的话，最终在终端显示的时候会是乱序的，如下图所示</p><p><img src="https://img-blog.csdnimg.cn/b2f1760eb78040789acd3ab18b589c7a.png#pic_center" alt=""></p><p>这是要因为，对操作系统而言，这几个子进程几乎是同时出现的，它们和父进程一起争夺cpu，谁抢到，谁打印，所以出现顺序是随机的。还有就是终端提示符混在了输出里，这是因为，fork1 进程启动之后，共创建了 5 个子进程，其实 fork1 也是有父进程的就是当前的终端，终端只能检测到fork1进程的状态，fork1执行期间终端切换到后台，a.out 执行完毕之后终端切换回前台，当终端切换到前台之后，fork1的子进程还没有执行完毕，所以子进程输出的信息就显示到终端命令提示符的后边了，导致终端显示有问题。因此想要解决这个问题，调用sleep()函数即可完美解决。</p><h3 id="2-5-父子进程共享哪些内容">2.5 父子进程共享哪些内容</h3><p>刚fork之后：(注意时间点)</p><p><strong>父子进程相同部分：</strong></p><p>data段、text段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位置、信号处理方式</p><p><strong>父子进程不同部分：</strong></p><p>进程id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p><p><strong>解释：</strong></p><p>在主进程使用fork()函数后，会创建出子进程，因为每个进程都会有自己的虚拟内存空间，所以子进程也会有自己单独的虚拟内存空间，他和主进程的虚拟内存空间是完全独立的，只不过子进程的虚拟内存空间是基于父进程的虚拟内存空间拷贝出来的，拷贝完成后，他们两0-3G的用户区是相同的，但是由于每个进程都有自己的进程 ID，因此内核区存储的父子进程 ID 是不同的。虽然他们在代码区的代码相同，但是执行时可以通过fork()函数的返回值来区分主进程和子进程的执行逻辑，似乎，子进程复制了父进程 0-3G 用户空间内容，以及父进程的 PCB，但 pid 不同。真的每 fork 一个子进程都要将父进程的 0-3G 地址空间完全拷贝一份，然后在映射至物理内存吗？当然不是！父子进程间遵循<strong>读时共享写时复制的原则</strong>。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</p><p>有的人可能会想通过全局变量来让父子进程之间进行通信，但是这是行不通的，因为每个进程都有自己的地址空间，两个同名全局变量存储在不同的虚拟地址空间中，二者没有任何关联性。如果想让父子进程之间进行通信交流，可以使用：管道，共享内存，本地套接字，内存映射区，消息队列等方式。后面会介绍这些方法。</p><h3 id="2-6-父子进程gdb调试">2.6 父子进程gdb调试</h3><p>使用 gdb 调试的时候，gdb 只能跟踪一个进程。可以在 fork 函数调用之前，通过指令设置 gdb 调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。</p><ul class="lvl-0"><li class="lvl-2"><p>设置父进程调试路径：<code>set follow-fork-mode parent (默认)</code></p></li><li class="lvl-2"><p>设置子进程调试路径：<code>set follow-fork-mode child</code></p></li></ul><p>注意，一定要在fork函数调用之前设置才有效。</p><h2 id="3-exec函数族">3.exec函数族</h2><p>fork 创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种 exec 函数以执行另一个程序。当进程调用一种 exec 函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用 exec 并不创建新进程，所以调用 exec 前后该进程的 id 并未变。</p><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">          <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">            <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p>这些函数执行成功无返回值，失败返回 -1</p><p><code>exec族函数</code>中最常用的有两个<code>execl()</code>和<code> execlp()</code>，这两个函数是对其他 4 个函数做了进一步的封装，下面介绍一下。</p><h3 id="3-1-execlp-函数">3.1 execlp()函数</h3><p>加载一个进程，借助 PATH环境变量</p><p><strong>函数原型</strong></p><p><code>int execlp(const char *file, const char *arg, …)</code></p><p><strong>函数参数</strong></p><p>参数1：要加载的程序名字，该函数需要配合PATH环境变量来使用，当PATH所有目录搜素后没有参数1则返回出错。</p><p>参数2：ps aux 查看进程的时候，启动的进程的名字，可以随意指定，一般和要启动的可执行程序名相同。</p><p>参数3 : 要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。</p><p><strong>函数返回值</strong></p><p>执行成功，无返回，执行失败，返回-1</p><p>该函数通常用来调用系统程序。如ls、date、cp、cat命令。</p><p>execlp这里面的p，表示要借助环境变量来加载可执行文件</p><h3 id="3-2-execl-函数">3.2 execl()函数</h3><p>该函数可用于执行任意一个可执行程序，函数需要通过指定的文件路径才能找到这个可执行程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 变参函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数</strong><br>参数1：要启动的可执行程序的路径，推荐使用绝对路径。</p><p>参数2：ps aux 查看进程的时候，启动的进程的名字，可以随意指定，一般和要启动的可执行程序名相同。</p><p>参数3：要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。</p><p><strong>函数返回值</strong></p><p>执行成功，无返回，执行失败，返回-1</p><p><strong>函数原型</strong></p><h3 id="3-3-小练习">3.3 小练习</h3><p><strong>1.通过execlp让子进程去执行ls命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-h&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;exec error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent pid = %d&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/ead9266bfab74c349b6acf4b32a94415.png#pic_center" alt=""></p><p><strong>2.使用execl来让子程序调用自定义的程序。</strong></p><p>注意</p><ul class="lvl-0"><li class="lvl-2"><p>和execlp不同的是，第一个参数是路径，不是文件名。</p></li><li class="lvl-2"><p>这个路径用相对路径和绝对路径都行。</p></li></ul><p><mark>hello.c</mark></p><p><img src="https://img-blog.csdnimg.cn/eef5a1c451f2442aa1040cc2a8031f73.png#pic_center" alt=""></p><p><mark>exec.c</mark></p><p><img src="https://img-blog.csdnimg.cn/ea74d1fa220a4afeb3b990ef912d336e.png#pic_center" alt=""></p><p>编译运行，结果如下所示：</p><p><img src="https://img-blog.csdnimg.cn/9a6c767e8e104905b715e8836e9dd773.png#pic_center" alt=""></p><h3 id="3-4-exec函数族特性">3.4 exec函数族特性</h3><p><strong>写一个程序，使用execlp执行进程查看，并将结果输出到文件里。</strong></p><p><img src="https://img-blog.csdnimg.cn/7eb4c463365041a9a3293b2e0df1111a.png#pic_center" alt=""></p><p>编译运行，结果如下所示：</p><p><img src="https://img-blog.csdnimg.cn/61684c3e52af4191aa7cb28210f5365f.png#pic_center" alt=""></p><p>exec函数一旦调用成功，即执行新的程序，不返回。只有失败才返回，错误值-1。所以通常我们直接在exec函数调用后直接调用perror()，和exit()，无需if判断。</p><p>l(list)命令行参数列表</p><p>p(path)搜索file时使用path变量</p><p>v(vector)使用命令行参数数组</p><p>e(environment)使用环境变量数组，不适用进程原有的环境变量，</p><p>设置新加载程序运行的环境变量</p><p>事实上，只有execve是真正的系统调用，其他5个函数最终都调用execve，是库函数，所以execve在man手册第二节，其它函数在man手册第3节。这些函数之间的关系如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/2292db940a6340789fd3bf920206b8f9.png#pic_center" alt=""></p><h2 id="4-回收子进程">4.回收子进程</h2><h3 id="4-1孤儿进程和僵尸进程">4.1孤儿进程和僵尸进程</h3><p>孤儿进程：</p><ul class="lvl-0"><li class="lvl-2"><p>父进程先于子进终止，子进程沦为“孤儿进程”，会被 init 进程(1号进程)领养。</p></li></ul><p>下面这段代码可以得到一个僵尸进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);<span class="comment">// 强迫子进程睡眠1s, 这个期间, 父进程退出, 当前进程变成了孤儿进程，子进程被1号进程回收</span></span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>僵尸进程：</p><ul class="lvl-0"><li class="lvl-2"><p>子进程终止，父进程尚未对子进程进行回收，在此期间，子进程为“僵尸进程”。  kill 对其无效。这里要注意，每个进程结束后都必然会经历僵尸态，时间长短的差别而已。</p></li><li class="lvl-2"><p>子进程终止时，子进程残留资源PCB存放于内核中，PCB记录了进程结束原因，进程回收就是回收PCB。回收僵尸进程，得kill它的父进程，让孤儿院去回收它。</p></li></ul><p>下面这段代码可以得到一个僵尸进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="comment">// 一直运行不退出, 就会出现僵尸进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-wait-函数和waitpid-函数">4.2 wait()函数和waitpid()函数</h3><p>为了避免僵尸进程的产生，一般我们会在父进程中进行子进程的资源回收，回收方式有两种，一种是阻塞方式<code> wait()</code>，一种是非阻塞方式 <code>waitpid()</code>。</p><h4 id="4-2-1wait-函数">4.2.1wait()函数</h4><p>这是个阻塞函数，如果没有子进程退出，函数会一直阻塞等待，当检测到子进程退出了，该函数阻塞解除回收子进程资源。这个函数被调用一次，只能回收一个子进程的资源，如果有多个子进程需要资源回收，函数需要被调用多次。</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// man 2 wait</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数</strong></p><p>status：传出参数，回收进程的状态。</p><p><strong>函数返回值</strong></p><ul class="lvl-0"><li class="lvl-2"><p>成功：返回被回收的子进程的进程 ID</p></li><li class="lvl-2"><p>失败: -1</p><ul class="lvl-2"><li class="lvl-4">没有子进程资源可以回收了，函数的阻塞会自动解除，返回 - 1</li><li class="lvl-4">回收子进程资源的时候出现了异常</li></ul></li></ul><p><strong>函数作用</strong></p><ul class="lvl-0"><li class="lvl-2"><p>阻塞等待子进程退出</p></li><li class="lvl-2"><p>清理子进程残留在内核的 pcb 资源</p></li><li class="lvl-2"><p>通过传出参数，得到子进程结束状态</p></li></ul><h4 id="4-2-2-获取子进程退出值和异常终止信号">4.2.2 获取子进程退出值和异常终止信号</h4><ul class="lvl-0"><li class="lvl-2"><p>一个进程终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。</p></li><li class="lvl-2"><p>这个进程的父进程可以调用wait或者waitpid获取这些信息，然后彻底清除掉这个进程。</p></li><li class="lvl-2"><p>一个进程的退出状态可以在shell中用特殊变量$？查看，因为shell是它的父进程，当它终止时，shell调用wait或者waitpid得到它的退出状态，同时彻底清除掉这个进程。</p></li></ul><p><strong>获取子进程正常终止值：</strong></p><p>​WIFEXITED(status) --&gt; 为真 --&gt;调用 WEXITSTATUS(status) --&gt; 得到 子进程 退出值。</p><p><strong>获取导致子进程异常终止信号：</strong></p><p>​WIFSIGNALED(status) --&gt; 为真 --&gt;调用 WTERMSIG(status) --&gt; 得到 导致子进程异常终止的信号编号。</p><p><strong>小案例</strong>：</p><p>捕获程序异常终止的信号并打印：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">pid_t</span> pid, wpid;  </span><br><span class="line">    <span class="type">int</span> status;  </span><br><span class="line">  </span><br><span class="line">    pid = fork();  </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---child, my id= %d, going to sleep 10s\n&quot;</span>, getpid());  </span><br><span class="line">        sleep(<span class="number">10</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------child die--------------\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">73</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">//wpid = wait(NULL);          // 不关心子进程结束原因  </span></span><br><span class="line">        wpid = wait(&amp;status);       <span class="comment">// 如果子进程未终止,父进程阻塞在这个函数上  </span></span><br><span class="line">        <span class="keyword">if</span> (wpid == <span class="number">-1</span>) &#123;  </span><br><span class="line">            perror(<span class="string">&quot;wait error&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;        <span class="comment">//为真,说明子进程正常终止.   </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d\n&quot;</span>, WEXITSTATUS(status));  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;      <span class="comment">//为真,说明子进程是被信号终止.  </span></span><br><span class="line">  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child kill with signal %d\n&quot;</span>, WTERMSIG(status));  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------parent wait finish: %d\n&quot;</span>, wpid);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="4-2-3-waitpid-函数、">4.2.3 waitpid()函数、</h4><p>指定某一个进程进行回收。可以设置非阻塞。</p><p>waitpid(-1, &amp;status, 0) == wait(&amp;status);</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// man 2 waitpid</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这个函数可以设置阻塞, 也可以设置为非阻塞</span></span><br><span class="line"><span class="comment">// 这个函数可以指定回收哪些子进程的资源</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数</strong></p><ul class="lvl-0"><li class="lvl-2"><p>pid：指定回收某一个子进程pid</p><ul class="lvl-2"><li class="lvl-4">大于0 回收指定 ID 的子进程</li><li class="lvl-4">-1 回收任意子进程（相当于wait）</li><li class="lvl-4">0 回收和当前调用waitpid 一个组的所有子进程</li><li class="lvl-4">小于 -1 回收指定进程组内的任意子进程</li></ul></li><li class="lvl-2"><p>status：（传出参数） 回收进程的状态,同wait()函数</p></li><li class="lvl-2"><p>options：控制函数是阻塞还是非阻塞</p><ul class="lvl-2"><li class="lvl-4">WNOHANG ：指定回收方式为，非阻塞</li><li class="lvl-4">0： 函数是行为是阻塞的 ==&gt; 和 wait 一样</li></ul></li></ul><p><strong>函数返回值</strong></p><ul class="lvl-0"><li class="lvl-2"><p>大于0 : 表成功回收的子进程 pid</p></li><li class="lvl-2"><p>等于0 : 函数是非阻塞的，并且子进程还在运行</p></li><li class="lvl-2"><p>-1: 失败。并设置errno</p></li></ul><p><strong>小案例</strong>：</p><p>回收指定子进程:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="type">pid_t</span> pid, wpid, tmpid;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;         </span><br><span class="line">        pid = fork();  </span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;       <span class="comment">// 循环期间, 子进程不 fork   </span></span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;  </span><br><span class="line">            tmpid = pid;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;--------pid = %d\n&quot;</span>, tmpid);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">5</span> == i) &#123;       <span class="comment">// 父进程, 从表达式2跳出  </span></span><br><span class="line">        sleep(<span class="number">5</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent , before waitpid, pid = %d\n&quot;</span>, tmpid);  </span><br><span class="line">  </span><br><span class="line">        wpid = waitpid(tmpid, <span class="literal">NULL</span>, WNOHANG);   <span class="comment">//指定一个进程回收, 不阻塞  </span></span><br><span class="line">        <span class="comment">//wpid = waitpid(tmpid, NULL, 0);         //指定一个进程回收, 阻塞回收  </span></span><br><span class="line">        <span class="keyword">if</span> (wpid == <span class="number">-1</span>) &#123;  </span><br><span class="line">            perror(<span class="string">&quot;waitpid error&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m parent, wait a child finish : %d \n&quot;</span>, wpid);  </span><br><span class="line">   </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 子进程, 从 break 跳出  </span></span><br><span class="line">         sleep(i);  </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %dth child, pid= %d\n&quot;</span>, i+<span class="number">1</span>, getpid());  </span><br><span class="line">     &#125;  </span><br><span class="line">   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="4-2-4-waitpid-回收多个子进程">4.2.4 waitpid()回收多个子进程</h4><p>一次wait/waitpid函数调用，只能回收一个子进程。下面来演示回收多个子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 回收子进程的资源</span></span><br><span class="line">            <span class="comment">// 子进程有多个, 需要循环回收子进程资源</span></span><br><span class="line">            <span class="comment">// 子进程退出了就回收, </span></span><br><span class="line">            <span class="comment">// 没退出就不回收, 返回0</span></span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);  <span class="comment">// 非阻塞</span></span><br><span class="line">            <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收了子进程资源, 子进程PID: %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="comment">// 判断进程是不是正常退出</span></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程退出时候的状态码: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程是被这个信号杀死的: %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程还没有退出, 不做任何处理...\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收失败, 或者是已经没有子进程了...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-进程相关概念&quot;&gt;1.进程相关概念&lt;/h2&gt;
&lt;h3 id=&quot;1-1-程序和进程&quot;&gt;1.1 程序和进程&lt;/h3&gt;
&lt;p&gt;程序：是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、 设备、锁…)，是一个静态的概念 。&lt;/p&gt;
&lt;p&gt;进程：被</summary>
      
    
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="进程" scheme="https://billysturate.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程之文件IO</title>
    <link href="https://billysturate.github.io/posts/651c43c5.html"/>
    <id>https://billysturate.github.io/posts/651c43c5.html</id>
    <published>2022-08-22T10:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-linux-man-1-2-3的作用">1.linux man 1 2 3的作用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、Standard commands （标准命令）</span><br><span class="line">2、System calls （系统调用）</span><br><span class="line">3、Library functions （库函数）</span><br><span class="line">4、Special devices （设备说明）</span><br><span class="line">5、File formats （文件格式）</span><br><span class="line">6、Games and toys （游戏和娱乐）</span><br><span class="line">7、Miscellaneous （杂项）</span><br><span class="line">8、Administrative Commands （管理员命令）</span><br><span class="line">9 其他（Linux特定的）， 用来存放内核例行程序的文档。</span><br></pre></td></tr></table></figure><p>说明：</p><p>系统调用     Linux内核提供的函数</p><p>库调用       c语言标准库函数和编译器特定库函数</p><p>例子：</p><p><code>man 1 cd</code></p><p><code>man 2 open</code></p><p><code>man 3 printf</code></p><p><strong>一个小案例</strong>:</p><p>C 标准函数和系统函数调用关系。一个 helloworld 如何打印到屏幕。</p><p><img src="https://img-blog.csdnimg.cn/bec6e0db7d184e3dae21532fba9f82be.png#pic_center" alt=""></p><h2 id="2-open函数">2.open函数</h2><h3 id="2-1函数原型">2.1函数原型</h3><p>manpage 第二卷(系统调用函数)，输入<mark>man 2 open</mark>指令</p><p>open函数如下，有两个版本的</p><p><img src="https://img-blog.csdnimg.cn/34cb8ac8d12b45eaaacfb49a30a1c59d.png#pic_center" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>open是一个系统函数, 只能在linux系统中使用, windows不支持</p></li><li class="lvl-2"><p>fopen 是标准c库函数, 一般都可以跨平台使用, 可以这样理解:</p><p>在linux中 fopen底层封装了Linux的系统API open</p><p>在window中, fopen底层封装的是 window 的 api</p></li></ul><h3 id="2-2函数参数">2.2函数参数</h3><ul class="lvl-0"><li class="lvl-2"><p><code>pathname</code>   文件路径</p></li><li class="lvl-2"><p><code>flags</code>     文件打开方式：只读，只写，读写，创建，添加等。 <code>O_RDONLY, O_WRONLY, O_RDWR，O_CREAT，O_APPEND，O_TRUNC，O_EXCL，O_NONBLOCK </code></p></li></ul><ul class="lvl-0"><li class="lvl-2"><p><code>mode参数</code>，用来指定文件的权限，数字设定法。文件权限 = mode &amp; ~umask。参数3使用的前提， 参2指定了 <code>O_CREAT</code>。 用来描述文件的访问权限。</p></li></ul><h3 id="2-3函数返回值">2.3函数返回值</h3><p>当open出错时，程序会自动设置errno，可以通过strerror(errno)来查看报错数字的含义</p><p>以打开不存在文件为例：</p><p><img src="https://img-blog.csdnimg.cn/cc3774bb155949aea31878d008bcca8d.png#pic_center" alt=""></p><p>执行该代码，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/f6e7d05af99d4f9a9b13776c9fad8841.png#pic_center" alt=""></p><h2 id="3-close-函数">3.close()函数</h2><h3 id="3-1函数原型">3.1函数原型</h3><p><code>int close(int fd)</code></p><h3 id="3-2函数参数">3.2函数参数</h3><ul class="lvl-0"><li class="lvl-2"><p>fd 表示改文件的文件描述符，open的返回值</p></li><li class="lvl-2"><p>返回值　成功为0 失败返回-1</p></li></ul><p>小案例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  fd;</span><br><span class="line">fd=open(<span class="string">&quot;tmp.txt&quot;</span>,O_RDONLY);</span><br><span class="line">close（fd）；</span><br></pre></td></tr></table></figure><h2 id="4-read-函数">4.read()函数</h2><h3 id="4-1函数原型">4.1函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><h3 id="4-2函数参数">4.2函数参数</h3><ul class="lvl-0"><li class="lvl-2"><p>fd: 文件描述符，open () 函数的返回值，通过这个参数定位打开的磁盘文件</p></li><li class="lvl-2"><p>buf: 是一个传出参数，指向一块有效的内存，用于存储从文件中读出的数据</p></li><li class="lvl-2"><p>count: buf 指针指向的内存的大小，指定可以存储的最大字节数</p></li></ul><h3 id="4-3函数返回值">4.3函数返回值</h3><ul class="lvl-0"><li class="lvl-2"><p>大于 0: 从文件中读出的字节数，读文件成功</p></li><li class="lvl-2"><p>等于 0: 代表文件读完了，读文件成功</p></li><li class="lvl-2"><p>-1: 读文件失败了,并设置 errno</p></li></ul><p><strong>如果返回-1： 并且 errno = EAGIN 或 EWOULDBLOCK, 说明不是read失败，而是read在以非阻塞方式读一个设备文件（网络文件），并且文件无数据。</strong></p><h2 id="5-write-函数">5.write()函数</h2><h3 id="5-1函数原型">5.1函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><h3 id="5-2函数参数">5.2函数参数</h3><ul class="lvl-0"><li class="lvl-2"><p>fd: 文件描述符，open () 函数的返回值，通过这个参数定位打开的磁盘文件</p></li><li class="lvl-2"><p>buf: 指向一块有效的内存地址，里边有要写入到磁盘文件中的数据</p></li><li class="lvl-2"><p>count: 要往磁盘文件中写入的字节数，一般情况下就是 buf 字符串的长度，strlen (buf)</p></li></ul><h3 id="5-3函数返回值">5.3函数返回值</h3><ul class="lvl-0"><li class="lvl-2"><p>大于 0: 成功写入到磁盘文件中的字节数</p></li><li class="lvl-2"><p>-1: 写文件失败了</p></li></ul><h2 id="6-小案例：用read-和write-函数实现copy功能">6.小案例：用read()和write()函数实现copy功能</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件的拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开存在的文件english.txt, 读这个文件</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-readfile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 打开不存在的文件, 将其创建出来, 将从english.txt读出的内容写入这个文件中</span></span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;copy.txt&quot;</span>, O_WRONLY|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-writefile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 循环读文件, 循环写文件</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( (len = read(fd1, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将读到的数据写入到另一个文件中</span></span><br><span class="line">        write(fd2, buf, len); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 关闭文件</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-系统调用和库函数比较—预读入缓输出">7.系统调用和库函数比较—预读入缓输出</h2><p>下面写两个文件拷贝函数，一个用read/write实现，一个用fputc/fgetc实现，比较他们两个之间的速度</p><p><mark>fputc/fgetc实现</mark></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp,*fp_out;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  fp = fopen(<span class="string">&quot;hello.c&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  fp_out = fopen(<span class="string">&quot;hello.cp&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(fp_out == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">while</span>((n = fgetc(fp)) != EOF)</span><br><span class="line">  &#123;</span><br><span class="line">    fputc(n, fp_out);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(fp);</span><br><span class="line">  fclose(fp_out);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>下面修改read那边的缓冲区，一次拷贝一个字符。</mark></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件的拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd1 = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-readfile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> fd2 = open(argv[<span class="number">2</span>], O_WRONLY|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-writefile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 循环读文件, 循环写文件</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( (len = read(fd1, buf, <span class="number">1</span>)) &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将读到的数据写入到另一个文件中</span></span><br><span class="line">        write(fd2, buf, len); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 关闭文件</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/cc4017b457f84fc0ac031c6606d07f3a.png#pic_center" alt=""></p><p>我猜很多人会觉得，read/write函数会比fputc/fgetc这些c语言标准库函数更快，因为read/write函数是系统调用函数，更接近linux内核。</p><p>其实不然，实际上fputc/fgetc会更快，为什么呢?下面我来分析一下</p><p><strong>原因分析：</strong></p><p>read/write，每次写一个字节，由于在用户区没缓冲区，会疯狂进行内核态和用户态的切换，所以非常耗时。</p><p>fgetc/fputc，在用户区有个缓冲区，所以它并不是一个字节一个字节地写进，内核和用户切换就比较少</p><p>所以系统函数并不是一定比库函数牛逼，能使用库函数的地方就使用库函数。</p><p>标准IO函数自带用户缓冲区，系统调用无用户级缓冲。系统缓冲区是都有的。</p><p>这就是<strong>预读入，缓输出机制</strong>。</p><p><img src="https://img-blog.csdnimg.cn/5936e1065bd24b9c870923412337b9d3.png#pic_center" alt=""></p><h2 id="8-阻塞和非阻塞">8.阻塞和非阻塞</h2><p><strong>阻塞、非阻塞： 是设备文件、网络文件的属性。</strong></p><p>产生阻塞的场景。 读设备文件。读网络文件。（读常规文件无阻塞概念。）</p><p>/dev/tty – 终端文件。</p><p>open(“/dev/tty”, O_RDWR|O_NONBLOCK)  — 设置 /dev/tty 非阻塞状态。(默认为阻塞状态)</p><blockquote><p>小案例：从标准输入读，写到标准输出</p></blockquote><p><img src="https://img-blog.csdnimg.cn/339e087f61a745d6bd1991794edfcf13.png#pic_center" alt=""></p><p>执行程序，就会发现程序在阻塞等待输入</p><p><img src="https://img-blog.csdnimg.cn/4a9c4c873fd74094a55fa1cc2b6c7612.png#pic_center" alt=""></p><p>下面是一段更改非阻塞读取终端的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TRY <span class="string">&quot;try again\n&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TIMEOUT <span class="string">&quot;time out\n&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd, n, i;  </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY | O_NONBLOCK);  </span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">        perror(<span class="string">&quot;open /dev/tty&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;open /dev/tty ok... %d\n&quot;</span>, fd);  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//轮询读取</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;  </span><br><span class="line">        n = read(fd, buf, <span class="number">10</span>);  </span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;                    <span class="comment">//说明读到了东西  </span></span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;          <span class="comment">//EWOULDBLOCK    </span></span><br><span class="line">            perror(<span class="string">&quot;read /dev/tty&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            write(STDOUT_FILENO, MSG_TRY, <span class="built_in">strlen</span>(MSG_TRY));  </span><br><span class="line">            sleep(<span class="number">2</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//超时判断</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;  </span><br><span class="line">        write(STDOUT_FILENO, MSG_TIMEOUT, <span class="built_in">strlen</span>(MSG_TIMEOUT));  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        write(STDOUT_FILENO, buf, n);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>执行，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/169bdb2eb71f42b5a26bd23fd636c2ec.png#pic_center" alt=""></p><h2 id="9-fcntl-函数">9.fcntl()函数</h2><blockquote><p>fcntl用来改变一个已经打开的文件的访问控制属性</p></blockquote><p>重点掌握两个参数的使用， <code>F_GETFL</code>，<code>F_SETFL </code></p><h3 id="9-1fcntl函数原型：">9.1fcntl函数原型：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure><h3 id="9-2函数参数">9.2函数参数:</h3><ul class="lvl-0"><li class="lvl-2"><p><code>fd</code>   文件描述符</p></li><li class="lvl-2"><p><code>cmd  命令</code>，决定了后续参数个数</p></li><li class="lvl-2"><p>获取文件状态： <code>F_GETFL</code></p></li><li class="lvl-2"><p>设置文件状态：<code> F_SETFL</code></p></li></ul><h3 id="9-3函数返回值">9.3函数返回值</h3><p><code> int flgs = fcntl(fd, F_GETFL);</code></p><p><code>flgs |= O_NONBLOCK</code></p><p><code> fcntl(fd, F_SETFL, flgs);</code></p><p><strong>一个小案例：</strong></p><p>终端文件默认是阻塞读的，这里用fcntl将其更改为非阻塞读：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TRY <span class="string">&quot;try again\n&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];  </span><br><span class="line">    <span class="type">int</span> flags, n;  </span><br><span class="line"></span><br><span class="line">    flags = fcntl(STDIN_FILENO, F_GETFL); <span class="comment">//获取stdin属性信息  </span></span><br><span class="line">    <span class="keyword">if</span>(flags == <span class="number">-1</span>)&#123;  </span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    flags |= O_NONBLOCK;  </span><br><span class="line">    <span class="type">int</span> ret = fcntl(STDIN_FILENO, F_SETFL, flags);  </span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;  </span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">tryagain:  </span><br><span class="line">    n = read(STDIN_FILENO, buf, <span class="number">10</span>);  </span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(errno != EAGAIN)&#123;          </span><br><span class="line">            perror(<span class="string">&quot;read /dev/tty&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        sleep(<span class="number">3</span>);  </span><br><span class="line">        write(STDOUT_FILENO, MSG_TRY, <span class="built_in">strlen</span>(MSG_TRY));  </span><br><span class="line">        <span class="keyword">goto</span> tryagain;  </span><br><span class="line">    &#125;  </span><br><span class="line">    write(STDOUT_FILENO, buf, n);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="10-lseek-函数">10.lseek()函数</h2><blockquote><p>系统函数 lseek 的功能是比较强大的，我们既可以通过这个函数移动文件指针，也可以通过这个函数进行文件的拓展。</p></blockquote><h3 id="10-1函数原型">10.1函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><h3 id="10-2-函数参数">10.2 函数参数</h3><ul class="lvl-0"><li class="lvl-2"><p>fd: 文件描述符，open () 函数的返回值，通过这个参数定位打开的磁盘文件</p></li><li class="lvl-2"><p>offset: 偏移量，需要和第三个参数配合使用</p></li><li class="lvl-2"><p>whence: 通过这个参数指定函数实现什么样的功能</p><ul class="lvl-2"><li class="lvl-4"><code>SEEK_SET</code>: 从文件头部开始偏移 offset 个字节</li><li class="lvl-4"><code>SEEK_CUR</code>: 从当前文件指针的位置向后偏移 offset 个字节</li><li class="lvl-4"><code>SEEK_END</code>: 从文件尾部向后偏移 offset 个字节</li></ul></li></ul><h3 id="10-3-函数返回值">10.3 函数返回值</h3><ul class="lvl-0"><li class="lvl-2"><p>成功：文件指针从头部开始计算总的偏移量</p></li><li class="lvl-2"><p>失败: -1</p></li></ul><p><strong>一个小案例：</strong></p><p>写一个句子到空白文件，完事调整光标位置，读取刚才写那个文件。</p><p>这个示例中，如果不调整光标位置，是读取不到内容的，因为读写指针在内容的末尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> fd, n;  </span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;It&#x27;s a test for lseek\n&quot;</span>;  </span><br><span class="line">    <span class="type">char</span> ch;  </span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;lseek.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0644</span>);  </span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">        perror(<span class="string">&quot;open lseek.txt error&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    write(fd, msg, <span class="built_in">strlen</span>(msg));     </span><br><span class="line">      </span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);        </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span>((n = read(fd, &amp;ch, <span class="number">1</span>)))&#123;  </span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">            perror(<span class="string">&quot;read error&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        write(STDOUT_FILENO, &amp;ch, n);   <span class="comment">//将文件内容按字节读出，写出到屏幕  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    close(fd);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong></p><p>​1. 文件的“读”、“写”使用同一偏移位置。</p><p>​2. 使用lseek获取文件大小（返回值接收）</p><p>​3. 使用lseek拓展文件大小：要想使文件大小真正拓展，必须【引起IO操作】。</p><p><mark>小案例：</mark></p><p>用lseek的偏移来读取文件大小</p><p><img src="https://img-blog.csdnimg.cn/9059d78a4e794e71b0695cc88a595fd4.png#pic_center" alt=""></p><p>用lseek实现文件拓展：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lseek.c</span></span><br><span class="line"><span class="comment">// 拓展文件大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件拓展, 一共增加了 1001 个字节</span></span><br><span class="line">    lseek(fd, <span class="number">1000</span>, SEEK_END);</span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-truncate-ftruncate-函数">11.truncate()/ftruncate()函数</h2><blockquote><p>truncate/ftruncate 这两个函数的功能是一样的，可以对文件进行拓展也可以截断文件。使用这两个函数拓展文件比使用 lseek 要简单。这两个函数的函数原型如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓展文件或截断文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line">- </span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>path: 要拓展 / 截断的文件的文件名</p></li><li class="lvl-2"><p>fd: 文件描述符，open () 得到的</p></li><li class="lvl-2"><p>length: 文件的最终大小</p><ul class="lvl-2"><li class="lvl-4">文件原来 size &gt; length，文件被截断，尾部多余的部分被删除，文件最终长度为 length</li><li class="lvl-4">文件原来 size &lt; length，文件被拓展，文件最终长度为 length</li></ul></li></ul><p><strong>函数返回值</strong>：</p><p>成功返回 0; 失败返回值 - 1</p><p>truncate () 和 ftruncate () 两个函数的区别在于一个使用文件名一个使用文件描述符操作文件，功能相同。</p><p>不管是使用这两个函数还是使用 lseek () 函数拓展文件，文件尾部填充的字符都是 0。</p><p><strong>小案例：</strong></p><p>直接拓展文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = truncate(<span class="string">&quot;dict.cp&quot;</span>, <span class="number">250</span>);</span><br></pre></td></tr></table></figure><h2 id="12-目录项和inode">12.目录项和inode</h2><p><img src="https://img-blog.csdnimg.cn/1bdd32d3d345471dba5ed4da04572d9f.png#pic_center" alt=""></p><p>一个文件主要由两部分组成，dentry(目录项)和inode</p><p>inode本质是结构体，存储文件的属性信息，如：权限、类型、大小、时间、用户、盘快位置…</p><p>也叫做文件属性管理结构，大多数的inode都存储在磁盘上。</p><p>少量常用、近期使用的inode会被缓存到内存中。</p><p>所谓的删除文件，就是删除inode，但是数据其实还是在硬盘上，以后会覆盖掉。</p><h2 id="13-stat-lstate-函数">13.stat()/lstate()函数</h2><p><mark>想深入了解，请看这篇博客,下面只介绍常用的</mark></p><p><a href="https://subingwen.cn/linux/stat/">点我查看</a></p><p>用来获取文件或目录的详细属性信息包括文件系统状态，（从第二个参数结构体中获取）</p><h3 id="13-1-函数原型">13.1 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><p><mark>二者的区别:</mark></p><p><code>lstat ():</code> 得到的是软连接文件本身的属性信息<br><code>stat ():</code> 得到的是软链接文件关联的文件的属性信息(<strong>存在符号穿透</strong>)</p><h3 id="13-2-函数参数">13.2 函数参数</h3><ul class="lvl-0"><li class="lvl-2"><p><code>pathname:</code> 文件名，要获取这个文件的属性信息</p></li><li class="lvl-2"><p><code>buf: </code>传出参数，文件的信息被写入到了这块内存中</p></li></ul><blockquote><p>这个函数的第二个参数是一个结构体类型，这个结构体相对复杂，通过这个结构体可以存储得到的文件的所有属性信息，结构体原型如下:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>          st_dev;        <span class="comment">// 文件的设备编号</span></span><br><span class="line">    <span class="type">ino_t</span>           st_ino;        <span class="comment">// inode节点</span></span><br><span class="line">    <span class="type">mode_t</span>      st_mode;      <span class="comment">// 文件的类型和存取的权限, 16位整形数  -&gt; 常用</span></span><br><span class="line">    <span class="type">nlink_t</span>        st_nlink;     <span class="comment">// 连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">    <span class="type">uid_t</span>           st_uid;       <span class="comment">// 用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>           st_gid;       <span class="comment">// 组ID</span></span><br><span class="line">    <span class="type">dev_t</span>          st_rdev;      <span class="comment">// (设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">    <span class="type">off_t</span>            st_size;      <span class="comment">// 文件字节数(文件大小)   --&gt; 常用</span></span><br><span class="line">    <span class="type">blksize_t</span>     st_blksize;   <span class="comment">// 块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line">    <span class="type">blkcnt_t</span>      st_blocks;    <span class="comment">// block的块数</span></span><br><span class="line">    <span class="type">time_t</span>         st_atime;     <span class="comment">// 最后一次访问时间</span></span><br><span class="line">    <span class="type">time_t</span>         st_mtime;     <span class="comment">// 最后一次修改时间(文件内容)</span></span><br><span class="line">    <span class="type">time_t</span>         st_ctime;     <span class="comment">// 最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="13-3-各种操作">13.3 各种操作</h3><p><strong>获取文件大小</strong><br>下面调用 stat () 函数，以代码的方式演示一下如何得到某个文件的大小:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 定义结构体, 存储文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myst</span>;</span></span><br><span class="line">    <span class="comment">// 2. 获取文件属性 english.txt</span></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;./english.txt&quot;</span>, &amp;myst);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件大小: %d\n&quot;</span>, (<span class="type">int</span>)myst.st_size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取文件类型</strong><br>文件的类型信息存储在 struct stat 结构体的 st_mode 成员中，它是一个 mode_t 类型，本质上是一个 16 位的整数。Linux API 中为我们提供了相关的宏函数，通过对应的宏函数可以直接判断出文件是不是某种类型，这些信息都可以通过 man 文档（man 2 stat）查询到。</p><p>相关的宏函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型是存储在结构体的这个成员中: mode_t  st_mode;  </span></span><br><span class="line"><span class="comment">// 这些宏函数中的m 对应的就是结构体成员  st_mode</span></span><br><span class="line"><span class="comment">// 宏函数返回值: 是对应的类型返回-&gt; 1, 不是对应类型返回0</span></span><br><span class="line"></span><br><span class="line">S_ISREG(m)  is it a regular file?  </span><br><span class="line">- 普通文件</span><br><span class="line">S_ISDIR(m)  directory?</span><br><span class="line">- 目录</span><br><span class="line">S_ISCHR(m)  character device?</span><br><span class="line">- 字符设备</span><br><span class="line">S_ISBLK(m)  block device?</span><br><span class="line">- 块设备</span><br><span class="line">S_ISFIFO(m) FIFO (named pipe)?</span><br><span class="line">- 管道</span><br><span class="line">S_ISLNK(m)  symbolic link?  (Not in POSIX<span class="number">.1</span><span class="number">-1996.</span>)</span><br><span class="line">- 软连接</span><br><span class="line">S_ISSOCK(m) socket?  (Not in POSIX<span class="number">.1</span><span class="number">-1996.</span>)</span><br><span class="line">    - 本地套接字文件</span><br></pre></td></tr></table></figure><p>在程序中通过宏函数判断文件类型，实例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 定义结构体, 存储文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myst</span>;</span></span><br><span class="line">    <span class="comment">// 2. 获取文件属性 english.txt</span></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;./hello&quot;</span>, &amp;myst);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件大小: %d\n&quot;</span>, (<span class="type">int</span>)myst.st_size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断文件类型</span></span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个普通文件...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个目录...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISLNK(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个软连接文件...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-目录操作函数">13.目录操作函数</h2><h3 id="13-1opendir-函数">13.1opendir()函数</h3><blockquote><p>在目录操作之前必须要先通过 opendir () 函数打开这个目录，函数原型如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="comment">// 打开目录</span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数: name -&gt; 要打开的目录的名字</p></li><li class="lvl-2"><p>返回值: DIR*, 结构体类型指针。打开成功返回目录的实例，打开失败返回 NULL</p></li></ul><h3 id="13-2readdir-函数">13.2readdir()函数</h3><blockquote><p>目录打开之后，就可以通过 readdir () 函数遍历目录中的文件信息了。每调用一次这个函数就可以得到目录中的一个文件信息，当目录中的文件信息被全部遍历完毕会得到一个空对象。先来看一下这个函数原型：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数：dirp -&gt; opendir () 函数的返回值</p></li><li class="lvl-2"><p>返回值：函数调用成功，返回读到的文件的信息，目录文件被读完了或者函数调用失败返回 NULL</p></li><li class="lvl-2"><p>函数返回值 struct dirent 结构体原型如下:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="type">ino_t</span>          d_ino;       <span class="comment">/* 文件对应的inode编号, 定位文件存储在磁盘的那个数据块上 */</span></span><br><span class="line">    <span class="type">off_t</span>          d_off;       <span class="comment">/* 文件在当前目录中的偏移量 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* 文件名字的实际长度 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* 文件的类型, linux中有7中文件类型 */</span></span><br><span class="line">    <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* 文件的名字 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于结构体中的文件类型 <code>d_type</code>，可使用的宏值如下</p><p><code>DT_BLK</code>：块设备文件<code>DT_CHR</code>：字符设备文件<code>DT_DIR</code>：目录文件<br><code>DT_FIFO</code> ：管道文件<code>DT_LNK</code>：软连接文件<code>DT_REG </code>：普通文件<code>DT_SOCK</code>：本地套接字文件<code>DT_UNKNOWN</code>：无法识别的文件类型</p><p>通过 readdir () 函数遍历某一个目录中的文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开目录</span></span><br><span class="line">DIR* dir = opendir(<span class="string">&quot;/home/test&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 遍历目录</span></span><br><span class="line"><span class="keyword">while</span>( (ptr=readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-3closedir-函数">13.3closedir()函数</h3><blockquote><p>目录操作完毕之后，需要通过 closedir() 关闭通过 opendir() 得到的实例，释放资源。函数原型如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭目录, 参数是 opendir() 的返回值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数：dirp-&gt; opendir () 函数的返回值</p></li><li class="lvl-2"><p>返回值：目录关闭成功返回 0, 失败返回 -1</p></li></ul><h2 id="14-文件描述符复制和重定向-dup-dup2-命令">14.文件描述符复制和重定向(dup(),dup2()命令)</h2><p><mark>请看这篇博客，写的很好</mark></p><p><a href="https://subingwen.cn/linux/fcntl-dup2/">点我查看</a></p><h2 id="15-文件描述符">15.文件描述符</h2><p><img src="https://img-blog.csdnimg.cn/b1d28fb9eeba498596caada0683f47c0.png#pic_center" alt=""></p><p>如上图所示，是我们的虚拟地址空间，其中0-3G为用户区，3-4G为内核区，其中我们的PCB进程控制块就在内核区，它的本质是一个结构体，在这个结构体中有一个成员变量 file_struct *file 指向文件描述符表。 从应用程序使用角度，该指针可理解记忆成一个字符指针数组，下标 0/1/2/3/4…找到文件结构体。本质是一个键值对 0、1、2…都分别对应具体地址。但键值对使用的特性是自动映射，我们只操作键不直接使用值。 新打开文件返回文件描述符表中未使用的最小文件描述符。<br><code>STDIN_FILENO</code>   0标准输入 （键盘）<br><code>STDOUT_FILENO</code> 1标准输出（显示器）<br><code>STDERR_FILENO </code> 2标准错误</p><p><strong>一个进程默认打开文件的个数 1024。</strong></p><h2 id="16-写在最后">16.写在最后</h2><blockquote><p>本文章是我在b站跟着黑马Linux系统编程学习时的笔记，为了防止遗忘和以后复习，写下这篇笔记，如有错误，欢迎指出</p></blockquote><p>笔记中有的地方我是参考了这个博主的博客内容，这个博主的文章质量真的很高，这是它的博客<a href="https://subingwen.cn/linux/">点我查看</a>，这是他的b站账号，有很多优质视频，强烈推荐<a href="https://space.bilibili.com/147020887/?spm_id_from=333.999.0.0">点我查看</a></p><p><mark>黑马Linux系统编程视频链接</mark></p><p><a href="https://www.bilibili.com/video/BV1KE411q7ee?spm_id_from=333.999.list.card_archive.click&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">点我查看</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-linux-man-1-2-3的作用&quot;&gt;1.linux man 1 2 3的作用&lt;/h2&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux系统编程" scheme="https://billysturate.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="文件IO" scheme="https://billysturate.github.io/tags/%E6%96%87%E4%BB%B6IO/"/>
    
  </entry>
  
  <entry>
    <title>Json详解</title>
    <link href="https://billysturate.github.io/posts/18760bb5.html"/>
    <id>https://billysturate.github.io/posts/18760bb5.html</id>
    <published>2022-08-19T06:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.187Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://subingwen.cn/qt/json/">原文链接</a><br>JSON(JavaScrip Object Notation) 是一种<mark>轻量级的数据交换格式</mark>。它基于 ECMAScript (欧洲计算机协会制定的 js 规范) 的一个子集，<mark>采用完全独立于编程语言的文本格式来存储和表示数据</mark>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>关于上面的描述可以精简为一句话：<mark>Json 是一种数据格式，和语言无关，在什么语言中都可以使用 Json</mark>。基于这种通用的数据格式，一般处理两方面的任务：</p><p>组织数据（数据序列化），用于数据的网络传输组织数据（数据序列化），写磁盘文件实现数据的持久化存储(一般以 <mark>.json</mark> 作为文件后缀)<br>Json 中主要有两种数据格式：Json 数组和 Json 对象，并且这两种格式可以交叉嵌套使用，下面依次介绍下这两种数据格式：</p><h2 id="1-Json-数组">1.Json 数组</h2><p>Json 数组使用 [] 表示，[] 里边是元素，元素和元素之间使用逗号间隔，<mark>最后一个元素后边没有逗号</mark>，一个 Json 数组中支持同时存在多种不同类型的成员，包括：<mark>整形</mark>、<mark>浮点</mark>、 <mark>字符串</mark>、 <mark>布尔类型</mark>、 <mark>json数组</mark>、 <mark>json对象</mark>、 <mark>空值-null</mark>。由此可见 Json 数组比起 C/C++ 数组要灵活很多。</p><blockquote><p>Json 数组中的元素数据类型一致</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整形</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;luffy&quot;</span><span class="punctuation">,</span> <span class="string">&quot;sanji&quot;</span><span class="punctuation">,</span> <span class="string">&quot;zoro&quot;</span><span class="punctuation">,</span> <span class="string">&quot;nami&quot;</span><span class="punctuation">,</span> <span class="string">&quot;robin&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><blockquote><p>Json 数组中的元素数据类型不一致</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="number">12</span><span class="punctuation">,</span> <span class="number">13.34</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="string">&quot;hello,world&quot;</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><blockquote><p>Json 数组中的数组嵌套使用</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;cat&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dog&quot;</span><span class="punctuation">,</span> <span class="string">&quot;panda&quot;</span><span class="punctuation">,</span> <span class="string">&quot;beer&quot;</span><span class="punctuation">,</span> <span class="string">&quot;rabbit&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;北京&quot;</span><span class="punctuation">,</span> <span class="string">&quot;上海&quot;</span><span class="punctuation">,</span> <span class="string">&quot;天津&quot;</span><span class="punctuation">,</span> <span class="string">&quot;重庆&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;luffy&quot;</span><span class="punctuation">,</span> <span class="string">&quot;boy&quot;</span><span class="punctuation">,</span> <span class="number">19</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><blockquote><p>Json 数组和对象嵌套使用</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;luffy&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">19</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;father&quot;</span><span class="punctuation">:</span><span class="string">&quot;Monkey·D·Dragon&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;grandpa&quot;</span><span class="punctuation">:</span><span class="string">&quot;Monkey D Garp&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brother1&quot;</span><span class="punctuation">:</span><span class="string">&quot;Portgas D Ace&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brother2&quot;</span><span class="punctuation">:</span><span class="string">&quot;Sabo&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="2-Json-对象">2.Json 对象</h2><p>Json 对象使用 {} 来描述，每个 Json 对象中可以存储若干个元素，每一个元素对应一个键值对（key：value 结构），元素和元素之间使用逗号间隔，最后一个元素后边没有逗号。对于每个元素中的键值对有以下细节需要注意：</p><p>1.键值（key）必须是字符串，位于同一层级的键值不要重复（因为是通过键值取出对应的 value 值）<br>2.value 值的类型是可选的，可根据实际需求指定，可用类型包括：<mark>整形</mark>、 <mark>浮点</mark>、 <mark>字符串</mark>、 <mark>布尔类型</mark>、<mark>json数组</mark>、 <mark>json对象</mark>、 <mark>空值-null</mark>。<br><strong>使用 Json 对象描述一个人的信息:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Name&quot;:&quot;Ace&quot;,</span><br><span class="line">    &quot;Sex&quot;:&quot;man&quot;,</span><br><span class="line">    &quot;Age&quot;:20,</span><br><span class="line">    &quot;Family&quot;:&#123;</span><br><span class="line">        &quot;Father&quot;:&quot;Gol·D·Roger&quot;,</span><br><span class="line">        &quot;Mother&quot;:&quot;Portgas·D·Rouge&quot;,</span><br><span class="line">        &quot;Brother&quot;:[&quot;Sabo&quot;, &quot;Monkey D. Luffy&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IsAlive&quot;:false,</span><br><span class="line">    &quot;Comment&quot;:&quot;yyds&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注意事项">3.注意事项</h2><p>通过上面的介绍可用看到，Json 的结构虽然简单，但是进行嵌套之后就可以描述很复杂的事情，在项目开发过程中往往需要我们根据实际需求自己定义 Json 格式用来存储项目数据。</p><p>另外，如果需要将 Json 数据持久化到磁盘文件中，需要注意一个问题：<mark>在一个 Json 文件中只能有一个 Json 数组或者 Json 对象的根节点，不允许同时存储多个并列的根节点</mark>。下面举例说明：</p><blockquote><p>错误的写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// test.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;luffy&quot;,</span><br><span class="line">    &quot;age&quot;:19</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot;:&quot;ace&quot;,</span><br><span class="line">    &quot;passwd&quot;:&quot;123456&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误原因：<mark>在一个 Json 文件中有两个并列的 Json 根节点（并列包含 Json 对象和 Json 对象、Json 对象和 Json 数组、Json 数组和 Json 数组），根节点只能有一个。</mark></p><blockquote><p>正确的写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// test.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Name&quot;:&quot;Ace&quot;,</span><br><span class="line">    &quot;Sex&quot;:&quot;man&quot;,</span><br><span class="line">    &quot;Age&quot;:20,</span><br><span class="line">    &quot;Family&quot;:&#123;</span><br><span class="line">        &quot;Father&quot;:&quot;Gol·D·Roger&quot;,</span><br><span class="line">        &quot;Mother&quot;:&quot;Portgas·D·Rouge&quot;,</span><br><span class="line">        &quot;Brother&quot;:[&quot;Sabo&quot;, &quot;Monkey D. Luffy&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IsAlive&quot;:false,</span><br><span class="line">    &quot;Comment&quot;:&quot;yyds&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>在上面的例子中通过Json对象以及Json数组的嵌套描述了一个人的身份信息，并且根节点只有一个就是Json对象，如果还需要使用Json数组或者Json对象描述其他信息，需要将这些信息写入到其他文件中，不要和这个Json对象并列写入到同一个文件里边，切记！！！</mark></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://subingwen.cn/qt/json/&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;
JSON(JavaScrip Object Notation) 是一种&lt;mark&gt;轻量级的数据交换格式&lt;/mark&gt;。它基于 ECMAScript (欧洲计算机协会制定</summary>
      
    
    
    
    <category term="Json" scheme="https://billysturate.github.io/categories/Json/"/>
    
    
    <category term="Json" scheme="https://billysturate.github.io/tags/Json/"/>
    
  </entry>
  
  <entry>
    <title>C++命名空间详解</title>
    <link href="https://billysturate.github.io/posts/553a97ec.html"/>
    <id>https://billysturate.github.io/posts/553a97ec.html</id>
    <published>2022-08-18T12:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-作用域运算符">1. ::作用域运算符</h2><p>通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//全局a被隐藏</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是a:20。在test函数的输出语句中，使用的变量a是test函数内定义的局部变量，因此输出的结果为局部变量a的值。</p><p>作用域运算符可以用来解决局部变量与全局变量的重名问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//1. 局部变量和全局变量同名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//打印局部变量a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">//打印全局变量a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量a:&quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子可以看出，作用域运算符可以用来解决局部变量与全局变量的重名问题，即在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。</p><h2 id="2-C-命名空间-namespace">2.  C++命名空间(namespace)</h2><p>在c++ 中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等。工程越大，名称互相冲突性的可能性越大。另外使用多个厂商的类库时，也可能导致名称冲突。为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++ 库时，这些标识符的命名发生冲突，标准C++ 引入关键字namespace（命名空间/名字空间/名称空间），可以更好地控制标识符的作用域。</p><h3 id="2-1命名空间使用语法">2.1命名空间使用语法</h3><p><mark>创建一个命名空间:</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>命名空间只能全局范围内定义（<strong>以下错误写法</strong>）</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>命名空间可嵌套命名空间</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::B::a : &quot;</span> &lt;&lt; A::B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>命名空间是开放的，即可以随时把新的成员加入已有的命名空间中</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello namespace!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">A::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>声明和实现可分离</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MySpace&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MySpace::func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func2</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MySpace::func2 : &quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><mark>无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; a &lt;&lt; endl;<span class="comment">//直接访问就行，可以看成静态变量</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>命名空间别名</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> veryLongName&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> shortName = veryLongName;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;veryLongName::a : &quot;</span> &lt;&lt; shortName::a &lt;&lt; endl;</span><br><span class="line">veryLongName::<span class="built_in">func</span>();</span><br><span class="line">shortName::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-using声明">2.2 using声明</h3><p>using声明可使得指定的标识符可用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">  <span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1. 通过命名空间域运算符</span></span><br><span class="line">cout &lt;&lt; A::paramA &lt;&lt; endl;</span><br><span class="line">A::<span class="built_in">funcA</span>();</span><br><span class="line"><span class="comment">//2. using声明</span></span><br><span class="line"><span class="keyword">using</span> A::paramA;</span><br><span class="line"><span class="keyword">using</span> A::funcA;</span><br><span class="line">cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; paramB &lt;&lt; endl; //不可直接访问</span></span><br><span class="line"><span class="built_in">funcA</span>();</span><br><span class="line"><span class="comment">//3. 同名冲突,using声明和就近原则不要同时出现</span></span><br><span class="line"><span class="comment">//int paramA = 20; //相同作用域注意同名冲突</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>using声明碰到函数重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> A::func;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。</p><h3 id="2-3-using编译指令">2.3 using编译指令</h3><p>using编译指令使整个命名空间标识符可用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcB&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; paramB &lt;&lt; endl;</span><br><span class="line"><span class="built_in">funcA</span>();</span><br><span class="line"><span class="built_in">funcB</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//不会产生二义性，using编译指令和就近原则同时出现，优先使用就近原则</span></span><br><span class="line"><span class="type">int</span> paramA = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcB&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line"><span class="comment">//二义性产生，不知道调用A还是B的paramA</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; paramA &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：使用using声明或using编译指令会增加命名冲突的可能性。也就是说，如果有名称空间，并在代码中使用作用域解析运算符，则不会出现二义性</strong></p></blockquote><h3 id="2-4-命名空间使用">2.4 命名空间使用</h3><p>我们刚讲的一些东西一开始会觉得难一些，这些东西以后还是挺常用，只要理解了它们的工作机理，使用它们非常简单。</p><p>需要记住的关键问题是当引入一个全局的using编译指令时，就为该文件打开了该命名空间，它不会影响任何其他的文件，所以可以在每一个实现文件中调整对命名空间的控制。比如，如果发现某一个实现文件中有太多的using指令而产生的命名冲突，就要对该文件做个简单的改变，通过明确的限定或者using声明来消除名字冲突，这样不需要修改其他的实现文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-作用域运算符&quot;&gt;1. ::作用域运算符&lt;/h2&gt;
&lt;p&gt;通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="C++" scheme="https://billysturate.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://billysturate.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++类型转换详解</title>
    <link href="https://billysturate.github.io/posts/3665bf7d.html"/>
    <id>https://billysturate.github.io/posts/3665bf7d.html</id>
    <published>2022-08-18T10:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.173Z</updated>
    
    <content type="html"><![CDATA[<p>类型转换(cast)是将一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。</p><p>转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的数据。</p><p>应该小心类型转换，因为转换也就相当于对编译器说：忘记类型检查，把它看做其他的类型。</p><blockquote><p>一般情况下，尽量少的去使用类型转换，除非用来解决非常特殊的问题。 无论什么原因，任何一个程序如果使用很多类型转换都值得怀疑.</p></blockquote><p>标准c++提供了一个显示的转换的语法，来替代旧的C风格的类型转换。</p><p>使用C风格的强制转换可以把想要的任何东西转换成我们需要的类型。那为什么还需要一个新的C++类型的强制转换呢？</p><p>新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。</p><h2 id="1-静态转换-static-cast">1. 静态转换(static_cast)</h2><p>用于<a href="http://baike.baidu.com/view/2405425.htm">类层次结构</a>中基类（父类）和<a href="http://baike.baidu.com/view/535532.htm">派生类</a>（子类）之间指针或引用的转换。</p><p>进行向上转换（把派生类的指针或引用转换成基类表示）是安全的；</p><p>进行向下转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</p><p>用于基本数据类型之间的转换，如把int转换成char，把char转换成int。这种转换的安全性也要开发人员来保证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;&#125;;</span><br><span class="line">class Dog : public Animal&#123;&#125;;</span><br><span class="line">class Other&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//基础数据类型转换</span><br><span class="line">void test01()&#123;</span><br><span class="line">char a = &#x27;a&#x27;;</span><br><span class="line">double b = static_cast&lt;double&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承关系指针互相转换</span><br><span class="line">void test02()&#123;</span><br><span class="line">//继承关系指针转换</span><br><span class="line">Animal* animal01 = NULL;</span><br><span class="line">Dog* dog01 = NULL;</span><br><span class="line">//子类指针转成父类指针,安全</span><br><span class="line">Animal* animal02 = static_cast&lt;Animal*&gt;(dog01);</span><br><span class="line">//父类指针转成子类指针，不安全</span><br><span class="line">Dog* dog02 = static_cast&lt;Dog*&gt;(animal01);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承关系引用相互转换</span><br><span class="line">void test03()&#123;</span><br><span class="line"></span><br><span class="line">Animal ani_ref;</span><br><span class="line">Dog dog_ref;</span><br><span class="line">//继承关系指针转换</span><br><span class="line">Animal&amp; animal01 = ani_ref;</span><br><span class="line">Dog&amp; dog01 = dog_ref;</span><br><span class="line">//子类指针转成父类指针,安全</span><br><span class="line">Animal&amp; animal02 = static_cast&lt;Animal&amp;&gt;(dog01);</span><br><span class="line">//父类指针转成子类指针，不安全</span><br><span class="line">Dog&amp; dog02 = static_cast&lt;Dog&amp;&gt;(animal01);</span><br><span class="line">&#125;</span><br><span class="line">//无继承关系指针转换</span><br><span class="line">void test04()&#123;</span><br><span class="line"></span><br><span class="line">Animal* animal01 = NULL;</span><br><span class="line">Other* other01 = NULL;</span><br><span class="line"></span><br><span class="line">//转换失败</span><br><span class="line">//Animal* animal02 = static_cast&lt;Animal*&gt;(other01);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-动态转换-dynamic-cast">2. 动态转换(dynamic_cast)</h2><p>dynamic_cast主要用于类层次间的向上转换和向下转换；</p><p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；</p><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowName</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I am a dog!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是其他类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不支持基础数据类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//double a = dynamic_cast&lt;double&gt;(a);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承关系指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Dog* dog01 = <span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类指针转换成父类指针 可以</span></span><br><span class="line">Animal* animal02 = <span class="built_in">dynamic_cast</span>&lt;Animal*&gt;(dog01);</span><br><span class="line">animal02-&gt;<span class="built_in">ShowName</span>();</span><br><span class="line"><span class="comment">//父类指针转换成子类指针 不可以</span></span><br><span class="line"><span class="comment">//Dog* dog02 = dynamic_cast&lt;Dog*&gt;(animal01);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承关系引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Dog dog_ref;</span><br><span class="line">Dog&amp; dog01 = dog_ref;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类引用转换成父类引用 可以</span></span><br><span class="line">Animal&amp; animal02 = <span class="built_in">dynamic_cast</span>&lt;Animal&amp;&gt;(dog01);</span><br><span class="line">animal02.<span class="built_in">ShowName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无继承关系指针转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Other* other = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可以</span></span><br><span class="line"><span class="comment">//Animal* animal02 = dynamic_cast&lt;Animal*&gt;(other);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-常量转换-const-cast">3. 常量转换(const_cast)</h2><p>该运算符用来修改类型的const属性。</p><p>常量指针被转化成非常量指针，并且仍然指向原来的对象；</p><p>常量引用被转换成非常量引用，并且仍然指向原来的对象；</p><p><strong>注意:</strong> 不能直接对非指针和非引用的变量使用const_cast操作符去直接移除它的const.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量指针转换成非常量指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>* np = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* pp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* npp = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(pp);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">//不能对非指针或非引用进行转换</span></span><br><span class="line"><span class="comment">//int b = const_cast&lt;int&gt;(a); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量引用转换成非常量引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp; refNum = num;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; refNum2 = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>&amp;&gt;(refNum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3-重新解释转换-reinterpret-cast-不建议使用">2.3 重新解释转换(reinterpret_cast)(不建议使用)</h2><p>这是最不安全的一种转换机制，最有可能出问题。</p><p>主要用于将一种数据类型从一种类型转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;类型转换(cast)是将一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。&lt;/p&gt;
&lt;p&gt;转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的</summary>
      
    
    
    
    <category term="C++" scheme="https://billysturate.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://billysturate.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>gdb详解</title>
    <link href="https://billysturate.github.io/posts/ff8b855b.html"/>
    <id>https://billysturate.github.io/posts/ff8b855b.html</id>
    <published>2022-08-12T11:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.199Z</updated>
    
    <content type="html"><![CDATA[<h1>一、调试前的准备</h1><p>用gcc编译源程序的时候，编译后的可执行文件不会包含源程序代码，如果您打算编译后的程序可以被调试，编译的时候要加-g的参数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o book113 book113.c</span><br></pre></td></tr></table></figure><p>在命令提示符下输入gdb book113就可以调试book113程序了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb book113</span><br></pre></td></tr></table></figure><h1>二、基本调试命令</h1><table><thead><tr><th><strong>命令</strong></th><th><strong>命令</strong>缩写</th><th>命令说明</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>列出源码，根据源码指定行号，设置断点</td></tr><tr><td>set args</td><td></td><td>设置主程序的参数。例如：./book119 /oracle/c/book1.c /tmp/book1.c设置参数的方法是：gdb book119(gdb) set args /oracle/c/book1.c /tmp/book1.c</td></tr><tr><td>break</td><td>b</td><td>设置断点，b 20 表示在第20行设置断点，可以设置多个断点。</td></tr><tr><td>run</td><td>r</td><td>开始运行程序, 程序运行到断点的位置会停下来，如果没有遇到断点，程序一直运行下去。</td></tr><tr><td>next</td><td>n</td><td>执行当前行语句，如果该语句为函数调用，不会进入函数内部执行。</td></tr><tr><td>step</td><td>s</td><td>执行当前行语句，如果该语句为函数调用，则进入函数执行其中的第一条语句。注意了，如果函数是库函数或第三方提供的函数，用s也是进不去的，因为没有源代码，如果是您自定义的函数，只要有源码就可以进去。</td></tr><tr><td>print</td><td>p</td><td>显示变量值，例如：p name表示显示变量name的值。</td></tr><tr><td>continue</td><td>c</td><td>继续程序的运行，直到遇到下一个断点。</td></tr><tr><td>set var name=value</td><td></td><td>设置变量的值，假设程序有两个变量：int ii; char name[21];set var ii=10 把ii的值设置为10；set var name=“fsda” 把name的值设置为&quot;fsda&quot;，注意，不是strcpy。</td></tr><tr><td>finish</td><td></td><td>结束当前函数调用，返回到函数调用点</td></tr><tr><td>info b</td><td></td><td>info b 查看设置的断点信息</td></tr><tr><td>ptype</td><td></td><td>查看变量类型 例如：ptype name表示查看变量name的类型</td></tr><tr><td>bt</td><td></td><td>列出当前程序存活者的栈帧</td></tr><tr><td>frame</td><td></td><td>根据栈帧编号,替换栈帧</td></tr><tr><td>(un)display</td><td></td><td>设置跟踪变量</td></tr><tr><td>quit</td><td>q</td><td>退出gdb环境。</td></tr></tbody></table><p>注意，在gdb环境中，可以用上下光标键选择执行过的gdb命令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、调试前的准备&lt;/h1&gt;
&lt;p&gt;用gcc编译源程序的时候，编译后的可执行文件不会包含源程序代码，如果您打算编译后的程序可以被调试，编译的时候要加-g的参数，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="Linux" scheme="https://billysturate.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://billysturate.github.io/tags/Linux/"/>
    
    <category term="gdb" scheme="https://billysturate.github.io/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>Vim/Vi常用命令总结</title>
    <link href="https://billysturate.github.io/posts/f8adb3e0.html"/>
    <id>https://billysturate.github.io/posts/f8adb3e0.html</id>
    <published>2022-08-11T10:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、是什么">一、是什么</h2><p>VI 是Unix操作系统和类Unix操作系统中最通用的文本编辑器。</p><p>VIM编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM与VI 编辑器完全兼容。</p><h2 id="二、创建-打开文件">二、创建/打开文件</h2><p>vim 文件名</p><p>打开一个文件，如果文件不存在，将会自动创建它。</p><p>示例：</p><p>vim book.c</p><h2 id="三、vim的三种模式">三、vim的三种模式</h2><p>vim 有三种模式，命令行模式、插入模式和替换模式，在命令行模式下，任何键盘输入都是命令，在插入模式和替换模式下，键盘输入的才是字符。</p><p>插入模式和替换模式也合称为编辑模式。</p><p><img src="https://bu.dusays.com/2022/12/31/63b00cb58dcdb.png" alt="p1.png"></p><h2 id="四、vim的常用命令">四、vim的常用命令</h2><p>Esc    从编辑模式切换到命令行模式。</p><p>i   在光标所在位置前面开始插入。</p><p>a   在光标所在的位置后面开始插入。</p><p>o  在光标所在位置行的下面插入空白行。</p><p>O  在光标所在位置行的上面插入空白行。</p><p>I   在光标所在位置行的行首开始插入。</p><p>A  在光标所在位置行的行末开始插入。</p><p>k   类似方向键上。</p><p>j   类似方向键下。</p><p>h  类似方向键左。</p><p>l   类是方向键右。</p><p>Ctrl+u  向上翻半页。</p><p>Ctrl+d  向下翻页。</p><p>Ctrl+g    显示光标所在位置的行号和文件的总行数。</p><p>nG 光标跳到文件的第n行行首。</p><p>G  光标跳到文件最后一行。</p><p>:5回车  光标跳到第5行。</p><p>:n回车  光标跳到第n行。</p><p>:set nu 设置行号</p><p>:set nonu 关闭行号</p><p>0   光标跳到当前行的行首。</p><p>$   光标跳到当前行的行尾。</p><p>Ctrl+Home 光标跳到整篇文章开头</p><p>Ctrl+End 光标跳到整篇文章结尾</p><p>w   光标跳到下个单词的开头。</p><p>b   光标跳到上个单词的开头。</p><p>e  光标跳到本单词的尾部。</p><p>x    每按一次，删除光标所在位置的一个字符。</p><p>nx  如&quot;3x&quot;表示删除光标所在位置开始的3个字符。</p><p>dw 删除光标所在位置到本单词结尾的字符。</p><p>D  删除本行光标所在位置后面全部的内容。</p><p>dd  删除光标所在位置的一行。</p><p>ndd 如&quot;3dd&quot;表示删除光标所在位置开始的3行。</p><p>yy  将光标所在位置的一行复制到缓冲区。</p><p>nyy 将光标所在位置的n行复制到缓冲区。</p><p>p   将缓冲区里的内容粘贴到光标所在位置。</p><p>r   替换光标所在位置的一个字符 replace。</p><p>R  从光标所在位置开始替换，直到按下&quot;Esc&quot;。</p><p>cw 从光标所在位置开始替换单词，直到按下&quot;Esc&quot;。</p><p>u  撤销命令，可多次撤销。</p><p>J  把当前行的下一行接到当前行的尾部。</p><p>/abcd  在当前打开的文件中查找“abcd”文本内容。</p><p>n   查找下一个。</p><p>N   查找上一下。</p><p>.  重复执行上一次执行的vi命令。</p><p>~  对光标当前所在的位置的字符进行大小写转换。</p><p>列操作</p><p>Ctrl+V  光标上或下  大写的I  输入内容  Esc</p><p>:w回车  存盘。</p><p>:w!回车  强制存盘。</p><p>:wq回车 存盘退出。</p><p>:x回车  存盘退出。</p><p>:q回车 不存盘退出。</p><p>:q!回车  不存盘强制退出。</p><p>:g/aaaaaaaaa/s//bbbbbb/g回车  把文件中全部的aaaaaaaaa替换成bbbbbb。</p><p>Ctl+insert  复制鼠标选中的文本，相当于Ctl+c。</p><p>Shift+insert 输出鼠标选中的文本，相当于Ctl+v。</p><p>以上两个命令在windows和UNIX中是通用的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、是什么&quot;&gt;一、是什么&lt;/h2&gt;
&lt;p&gt;VI 是Unix操作系统和类Unix操作系统中最通用的文本编辑器。&lt;/p&gt;
&lt;p&gt;VIM编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM与VI 编辑器完全兼</summary>
      
    
    
    
    <category term="Linux" scheme="https://billysturate.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://billysturate.github.io/tags/Linux/"/>
    
    <category term="Vim/Vi" scheme="https://billysturate.github.io/tags/Vim-Vi/"/>
    
  </entry>
  
  <entry>
    <title>pandas详解</title>
    <link href="https://billysturate.github.io/posts/a8ad0e8e.html"/>
    <id>https://billysturate.github.io/posts/a8ad0e8e.html</id>
    <published>2022-08-05T10:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.213Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1hx411d7jb?spm_id_from=333.337.search-card.all.click&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><h2 id="1-pandas的常用数据类型">1.pandas的常用数据类型</h2><p>1.Series 一维，带标签数组</p><p>2.DataFrame 二维，Series容器</p><h2 id="2-pandas之Series创建">2.pandas之Series创建</h2><p><img src="https://img-blog.csdnimg.cn/bb43d34acca640a49f6235918cdc9d91.png#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/234e646df7ca4617a62cb02967d66d7d.png#pic_center" alt="图片2"></p><h2 id="3-pandas之Series切片和索引">3.pandas之Series切片和索引</h2><p><img src="https://img-blog.csdnimg.cn/a317d112aac84680ba7668555d2d12a5.png#pic_center" alt="图片3"></p><h2 id="4-pandas之Series的索引和值">4.pandas之Series的索引和值</h2><p><img src="https://img-blog.csdnimg.cn/eb431cfe4c154698ad432933016f986d.png#pic_center" alt="图片4"></p><h2 id="5-pandas之读取外部数据">5.pandas之读取外部数据</h2><p>我们的这组数据存在csv中，我们直接使用pd. read_csv即可</p><p>和我们想象的有些差别，我们以为他会是一个Series类型，但是他是一个DataFrame，那么接下来我们就来了解这种数据类型</p><p><mark>小示例：</mark></p><p>现在假设我们有一个组关于狗的名字的统计数据，那么为了观察这组数据的情况，我们应该怎么做呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">df = pd.read_csv(&#x27;./dogNames2.csv&#x27;)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://img-blog.csdnimg.cn/68be90dd4ba5438998639c7eec18efe3.png#pic_center" alt="图片5"></p><h2 id="6-pandas之DataFrame">6.pandas之DataFrame</h2><p><img src="https://img-blog.csdnimg.cn/be5b901ba4fb47cea1bd2ec48f9ae57e.png#pic_center" alt="图片6"></p><p><strong>DataFrame对象既有行索引，又有列索引</strong></p><p>行索引，表明不同行，横向索引，叫index，0轴，axis=0</p><p>列索引，表名不同列，纵向索引，叫columns，1轴，axis=1</p><p><img src="https://img-blog.csdnimg.cn/9ca03dc5756543d0b8912fdf772ef66a.png#pic_center" alt="图片7"></p><p><img src="https://img-blog.csdnimg.cn/52b5430936d04a96b1506fe210c93b5b.png#pic_center" alt="图片8"></p><p>那么回到之前我们读取的狗名字统计的数据上，我们尝试一下刚刚的方法</p><p>那么问题来了：</p><p>很多同学肯定想知道使用次数最高的前几个名字是什么呢？</p><p><code>df.sort_values(by=&quot;Count_AnimalName&quot;,ascending=*False*)</code></p><p><mark>dataframe排序</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">df = pd.read_csv(&#x27;./dogNames2.csv&#x27;)</span><br><span class="line"># print(df)</span><br><span class="line"># print(&#x27;*&#x27;*100)</span><br><span class="line"># print(df.head())</span><br><span class="line"># print(&#x27;*&#x27;*100)</span><br><span class="line"># print(df.info())</span><br><span class="line"># print(&#x27;*&#x27;*100)</span><br><span class="line"># print(df.describe())</span><br><span class="line"></span><br><span class="line"># 以Count_AnimalName来排序（默认升序）</span><br><span class="line"># df = df.sort_values(by=&#x27;Count_AnimalName&#x27;)</span><br><span class="line"># ascending=True 为升序，False为倒序</span><br><span class="line">df = df.sort_values(by=&#x27;Count_AnimalName&#x27;,ascending=False)</span><br><span class="line">print(df.head(10))</span><br></pre></td></tr></table></figure><h2 id="7-pandas之取行或者列">7.pandas之取行或者列</h2><p>刚刚我们知道了如何给数据按照某一行或者列排序，那么现在我们想单独研究使用次数前100的数据，应该如何做？</p><p><code>df_sorted = df.sort_values(by=&quot;Count_AnimalName&quot;)</code></p><p><code>df_sorted[:100]</code></p><p>那么问题来了：</p><p>我们具体要选择某一列该怎么选择呢？<code>df[&quot; Count_AnimalName &quot;]</code></p><p>我们要同时选择行和列改怎么办？<code>df[:100][&quot; Count_AnimalName &quot;]</code></p><h2 id="8-pandas之loc">8.pandas之loc</h2><p>还有更多的经过pandas优化过的选择方式：</p><p>1.df.loc 通过<strong>标签</strong>索引行数据</p><p>2.df.iloc 通过<strong>位置</strong>获取行数据</p><p><img src="https://img-blog.csdnimg.cn/4b62f336e82e420dac4b8bd321307195.png#pic_center" alt="图片9"></p><p><img src="https://img-blog.csdnimg.cn/9110f21838ff4e9d8834322a3ae3730b.png#pic_center" alt="图片10"></p><h2 id="9-pandas之布尔索引">9.pandas之布尔索引</h2><p>回到之前狗的名字的问题上，假如我们想找到所有的使用次数超过800的狗的名字，应该怎么选择？</p><p><img src="https://img-blog.csdnimg.cn/41bbcc62c40c42ed9f26ec43fd426cf9.png#pic_center" alt="图片11"></p><p>回到之前狗的名字的问题上，假如我们想找到所有的使用次数超过700并且名字的字符串的长度大于4的狗的名字，应该怎么选择？</p><p><img src="https://img-blog.csdnimg.cn/e9560f381945448db72ee3e53ed7c2b6.png#pic_center" alt="图片12"></p><h2 id="10-pandas之字符串方法">10.pandas之字符串方法</h2><p><img src="https://img-blog.csdnimg.cn/4c472eb7157b44a19c24e1e0d4dd2670.png#pic_center" alt="图片13"></p><h2 id="11-缺失数据的处理">11.缺失数据的处理</h2><p>观察下面这组数据</p><p><img src="https://img-blog.csdnimg.cn/e5e6a7182e0c45a9ac32234186f9d287.png#pic_center" alt="图片14"></p><p>我们的数据缺失通常有两种情况：</p><p>一种就是空，None等，在pandas是NaN(和np.nan一样)另一种是我们让其为0，蓝色框中</p><p>对于NaN的数据，在numpy中我们是如何处理的？</p><p>在pandas中我们处理起来非常容易</p><p>判断数据是否为NaN：<code>pd.isnull(df),pd.notnull(df)</code></p><p>处理方式1：删除NaN所在的行列<code>dropna (axis=0, how='any', inplace=False)</code></p><p>处理方式2：填充数据，<code>t.fillna(t.mean()),t.fiallna(t.median()),t.fillna(0)</code></p><p>处理为0的数据：<code>t[t==0]=np.nan</code></p><p>当然并不是每次为0的数据都需要处理</p><p>计算平均值等情况，nan是不参与计算的，但是0会</p><p><mark>示例</mark></p><p>假设现在我们有一组从2006年到2016年1000部最流行的电影数据，我们想知道这些电影数据中评分的平均分，导演的人数等信息，我们应该怎么获取？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd, numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;IMDB-Movie-Data.csv&#x27;)</span><br><span class="line">print(type(df))</span><br><span class="line">print(df.info())</span><br><span class="line">print(df.head())</span><br><span class="line">print(df[&#x27;Rating&#x27;].values)</span><br><span class="line">print(df[&#x27;Rating&#x27;].describe())</span><br><span class="line"># df[&#x27;Rating&#x27;].mean()为numpy类型的数据，不能使用字符串拼接，需要先转换为字符串</span><br><span class="line"># 电影评分平均值</span><br><span class="line">print(&#x27;电影平均分：&#x27; + str(df[&#x27;Rating&#x27;].mean()))</span><br><span class="line"># 导演的人数</span><br><span class="line"># df[&#x27;Director&#x27;].tolist()  #  python tolist()方法:将数组或者矩阵转换成列表</span><br><span class="line"># set(df[&#x27;Director&#x27;].tolist()) # 使用set() 将数组去重并转换为set集合，集合是一个无序的不重复元素序列</span><br><span class="line">print(&#x27;导演人数：&#x27;, len(set(df[&#x27;Director&#x27;].tolist())))</span><br><span class="line"># 别一种方法：df[&#x27;Director&#x27;].unique()可以将df[&#x27;Director&#x27;]去重，并返回</span><br><span class="line">print(&#x27;导演人数：&#x27;, len(df[&#x27;Director&#x27;].unique()))</span><br><span class="line"># 由于每一部电影的演员有多人，所以先使用split(&#x27;,&#x27;)以逗号分隔，让每组数据的字符串重组为数组</span><br><span class="line">print(&#x27;所有演员二维数据：&#x27;)</span><br><span class="line">print(df[&#x27;Actors&#x27;].str.split(&#x27;,&#x27;).tolist())</span><br><span class="line">temp_list = df[&#x27;Actors&#x27;].str.split(&#x27;,&#x27;).tolist()</span><br><span class="line"># 将二维数组展开</span><br><span class="line">nums = [i for j in temp_list for i in j]</span><br><span class="line">print(&#x27;所有演员一维数组：&#x27;)</span><br><span class="line">print(nums)</span><br><span class="line"># 数组去重,并取总数</span><br><span class="line">actors = len(set(nums))  # 使用set集合的特点去重</span><br><span class="line">actors2 = len(pd.Series(nums).unique())  # 使用pandas的unique方法去重</span><br><span class="line">print(&#x27;去重后演员的总人数：&#x27;, actors, actors2)</span><br><span class="line"># 电影时长的最大最小值：</span><br><span class="line">max_runtime = df[&#x27;Runtime (Minutes)&#x27;].max()</span><br><span class="line">max_runtime_index = df[&#x27;Runtime (Minutes)&#x27;].argmax()</span><br><span class="line">min_runtime = df[&#x27;Runtime (Minutes)&#x27;].min()</span><br><span class="line">min_runtime_index = df[&#x27;Runtime (Minutes)&#x27;].argmin()</span><br><span class="line">runtime_median = df[&#x27;Runtime (Minutes)&#x27;].median()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7a158f5466e84d30bc4962abb4d77a75.png#pic_center" alt="图片15"></p><p><mark>示例</mark></p><p>对于这一组电影数据，如果我们希望统计电影分类(genre)的情况，应该如何处理数据？</p><p>思路：重新构造一个全为0的数组，列名为分类，如果某一条数据中分类出现过，就让0变为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;IMDB-Movie-Data.csv&#x27;)</span><br><span class="line">print(df[&#x27;Genre&#x27;])</span><br><span class="line">temp_list = df[&#x27;Genre&#x27;].str.split(&#x27;,&#x27;).tolist()</span><br><span class="line">print(temp_list)</span><br><span class="line"># 利用set展开二维列表并去重</span><br><span class="line">genre_list = list(set([i for j in temp_list for i in j]))</span><br><span class="line">print(genre_list)</span><br><span class="line"># 构造全为0的DataFrame:df一样的行数，分类总数的列数，索引为分类数据genre_list</span><br><span class="line"># np.zeros((a,b))里面传的是元组</span><br><span class="line">zeros_df = pd.DataFrame(np.zeros((df.shape[0], len(genre_list))), columns=genre_list)</span><br><span class="line">print(zeros_df)</span><br><span class="line">for i in range(df.shape[0]):</span><br><span class="line">    zeros_df.loc[i, temp_list[i]] = 1</span><br><span class="line"># 显示所有列</span><br><span class="line">pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># 显示所有列</span><br><span class="line"># pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># #显示所有行</span><br><span class="line"># pd.set_option(&#x27;display.max_rows&#x27;, None)</span><br><span class="line"># #设置value的显示长度为100，默认为50</span><br><span class="line"># pd.set_option(&#x27;max_colwidth&#x27;,100)</span><br><span class="line">print(zeros_df.head(1))</span><br><span class="line"># 统计每个分类的电影的数量和</span><br><span class="line">genre_count = zeros_df.sum(axis=0)</span><br><span class="line">print(genre_count)</span><br><span class="line"># 排序</span><br><span class="line">genre_count = genre_count.sort_values()</span><br><span class="line"># 画柱状图</span><br><span class="line">_x = genre_count.index</span><br><span class="line">_y = genre_count.values</span><br><span class="line">plt.figure(figsize=(20, 8), dpi=80)</span><br><span class="line">plt.bar(range(len(_x)), _y)</span><br><span class="line">plt.xticks(range(len(_x)), _x)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/378e9f5eeb7d4373940e2aa3f7131f91.png#pic_center" alt="图片16"></p><h2 id="12-数据合并之join">12.数据合并之join</h2><p>join:默认情况下他是把行索引相同的数据合并到一起</p><p><img src="https://img-blog.csdnimg.cn/a2b0d6d56c47431baf76ad4ab8f1c9fa.png#pic_center" alt="图片17"></p><h2 id="13-数据合并之merge">13.数据合并之merge</h2><p>merge:按照指定的列把数据按照一定的方式合并到一起</p><p><img src="https://img-blog.csdnimg.cn/1ba88efd40d944d3a995597ec1d810a4.png#pic_center" alt="图片18"></p><p><mark>示例：</mark></p><p>现在我们有一组关于全球星巴克店铺的统计数据，如果我想知道美国的星巴克数量和中国的哪个多，或者我想知道中国每个省份星巴克的数量的情况，那么应该怎么办？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;starbucks_store_worldwide.csv&#x27;)</span><br><span class="line"># print(df)</span><br><span class="line"># print(df.info())</span><br><span class="line"># df_country = df.groupby(&#x27;Country&#x27;)  # 生成一个DataFrameGroupBy object</span><br><span class="line"># print(df_country)</span><br><span class="line"># # 显示所有列</span><br><span class="line"># pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># # 遍历</span><br><span class="line"># # for i in df_country:</span><br><span class="line"># #     print(i) # 遍历后的每一个数据都是一个元组</span><br><span class="line">#</span><br><span class="line"># # 由于遍历后的每一个值都是元组，所以还可以这样遍历</span><br><span class="line"># for i, j in df_country:</span><br><span class="line">#     print(i, j, type(j))  # i为国家信息，j为一个DataFrame,其中所有的country字段均为i</span><br><span class="line">#     print(&#x27;*&#x27; * 100)</span><br><span class="line">#</span><br><span class="line"># # 调用聚合方法</span><br><span class="line"># print(df_country.count())  # count()可以统计每个字段的总数</span><br><span class="line"># print(df_country[&#x27;City&#x27;].count())  # 单独统计一个字段的总数</span><br><span class="line"># #</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">平均值，中位数等方法也可以使用，但这里使用没有意义，因为都是字符串</span><br><span class="line">count:分组中非NA值的数量</span><br><span class="line">sum:非NA的和</span><br><span class="line">mean:非NA值的平均值 </span><br><span class="line">median:非NA值的算术中位数</span><br><span class="line">std、var: 无偏（分母为n-a)标准差和方差</span><br><span class="line">min,max:非NA值的最小值和最大值 &quot;&quot;&quot;</span><br><span class="line"># country_count = df_country[&#x27;City&#x27;].count()</span><br><span class="line"># # 美国和中国的星巴克店铺数量</span><br><span class="line"># print(&#x27;美国：&#x27;, country_count[&#x27;US&#x27;])</span><br><span class="line"># print(&#x27;中国：&#x27;, country_count[&#x27;CN&#x27;])</span><br><span class="line"></span><br><span class="line"># 统计中国每个省份的星巴克</span><br><span class="line">china_data = df[df[&#x27;Country&#x27;] == &#x27;CN&#x27;]  # 取出中国的星巴克数据，这里可以不需要分组，直接取数据</span><br><span class="line"># print(china_data)</span><br><span class="line"># print(china_data.info())</span><br><span class="line"># province_data = china_data.groupby(&#x27;State/Province&#x27;).count()[&#x27;Brand&#x27;]</span><br><span class="line"># print(province_data)</span><br><span class="line"># groupby可以传入多个条件来分组</span><br><span class="line">print(df[&#x27;Brand&#x27;])</span><br><span class="line">china_data_group = df.groupby(</span><br><span class="line">    by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]]).count()  # 返回一个Series,列索引有两个，一个是country,一个是State/Province</span><br><span class="line">print(china_data_group)</span><br><span class="line">print(china_data_group[&#x27;Brand&#x27;])</span><br><span class="line"></span><br><span class="line"># 以下三种写法，结果相同</span><br><span class="line">group1 = df.groupby(by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]]).count()[&#x27;Brand&#x27;]</span><br><span class="line">group2 = df[&#x27;Brand&#x27;].groupby(by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]]).count()</span><br><span class="line">group3 = df.groupby(by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]])[&#x27;Brand&#x27;].count()</span><br><span class="line">print(group1, type(group1))</span><br><span class="line">print(&#x27;*&#x27; * 100)</span><br><span class="line">print(group2, type(group2))</span><br><span class="line">print(&#x27;*&#x27; * 100)</span><br><span class="line">print(group3, type(group3))</span><br><span class="line"># 取值可以为DataFrame,需要使用一个小技巧</span><br><span class="line">group4 = df[[&#x27;Brand&#x27;]].groupby(by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]]).count()</span><br><span class="line">print(&#x27;*&#x27; * 100)</span><br><span class="line">print(group4, type(group4))</span><br><span class="line">print(group1.index)</span><br></pre></td></tr></table></figure><h2 id="14-分组和聚合">14.分组和聚合</h2><p><code>grouped = df.groupby(by=&quot;columns_name&quot;)</code></p><p>grouped是一个DataFrameGroupBy对象，是可迭代的</p><p>grouped中的每一个元素是一个元组</p><p>元组里面是（索引(分组的值)，分组之后的DataFrame）</p><p>DataFrameGroupBy对象有很多经过优化的方法</p><p><img src="https://img-blog.csdnimg.cn/139e675a90e1446098f585c5279e346c.png#pic_center" alt="图片19"></p><p>如果我们需要对国家和省份进行分组统计，应该怎么操作呢？</p><p><code>grouped = df.groupby(by=[df[&quot;Country&quot;],df[&quot;State/Province&quot;]])</code></p><p>很多时候我们只希望对获取分组之后的某一部分数据，或者说我们只希望对某几列数据进行分组，这个时候我们应该怎么办呢？</p><p>获取分组之后的某一部分数据：</p><p><code>df.groupby(by=[&quot;Country&quot;,&quot;State/Province&quot;])[&quot;Country&quot;].count()</code></p><p>对某几列数据进行分组：</p><p><code>df[&quot;Country&quot;].groupby(by=[df[&quot;Country&quot;],df[&quot;State/Province&quot;]]).count()</code></p><p>观察结果，由于只选择了一列数据，所以结果是一个Series类型</p><p>如果我想返回一个DataFrame类型呢？</p><p><code>t1 = df[[&quot;Country&quot;]].groupby(by=[df[&quot;Country&quot;],df[&quot;State/Province&quot;]]).count()</code><br><code>t2 = df.groupby(by=[&quot;Country&quot;,&quot;State/Province&quot;])[[&quot;Country&quot;]].count()</code></p><p>以上的两条命令结果一样</p><p>和之前的结果的区别在于当前返回的是一个DataFrame类型</p><p>简单的索引操作：</p><p>•获取index：<code>df.index</code></p><p>•指定index ：<code>df.index = ['x','y']</code></p><p>•重新设置index : <code>df.reindex(list(&quot;abcedf&quot;))</code></p><p>•指定某一列作为index ：<code>df.set_index(&quot;Country&quot;,drop=False)</code></p><p>•返回index的唯一值：<code>df.set_index(&quot;Country&quot;).index.unique()</code></p><h2 id="15-Series复合索引">15.Series复合索引</h2><p><img src="https://img-blog.csdnimg.cn/65d81c0cc1934479aeb8cee008889f63.png#pic_center" alt="图片20"></p><p><img src="https://img-blog.csdnimg.cn/40eeea952b1340a594e96bb67792006c.png#pic_center" alt="图片21"></p><p><img src="https://img-blog.csdnimg.cn/89c065dd558b4334bddd49b9ddab9b90.png#pic_center" alt="图片22"></p><p><mark>示例</mark></p><p>现在我们有2015到2017年25万条911的紧急电话的数据，请统计出出这些数据中不同类型的紧急情况的次数，如果我们还想统计出不同月份不同类型紧急电话的次数的变化情况，应该怎么做呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd, numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;911.csv&#x27;)</span><br><span class="line"># 显示所有列</span><br><span class="line">pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># print(df.head())</span><br><span class="line"># print(df.info())</span><br><span class="line"># print(df[&#x27;title&#x27;].str.split(&#x27;:&#x27;))</span><br><span class="line"># print(df[&#x27;title&#x27;].str.split(&#x27;:&#x27;)[0]) # 不能取到数据</span><br><span class="line"># to_list()将序列转换为数组</span><br><span class="line">temp_list = df[&#x27;title&#x27;].str.split(&#x27;:&#x27;).to_list()</span><br><span class="line"># temp_list = df[&#x27;title&#x27;].str.split(&#x27;:&#x27;).tolist()</span><br><span class="line">print(temp_list)</span><br><span class="line"># 遍历并取出第一项数据并去重</span><br><span class="line">cate_list = list(set([i[0] for i in temp_list]))</span><br><span class="line">print(cate_list)</span><br><span class="line"># 构造一个DataFrame,三列，与df同行，数据全为0</span><br><span class="line">zeros_df = pd.DataFrame(np.zeros((df.shape[0], len(cate_list))), columns=cate_list)</span><br><span class="line">print(zeros_df)</span><br><span class="line"># 　由于df数据量太大，如果直接遍历，会消耗很长时间</span><br><span class="line"># for i in range(df.shape[0]):</span><br><span class="line">#     zeros_df.loc[i,temp_list[i][0]] = 1</span><br><span class="line">#</span><br><span class="line"># print(zeros_df)</span><br><span class="line"></span><br><span class="line"># 遍历cate_list,只需要循环三次</span><br><span class="line">for cate in cate_list:</span><br><span class="line">    # df[&#x27;title&#x27;].str.contains(cate)返回的是一个布尔型数组，行数与zeros_df相同，列数为三列，</span><br><span class="line">    # 包含cate的那一列为True,具体可见5.62布尔索引章节</span><br><span class="line">    zeros_df[cate][df[&#x27;title&#x27;].str.contains(cate)] = 1</span><br><span class="line"></span><br><span class="line"># print(zeros_df)</span><br><span class="line"></span><br><span class="line"># 统计邮寄类型的数量</span><br><span class="line">sum_ret = zeros_df.sum(axis=0)</span><br><span class="line">print(sum_ret)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd, numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;911.csv&#x27;)</span><br><span class="line"># #显示所有行</span><br><span class="line">pd.set_option(&#x27;display.max_rows&#x27;, None)</span><br><span class="line">print(df.head())</span><br><span class="line">print(df.info())</span><br><span class="line"></span><br><span class="line"># to_list()将序列转换为数组</span><br><span class="line">temp_list = df[&#x27;title&#x27;].str.split(&#x27;:&#x27;).to_list()</span><br><span class="line"></span><br><span class="line"># print(temp_list)</span><br><span class="line"># 遍历并取出第一项的分类</span><br><span class="line">cate_list = [i[0] for i in temp_list]</span><br><span class="line"># print(cate_list)</span><br><span class="line">cate_df = pd.DataFrame(np.array(cate_list).reshape((df.shape[0]), 1), columns=[&#x27;cate&#x27;])</span><br><span class="line">print(cate_df)</span><br><span class="line"># 添加一列，列索引为cate</span><br><span class="line">df[&#x27;cate&#x27;] = cate_df</span><br><span class="line"># print(df[&#x27;cate&#x27;])</span><br><span class="line">print(df.groupby(by=&#x27;cate&#x27;).count()[&#x27;title&#x27;])</span><br></pre></td></tr></table></figure><h2 id="16-pandas中的时间序列">16.pandas中的时间序列</h2><p><mark>生成一段时间范围</mark></p><p><code>pd.date_range(start=None, end=None, periods=None, freq='D')</code></p><p>start和end以及freq配合能够生成start和end范围内以频率freq的一组时间索引</p><p>start和periods以及freq配合能够生成从start开始的频率为freq的periods个时间索引</p><p><img src="https://img-blog.csdnimg.cn/94cf1dc007ba4c459281320984f69db1.png#pic_center" alt="图片23"></p><p><mark>关于频率的更多缩写</mark></p><p><img src="https://img-blog.csdnimg.cn/4615b163445f4fd8a3e88cdf7cfc452a.png#pic_center" alt="图片24"></p><p><mark>在DataFrame中使用时间序列</mark></p><p><code>index=pd.date_range(&quot;20170101&quot;,periods=10)</code></p><p><code>df = pd.DataFrame(np.random.rand(10),index=index)</code></p><p>回到最开始的911数据的案例中，我们可以使用pandas提供的方法把时间字符串转化为时间序列</p><p><code>df[&quot;timeStamp&quot;] = pd.to_datetime(df[&quot;timeStamp&quot;],format=&quot;&quot;)</code></p><p>format参数大部分情况下可以不用写，但是对于pandas无法格式化的时间字符串，我们可以使用该参数，比如包含中文</p><p>那么问题来了：</p><p>我们现在要统计每个月或者每个季度的次数怎么办呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">df = pd.read_csv(&#x27;911.csv&#x27;)</span><br><span class="line">#显示所有列</span><br><span class="line">pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># #显示所有行</span><br><span class="line">pd.set_option(&#x27;display.max_rows&#x27;, None)</span><br><span class="line">print(df.info())</span><br><span class="line">print(df.head())</span><br><span class="line"># 将时间字符串转换为时间类型数据datetime64，以便进一步处理</span><br><span class="line">print(pd.to_datetime(df[&#x27;timeStamp&#x27;]).head())</span><br><span class="line"># 重新赋值df[&#x27;timeStamp&#x27;]</span><br><span class="line">df[&#x27;timeStamp&#x27;] = pd.to_datetime(df[&#x27;timeStamp&#x27;])</span><br><span class="line"># 将列timeStamp转换为行索引</span><br><span class="line">df.set_index(&#x27;timeStamp&#x27;,inplace=True)</span><br><span class="line">print(df.head())</span><br><span class="line"></span><br><span class="line"># 统计出911数据中不同月份电话次数</span><br><span class="line">count_by_month = df.resample(&#x27;M&#x27;).count()[&#x27;title&#x27;]</span><br><span class="line">print(count_by_month)</span><br><span class="line"></span><br><span class="line">_x = count_by_month.index</span><br><span class="line">_y = count_by_month.values</span><br><span class="line">print(_x)</span><br><span class="line">print(_y)</span><br><span class="line">_x = [i.strftime(&#x27;%Y%m%d&#x27;) for i in _x]</span><br><span class="line">plt.figure(figsize=(20,8), dpi=80)</span><br><span class="line">plt.plot(_x,_y)</span><br><span class="line"># plt.plot(range(len(_x)),_y)</span><br><span class="line">plt.xticks(_x,rotation=45)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="17-pandas重采样">17.pandas重采样</h2><p><img src="https://img-blog.csdnimg.cn/b7551d9e0d7a43e09dd27e6fbc66121d.png#pic_center" alt="图片25"></p><p><mark>示例</mark></p><p>1.统计出911数据中不同月份电话次数的变化情况</p><p>2.统计出911数据中不同月份不同类型的电话的次数的变化情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import pandas as pd,numpy as np</span><br><span class="line">df = pd.read_csv(&#x27;911.csv&#x27;)</span><br><span class="line"># 重新赋值df[&#x27;timeStamp&#x27;]</span><br><span class="line">df[&#x27;timeStamp&#x27;] = pd.to_datetime(df[&#x27;timeStamp&#x27;])</span><br><span class="line">#添加列，表示分类</span><br><span class="line">temp_list = df[&quot;title&quot;].str.split(&quot;: &quot;).tolist()</span><br><span class="line">cate_list = [i[0] for i in temp_list]</span><br><span class="line"># 创建列</span><br><span class="line">df[&quot;cate&quot;] = pd.DataFrame(np.array(cate_list).reshape((df.shape[0],1)))</span><br><span class="line"># 将时间列转化为索引</span><br><span class="line">df.set_index(&quot;timeStamp&quot;,inplace=True)</span><br><span class="line">print(df.head(1))</span><br><span class="line">dk = df.groupby(&#x27;cate&#x27;)</span><br><span class="line">print(dk)</span><br><span class="line">plt.figure(figsize=(20, 8), dpi=80)</span><br><span class="line">for group_name,group_data in dk:</span><br><span class="line">    print(group_name,group_data)</span><br><span class="line">    # 对不同的分类都进行绘图</span><br><span class="line">    count_by_month = group_data.resample(&quot;M&quot;).count()[&quot;title&quot;]</span><br><span class="line">    # 画图</span><br><span class="line">    _x = count_by_month.index</span><br><span class="line">    print(_x)</span><br><span class="line">    _y = count_by_month.values</span><br><span class="line">    print(_y)</span><br><span class="line">    _x = [i.strftime(&quot;%Y%m%d&quot;) for i in _x]</span><br><span class="line"></span><br><span class="line">    plt.plot(range(len(_x)), _y, label=group_name)</span><br><span class="line"></span><br><span class="line">plt.xticks(range(len(_x)), _x, rotation=45)</span><br><span class="line">plt.legend(loc=&quot;best&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>现在我们有北上广、深圳、和沈阳5个城市空气质量数据，请绘制出5个城市的PM2.5随时间的变化情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">import pandas as pd</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">file_path = &quot;./PM2.5/BeijingPM20100101_20151231.csv&quot;</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(file_path)</span><br><span class="line">print(df.head())</span><br><span class="line">print(df.info())</span><br><span class="line"># 把分开的时间字符串通过periodIndex的方法转化为pandas的时间类型</span><br><span class="line">period = pd.PeriodIndex(year=df[&quot;year&quot;], month=df[&quot;month&quot;], day=df[&quot;day&quot;], hour=df[&quot;hour&quot;], freq=&quot;H&quot;)</span><br><span class="line"># 增加一列df[&quot;datetime&quot;]</span><br><span class="line">df[&quot;datetime&quot;] = period</span><br><span class="line">print(df.head(10))</span><br><span class="line">#</span><br><span class="line"># 把datetime 设置为索引</span><br><span class="line">df.set_index(&quot;datetime&quot;, inplace=True)</span><br><span class="line">#</span><br><span class="line"># 进行降采样,如果按日来排序，数据图不好看，按月份太稀疏，按日太绸</span><br><span class="line">df = df.resample(&quot;7D&quot;).mean()</span><br><span class="line">print(df.head())</span><br><span class="line"># 处理缺失数据，删除缺失数据</span><br><span class="line">print(df[&quot;PM_US Post&quot;])</span><br><span class="line"># dropna()该函数主要用于滤除缺失数据。</span><br><span class="line"># 如果是Series,则返回一个仅含非空数据和索引值的Series，默认丢弃含有缺失值的行。</span><br><span class="line"># 美国数据</span><br><span class="line">data = df[&quot;PM_US Post&quot;].dropna()  # 使用降采样后，会计算均值，这里再使用dropna()过滤空值意义不大</span><br><span class="line"># 中国数据</span><br><span class="line">data_china = df[&quot;PM_Nongzhanguan&quot;]</span><br><span class="line"></span><br><span class="line">print(data_china.head(100))</span><br><span class="line">#画图</span><br><span class="line"></span><br><span class="line">_x = data.index</span><br><span class="line">_x = [i.strftime(&quot;%Y%m%d&quot;) for i in _x]</span><br><span class="line"># 取中国PM2.5数据</span><br><span class="line">_x_china = [i.strftime(&quot;%Y%m%d&quot;) for i in data_china.index]</span><br><span class="line">print(len(_x_china),len(_x_china))</span><br><span class="line">_y = data.values</span><br><span class="line">_y_china = data_china.values</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(20,8),dpi=80)</span><br><span class="line"></span><br><span class="line">plt.plot(range(len(_x)),_y,label=&quot;US_POST&quot;,alpha=0.7)</span><br><span class="line">plt.plot(range(len(_x_china)),_y_china,label=&quot;CN_POST&quot;,alpha=0.7)</span><br><span class="line"></span><br><span class="line">plt.xticks(range(0,len(_x_china),10),list(_x_china)[::10],rotation=45)</span><br><span class="line"></span><br><span class="line">plt.legend(loc=&quot;best&quot;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1hx411d7jb?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=2896408aa1ddac57180818bd00dd</summary>
      
    
    
    
    <category term="Python" scheme="https://billysturate.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://billysturate.github.io/tags/Python/"/>
    
    <category term="pandas" scheme="https://billysturate.github.io/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>const修饰指针的三种情况详解</title>
    <link href="https://billysturate.github.io/posts/6fb97407.html"/>
    <id>https://billysturate.github.io/posts/6fb97407.html</id>
    <published>2022-08-04T10:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.165Z</updated>
    
    <content type="html"><![CDATA[<p>今天突然脑袋发热，对const修饰指针有点模糊，特此记录，方便复习<br>const修饰指针有三种情况</p><p>const修饰指针 — 常量指针<br>const修饰常量 — 指针常量<br>const即修饰指针，又修饰常量<br><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line">  p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">  <span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">  a = <span class="number">100</span>;    <span class="comment">//a的值还是能修改</span></span><br><span class="line">  cout &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">  <span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">  <span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">  *p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line">  <span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">  <span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天突然脑袋发热，对const修饰指针有点模糊，特此记录，方便复习&lt;br&gt;
const修饰指针有三种情况&lt;/p&gt;
&lt;p&gt;const修饰指针 — 常量指针&lt;br&gt;
const修饰常量 — 指针常量&lt;br&gt;
const即修饰指针，又修饰常量&lt;br&gt;
&lt;strong&gt;示例：&lt;/s</summary>
      
    
    
    
    <category term="C++" scheme="https://billysturate.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://billysturate.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>基于多信息融合的疲劳驾驶检测系统</title>
    <link href="https://billysturate.github.io/posts/feb32ed4.html"/>
    <id>https://billysturate.github.io/posts/feb32ed4.html</id>
    <published>2022-08-02T10:13:54.000Z</published>
    <updated>2023-01-28T15:45:43.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-眨眼检测原理">1.眨眼检测原理</h2><p>基于dlib人脸识别68特征点检测、分别获取左右眼面部标志的索引，通过opencv对视频流进行灰度化处理，检测出人眼的位置信息。人脸特征点检测用到了dlib，dlib有两个关键函数：dlib.get_frontal_face_detector()和dlib.shape_predictor(predictor_path)。</p><p>前者是内置的人脸检测算法，检测人脸区域的界限后者是用来检测一个区域内的特征点，并输出这些特征点的坐标，它需要一个预先训练好的模型（通过文件路径的方法传入），才能正常工作。使用开源模型shape_predictor_68_face_landmarks.dat，可以得到68个特征点位置的坐标</p><p><a href="https://pypi.org/simple/dlib/">点我下载开源数据集</a></p><p>基本原理：计算 眼睛长宽比EAR.当人眼在正常状态下时，EAR在某个值上下波动，当人眼闭合时，EAR迅速下降。所以我们认为当EAR低于某个阈值时，眼睛处于闭合状态。为检测眨眼次数，我们设置了阈值为0.2，如果当前帧两双眼睛宽高比的平均值小于0.2，则加1，如果连续3次都小于阈值，则表示进行了一次眨眼活动。</p><p><img src="https://img-blog.csdnimg.cn/20191211162451238.png" alt="在这里插入图片描述"></p><p>（68点landmark中可以看到37-42为左眼，43-48为右眼）</p><p><img src="https://img-blog.csdnimg.cn/20191210164401726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1bmd1ZGFmYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>右眼开合度可以通过以下公式得到（左眼同理）：</p><p><img src="https://img-blog.csdnimg.cn/2019121016443063.png#pic_center" alt="在这里插入图片描述"></p><p>通过计算38、39、42、41的纵坐标、37、40的横坐标来计算眼睛的睁开度。如：1/2*[(y42+y41)-(y38+y39)]/(x40-x37)通过一个阈值确定眼睛是睁开还是闭上。也可以将这个值与初始的值的比值作为睁开度，根据不同程度来进行比较。睁开度从大到小为进入闭眼期，从小到大为进入睁眼期，计算 最长闭眼时间（可用帧数来代替）闭眼次数为进入闭眼、进入睁眼的次数 。</p><p>主要代码思路</p><p>第一步：使用dlib.get_frontal_face_detector() 获得脸部位置检测器第二步：使用dlib.shape_predictor获得脸部特征位置检测器第三步：分别获取左右眼面部标志的索引第四步：打开cv2 本地摄像头第五步：从视频流进行循环，读取图片，并对图片做维度扩大，并进灰度化第六步：使用detector(gray, 0) 进行脸部位置检测第七步：循环脸部位置信息，使用predictor(gray, rect)获得脸部特征位置的信息第八步：将脸部特征信息转换为数组array的格式第九步：提取左眼和右眼坐标第十步：构造函数计算左右眼的EAR值，使用平均值作为最终的EAR<br>第十一步：使用cv2.convexHull获得凸包位置，使用drawContours画出轮廓位置进行画图操作第十二步：进行画图操作，用矩形框标注人脸第十三步：分别计算左眼和右眼的评分求平均作为最终的评分，如果小于阈值，则加1，如果连续3次都小于阈值，则表示进行了一次眨眼活动第十四步：进行画图操作，68个特征点标识第十五步：进行画图操作，同时使用cv2.putText将眨眼次数进行显示</p><h2 id="2-打哈欠检测原理">2.打哈欠检测原理</h2><p>嘴部主要取六个参考点：</p><p><img src="https://img-blog.csdnimg.cn/20191211181733274.png#pic_center" alt="在这里插入图片描述"></p><p>打哈欠可利用嘴巴处通过计算51、59、53、57、的纵坐标、49、55的横坐标来计算眼睛的睁开度。如：1/2*[(y51+y53)-(y59+y57)]/(x55-x49)点的距离来判断是否张嘴及张嘴时间，从而确定人是否是在打哈欠，同时这个阈值应当合理，能够与正常说话或哼歌区分开来。</p><p>同眼睛相类似方法求嘴部欧式距离：</p><p><img src="https://img-blog.csdnimg.cn/20191211162451238.png" alt="在这里插入图片描述"></p><p><mark>主要代码思路</mark></p><p>Step1:提取帧图像检测人脸，嘴部粗定位进行肤色分割；<br>Step2: 嘴部精确定位，获取嘴部欧式距离K1，若k1大于阈值T1，则Step3,并且count+1；否则count=0回到step1，检测下一帧。<br>Step3: 统计哈欠特征值count,当count超过阈值3,则记作打一次哈欠，保存count到Yawn，Yawn(i)=count，count=0（count清0）回到Step1，否则的话也直接转回Step1。</p><h2 id="3-瞌睡点头检测原理">3.瞌睡点头检测原理</h2><p>采用Head Pose Estimation(头部姿态估计) 算法,该算法的步骤一般为：2D人脸关键点检测；3D人脸模型匹配；求解3D点和对应2D点的转换关系；根据旋转矩阵求解欧拉角</p><p><a href="https://developer.aliyun.com/article/674048">https://developer.aliyun.com/article/674048</a></p><p><a href="https://blog.csdn.net/lql0716/article/details/72597719">https://blog.csdn.net/lql0716/article/details/72597719</a></p><p>具体原理请看上面那两篇博客，网上有开源代码(如下)，大神已经帮我们搞好了，我们拿来直接用就行，最后得到欧拉角</p><p><a href="https://developer.aliyun.com/article/674048">点我查看参考代码</a></p><p><mark>主要代码思路</mark></p><p>头部姿态判断打瞌睡得到实时头部姿态的旋转角度过后,如下所示为头部旋转角度的3个参数Yaw,Pitch和Roll的示意图,驾驶员在打瞌睡时，显然头部会做类似于点头和倾斜的动作.而根据一般人的打瞌睡时表现出来的头部姿态，显然很少会在Yaw上有动作，而主要集中在Pitch和Roll的行为.设定参数阈值为0.3,在一个时间段内10 s内，当I PitchI≥20°或者|Rolll≥20°的时间比例超过0.3时,就认为驾驶员处于点头打瞌睡的状态</p><p><img src="https://img-blog.csdnimg.cn/20191212141457194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1bmd1ZGFmYQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-多信息融合的疲劳判断">4.多信息融合的疲劳判断</h2><p>我们分别计算出单位时间内瞌睡点头的频率，眨眼频率以及打哈欠的频率分别赋予他们不同的权值，采用信息融合的方式进行综合打分，最后根据最终分数，设置疲劳等级，分别为轻度疲劳，中度疲劳和重度疲劳，相应的做出报警等操作</p><h2 id="5-效果展示">5.效果展示</h2><h3 id="5-1ui界面设计">5.1ui界面设计</h3><p>[<img src="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue%20driving%20detection%20system/images/123.png" alt="img">](<a href="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue">https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue</a> driving detection system/images/123.png)</p><h3 id="5-2效果演示">5.2效果演示</h3><p>[<img src="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue%20driving%20detection%20system/images/%E6%BC%94%E7%A4%BA%E7%94%BB%E9%9D%A2.png" alt="img">](<a href="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue">https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue</a> driving detection system/images/演示画面.png)</p><h3 id="5-3报表界面部分演示">5.3报表界面部分演示</h3><p>[<img src="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue%20driving%20detection%20system/images/%E6%89%87%E5%BD%A2%E5%9B%BE.png" alt="img">](<a href="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue">https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue</a> driving detection system/images/扇形图.png)</p><p>[<img src="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue%20driving%20detection%20system/images/%E6%8A%98%E7%BA%BF%E5%9B%BE.png" alt="img">](<a href="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue">https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue</a> driving detection system/images/折线图.png)</p><h2 id="6-项目进展">6.项目进展</h2><table><thead><tr><th><s><strong>眨眼检测</strong></s></th><th><strong>DONE</strong></th></tr></thead><tbody><tr><td><s><strong>打哈欠检测</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>瞌睡点头检测</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>实时眨眼频率计算</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>实时打哈欠频率</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>实时瞌睡点头频率</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>疲劳程度的计算</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>疲劳程度划分</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>UI界面设计</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>FPS计算以及语音播报</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>报表界面设计</strong></s></td><td><strong>DONE</strong></td></tr></tbody></table><h2 id="7-界面参数介绍">7.界面参数介绍</h2><table><thead><tr><th>Blinks</th><th>眨眼次数</th></tr></thead><tbody><tr><td><strong>Yawning</strong></td><td><strong>打哈欠次数</strong></td></tr><tr><td><strong>Nod</strong></td><td><strong>瞌睡点头次数</strong></td></tr><tr><td><strong>Blink Frequency</strong></td><td><strong>实时眨眼频率</strong></td></tr><tr><td><strong>Yawing Frequency</strong></td><td><strong>实时打哈欠频率</strong></td></tr><tr><td><strong>Nod Frequency</strong></td><td><strong>实时瞌睡点头频率</strong></td></tr><tr><td><strong>Score</strong></td><td><strong>疲劳程度</strong></td></tr><tr><td><strong>FPS</strong></td><td><strong>视频帧率</strong></td></tr></tbody></table><h2 id="8-文件介绍">8.文件介绍</h2><p>main.py-------------------------主程序</p><p>sats2.py--------------------------报表界面制作(pyecharts,感觉还是挺好用的，具体操作可以看官网文档，中国人开发的库值得推荐)</p><p><a href="https://gallery.pyecharts.org/#/Bar/stack_bar_percent">pyecharts gallery</a> <a href="https://pyecharts.org/#/zh-cn/intro">pyecharts操作手册</a></p><p>images目录下存放图片png以及ico</p><p>model目录下存放68人脸关键点模型</p><p>fatigue_detect.html-----------------可视化报表</p><h2 id="9-项目所有源代码获取">9.项目所有源代码获取</h2><p><a href="https://github.com/BillySturate/Fatigue-driving-detection-system-based-on-opencv-dlib">https://github.com/BillySturate/Fatigue-driving-detection-system-based-on-opencv-dlib</a></p><h2 id="10-参考博客">10.参考博客</h2><p><a href="https://blog.csdn.net/cungudafa/article/details/103477960">https://blog.csdn.net/cungudafa/article/details/103477960</a></p><p><a href="https://blog.csdn.net/cungudafa/article/details/103499230">https://blog.csdn.net/cungudafa/article/details/103499230</a></p><p><a href="https://blog.csdn.net/cungudafa/article/details/103496881">https://blog.csdn.net/cungudafa/article/details/103496881</a></p><p><a href="https://blog.csdn.net/lql0716/article/details/72597719">https://blog.csdn.net/lql0716/article/details/72597719</a></p><p><a href="https://developer.aliyun.com/article/674048">https://developer.aliyun.com/article/674048</a></p>]]></content>
    
    
    <summary type="html">基于多信息融合的疲劳驾驶检测系统</summary>
    
    
    
    <category term="人工智能" scheme="https://billysturate.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="Python" scheme="https://billysturate.github.io/tags/Python/"/>
    
    <category term="人工智能" scheme="https://billysturate.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="计算机视觉" scheme="https://billysturate.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="opencv" scheme="https://billysturate.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Numpy详解</title>
    <link href="https://billysturate.github.io/posts/ee5d2157.html"/>
    <id>https://billysturate.github.io/posts/ee5d2157.html</id>
    <published>2022-07-28T10:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.212Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1hx411d7jb?spm_id_from=333.337.search-card.all.click&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><h2 id="1-什么是numpy">1.什么是numpy</h2><p>一个在Python中做科学计算的基础库，重在数值计算，也是大部分PYTHON科学计算库的基础库，多用于在大型、多维数组上执行数值运算</p><p><mark>为什么学习numpy?</mark></p><p>1.快速</p><p>2.方便</p><p>3.科学计算的基础库</p><h2 id="2-numpy基础">2.numpy基础</h2><h3 id="2-1numpy创建数组-矩阵">2.1numpy创建数组(矩阵)</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acb56f6.png" alt="图片1.png"></p><h3 id="2-2numpy中常见的更多数据类型">2.2numpy中常见的更多数据类型</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acbefda.png" alt="图片2.png"></p><h3 id="2-3数据类型的操作">2.3数据类型的操作</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acc056e.png" alt="图片3.png"></p><p><mark>代码示例</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">import numpy as np</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">#使用numpy生成数组,得到ndarray的类型</span><br><span class="line">t1 = np.array([1,2,3,])</span><br><span class="line">print(t1)</span><br><span class="line">print(type(t1))</span><br><span class="line"></span><br><span class="line">t2 = np.array(range(10))</span><br><span class="line">print(t2)</span><br><span class="line">print(type(t2))</span><br><span class="line"></span><br><span class="line">t3 = np.arange(4,10,2)</span><br><span class="line">print(t3)</span><br><span class="line">print(type(t3))</span><br><span class="line"></span><br><span class="line">print(t3.dtype)</span><br><span class="line">print(&quot;*&quot;*100)</span><br><span class="line">#numpy中的数据类型</span><br><span class="line"></span><br><span class="line">t4 = np.array(range(1,4),dtype=&quot;i1&quot;)</span><br><span class="line">print(t4)</span><br><span class="line">print(t4.dtype)</span><br><span class="line"></span><br><span class="line">##numpy中的bool类型</span><br><span class="line">t5 = np.array([1,1,0,1,0,0],dtype=bool)</span><br><span class="line">print(t5)</span><br><span class="line">print(t5.dtype)</span><br><span class="line"></span><br><span class="line">#调整数据类型</span><br><span class="line">t6 = t5.astype(&quot;int8&quot;)</span><br><span class="line">print(t6)</span><br><span class="line">print(t6.dtype)</span><br><span class="line"></span><br><span class="line">#numpy中的小数</span><br><span class="line">t7 = np.array([random.random() for i in range(10)])</span><br><span class="line">print(t7)</span><br><span class="line">print(t7.dtype)</span><br><span class="line"></span><br><span class="line">t8 = np.round(t7,2)</span><br><span class="line">print(t8)</span><br></pre></td></tr></table></figure><h3 id="2-4数组的形状">2.4数组的形状</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acbdfef.png" alt="图片4.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013acc138e.png" alt="图片5.png"></p><h3 id="2-5数组和数的计算">2.5数组和数的计算</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acc50d8.png" alt="图片6.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013acc136b.png" alt="图片7.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013acc4f33.png" alt="图片8.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013acc5caa.png" alt="图片9.png"></p><h3 id="2-7广播原则">2.7广播原则</h3><p><img src="https://bu.dusays.com/2022/12/31/63b015961bd39.png" alt="图片10.png"></p><p>怎么理解呢?</p><p>可以把维度指的是shape所对应的数字个数</p><p>那么问题来了:</p><p>shape为(3,3,3)的数组能够和(3,2)的数组进行计算么?   <mark>不能</mark></p><p>shape为(3,3,2)的数组能够和(3,2)的数组进行计算么?<mark>能</mark></p><p>有什么好处呢?</p><p>举个例子:每列的数据减去列的平均值的结果</p><h3 id="2-8轴-axis">2.8轴(axis)</h3><p>在numpy中可以理解为方向,使用0,1,2…数字表示,对于一个一维数组,只有一个0轴,对于2维数组(shape(2,2)),有0轴和1轴,对于三维数组(shape(2,2, 3)),有0,1,2轴</p><p>有了轴的概念之后,我们计算会更加方便,比如计算一个2维数组的平均值,必须指定是计算哪个方向上面的数字的平均值</p><p>那么问题来了:</p><p>在前面的知识,轴在哪里?</p><p>回顾np.arange(0,10).reshape((2,5)),reshpe中2表示0轴长度(包含数据的条数)为2,1轴长度为5,2X5一共10个数据</p><p><mark>二维数组的轴</mark></p><p><img src="https://img-blog.csdnimg.cn/e9bbdf8a2c874bac9c160dfaf8e866c8.png#pic_center" alt=""></p><p><mark>三维数组的轴</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b013ada241e.png" alt="图片12.png"></p><h3 id="2-9numpy读取数据">2.9numpy读取数据</h3><p>CSV:Comma-Separated Value,逗号分隔值文件</p><p>显示：表格状态</p><p>源文件：换行和逗号分隔行列的格式化文本,每一行的数据表示一条记录</p><p>由于csv便于展示,读取和写入,所以很多地方也是用csv的格式存储和传输中小型的数据,为了方便教学,我们会经常操作csv格式的文件,但是操作数据库中的数据也是很容易的实现的</p><p><code>np.loadtxt(fname,dtype=np.float,delimiter=None,skiprows=0,usecols=None,unpack=False)</code></p><p><img src="https://bu.dusays.com/2022/12/31/63b013adc062d.png" alt="图片13.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013adf27fc.png" alt="图片14.png"></p><h3 id="2-10numpy中的转置">2.10numpy中的转置</h3><p>转置是一种变换,对于numpy中的数组来说,就是在对角线方向交换数据,目的也是为了更方便的去处理数据</p><p><img src="https://bu.dusays.com/2022/12/31/63b013ae1a505.png" alt="图片15.png"></p><p>以上的三种方法都可以实现二维数组的转置的效果,大家能够看出来,转置和交换轴的效果一样</p><p><mark>示例</mark></p><p>现在这里有一个英国和美国各自youtube1000多个视频的点击,喜欢,不喜欢,评论数量([“views”,“likes”,“dislikes”,“comment_total”])的csv,运用刚刚所学习的只是,我们尝试来对其进行操作，那么,结合之前的所学的matplotlib把英国和美国的数据呈现出来?</p><p>看到这个问题,我们应该考虑什么?</p><p>1.我们想要反映出什么样的结果,解决什么问题?</p><p>2.选择什么样的呈现方式?</p><p>3.数据还需要做什么样的处理?</p><p>4.写代码</p><h3 id="2-11numpy索引和切片">2.11numpy索引和切片</h3><p>对于刚刚加载出来的数据,我如果只想选择其中的某一列(行)我们应该怎么做呢?</p><p>其实操作很简单,和python中列表的操作一样</p><p><img src="https://bu.dusays.com/2022/12/31/63b013ae34081.png" alt="图片16.png"></p><p><mark>代码示例</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">us_file_path = &quot;./youtube_video_data/US_video_data_numbers.csv&quot;</span><br><span class="line">uk_file_path = &quot;./youtube_video_data/GB_video_data_numbers.csv&quot;</span><br><span class="line"></span><br><span class="line"># t1 = np.loadtxt(us_file_path,delimiter=&quot;,&quot;,dtype=&quot;int&quot;,unpack=True)</span><br><span class="line">t2 = np.loadtxt(us_file_path,delimiter=&quot;,&quot;,dtype=&quot;int&quot;)</span><br><span class="line"></span><br><span class="line"># print(t1)</span><br><span class="line">print(t2)</span><br><span class="line"></span><br><span class="line">print(&quot;*&quot;*100)</span><br><span class="line"></span><br><span class="line">#取行</span><br><span class="line"># print(t2[2])</span><br><span class="line"></span><br><span class="line">#取连续的多行</span><br><span class="line"># print(t2[2:])</span><br><span class="line"></span><br><span class="line">#取不连续的多行</span><br><span class="line"># print(t2[[2,8,10]])</span><br><span class="line"></span><br><span class="line"># print(t2[1,:])</span><br><span class="line"># print(t2[2:,:])</span><br><span class="line"># print(t2[[2,10,3],:])</span><br><span class="line"></span><br><span class="line">#取列</span><br><span class="line"># print(t2[:,0])</span><br><span class="line"></span><br><span class="line">#取连续的多列</span><br><span class="line"># print(t2[:,2:])</span><br><span class="line"></span><br><span class="line">#取不连续的多列</span><br><span class="line"># print(t2[:,[0,2]])</span><br><span class="line"></span><br><span class="line">#去行和列，取第3行，第四列的值</span><br><span class="line"># a = t2[2,3]</span><br><span class="line"># print(a)</span><br><span class="line"># print(type(a))</span><br><span class="line"></span><br><span class="line">#取多行和多列，取第3行到第五行，第2列到第4列的结果</span><br><span class="line">#去的是行和列交叉点的位置</span><br><span class="line">b = t2[2:5,1:4]</span><br><span class="line"># print(b)</span><br><span class="line"></span><br><span class="line">#取多个不相邻的点</span><br><span class="line">#选出来的结果是（0，0） （2，1） （2，3）</span><br><span class="line">c = t2[[0,2,2],[0,1,3]]</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h3 id="2-12numpy中数值的修改">2.12numpy中数值的修改</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013ae5a6c8.png" alt="图片17.png"></p><h3 id="2-13numpy中布尔索引">2.13numpy中布尔索引</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013ae866a9.png" alt="图片18.png"></p><h3 id="2-14numpy中三元运算符">2.14numpy中三元运算符</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013aea983a.png" alt="图片19.png"></p><h3 id="2-15numpy中的clip-裁剪">2.15numpy中的clip(裁剪)</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013aec2565.png" alt="图片20.png"></p><p>观察上方的操作：</p><p>小于10的替换为10，大于18的替换为了18，nan不会被替换</p><h3 id="2-16numpy中的nan和inf">2.16numpy中的nan和inf</h3><p>nan(NAN,Nan):not a number表示不是一个数字</p><p>什么时候numpy中会出现nan：</p><p>当我们读取本地的文件为float的时候，如果有缺失，就会出现nan</p><p>当做了一个不合适的计算的时候(比如无穷大(inf)减去无穷大)</p><p>inf(-inf,inf):infinity,inf表示正无穷，-inf表示负无穷</p><p>什么时候回出现inf包括（-inf，+inf）</p><p>比如一个数字除以0，（python中直接会报错，numpy中是一个inf或者-inf）</p><p><img src="https://bu.dusays.com/2022/12/31/63b013aee5dab.png" alt="图片21.png"></p><p><mark>numpy中的nan的注意点</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b013af24d7d.png" alt="图片22.png"></p><p>那么问题来了，在一组数据中单纯的把nan替换为0，合适么？会带来什么样的影响？</p><p>比如，全部替换为0后，替换之前的平均值如果大于0，替换之后的均值肯定会变小，所以更一般的方式是把缺失的数值替换为均值（中值）或者是直接删除有缺失值的一行</p><h3 id="2-17numpy中常用统计函数">2.17numpy中常用统计函数</h3><p>求和：t.sum(axis=None)</p><p>均值：t.mean(a,axis=None) 受离群点的影响较大</p><p>中值：np.median(t,axis=None)</p><p>最大值：t.max(axis=None)</p><p>最小值：t.min(axis=None)</p><p>极值：np.ptp(t,axis=None) 即最大值和最小值只差</p><p>标准差：t.std(axis=None)</p><p>默认返回多维数组的全部的统计结果,如果指定axis则返回一个当前轴上的结果</p><h3 id="2-18-一个小案例">2.18 一个小案例</h3><p>t中存在nan值，如何操作把其中的nan填充为每一列的均值</p><p>t = array([[ 0.,  1.,  2.,  3.,  4.,  5.],</p><p>​    [ 6.,  7., nan,  9., 10., 11.],</p><p>​    [ 12., 13., 14., nan, 16., 17.],</p><p>​    [ 18., 19., 20., 21., 22., 23.]])</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">def Fill_Ndarry(r1):</span><br><span class="line">    for i in range(r1.shape[1]):</span><br><span class="line">        temp_col = r1[:, i]</span><br><span class="line">        nan_num = np.count_nonzero(temp_col != temp_col)</span><br><span class="line">        if nan_num != 0:</span><br><span class="line">            temp_not_nan = temp_col[temp_col == temp_col]</span><br><span class="line">            # print(temp_not_nan)</span><br><span class="line">            temp_col[np.isnan(temp_col)] = temp_not_nan.mean()</span><br><span class="line">            # print(temp_col[np.isnan(temp_col)])</span><br><span class="line">    return r1</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    t1 = np.arange(24).reshape((4, 6)).astype(&quot;float&quot;)</span><br><span class="line">    t1[1, 2:] = np.nan</span><br><span class="line">    print(t1)</span><br><span class="line">    t1 = Fill_Ndarry(t1)</span><br><span class="line">    print(t1)</span><br></pre></td></tr></table></figure><h3 id="2-19数组的拼接及行列交换">2.19数组的拼接及行列交换</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013af34138.png" alt="图片23.png"></p><p><mark>数组的行列交换</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b013af52fd3.png" alt="图片24.png"></p><p><mark>numpy更多好用的方法</mark></p><p>1.获取最大值最小值的位置</p><p>​ np.argmax(t,axis=0)</p><p>​ np.argmin(t,axis=1)</p><p>2.创建一个全0的数组: np.zeros((3,4))</p><p>3.创建一个全1的数组:np.ones((3,4))</p><p>4.创建一个对角线为1的正方形数组(方阵)：np.eye(3)</p><h3 id="2-20numpy生成随机数">2.20numpy生成随机数</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013af8130a.png" alt="图片25.png"></p><p><mark>分布的补充</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b013afbdc30.png" alt="图片26.png"></p><h3 id="2-21numpy的注意点copy和view">2.21numpy的注意点copy和view</h3><p>1.a=b 完全不复制，a和b相互影响</p><p>2.a = b[:],视图的操作，一种切片，会创建新的对象a，但是a的数据完全由b保管，他们两个的数据变化是一致的，</p><p>3.a = b.copy(),复制，a和b互不影响</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1hx411d7jb?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=2896408aa1ddac57180818bd00dd</summary>
      
    
    
    
    <category term="Python" scheme="https://billysturate.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://billysturate.github.io/tags/Python/"/>
    
    <category term="Numpy" scheme="https://billysturate.github.io/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib详解</title>
    <link href="https://billysturate.github.io/posts/68795d4b.html"/>
    <id>https://billysturate.github.io/posts/68795d4b.html</id>
    <published>2022-07-25T10:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.207Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1hx411d7jb?spm_id_from=333.337.search-card.all.click&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><h2 id="1-什么是matplotlib">1.什么是matplotlib</h2><p>matplotlib: 最流行的Python底层绘图库，主要做数据可视化图表,名字取材于MATLAB，模仿MATLAB构建</p><h2 id="2-样例">2.样例</h2><h3 id="2-1折线图">2.1折线图</h3><p>eg：假设一天中每隔两个小时(range(2,26,2))的气温(℃)分别是[15,13,14.5,17,20,25,26,26,27,22,18,15]</p><p><mark>matplotlib基本要点</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bc4084.png" alt="图片1.png"></p><p><mark>设置图片大小</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bca508.png" alt="图片2.png"></p><p><mark>调整X或者Y轴上的刻度</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bca5a2.png" alt="图片3.png"></p><p>那么问题来了:</p><p>​    如果列表a表示10点到12点的每一分钟的气温,如何绘制折线图观察每分钟气温的变化情况?</p><p>​    <code>a= [random.randint(20,35) for i in range(120)]</code></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd4ea9.png" alt="图片4.png"></p><p><mark>设置中文显示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd9667.png" alt="图片5.png"></p><p><mark>给图像添加描述信息</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd3f81.png" alt="图片6.png"></p><p><mark>最终代码展示</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager</span><br><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&quot;C:/Windows/Fonts/SimHei.ttf&quot;</span>, size=<span class="number">14</span>)</span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">120</span>)</span><br><span class="line">y = [random.randint(<span class="number">20</span>, <span class="number">35</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">120</span>)]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>), dpi=<span class="number">80</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">_x = x[::<span class="number">5</span>]</span><br><span class="line">_xtick_labels = [<span class="string">&quot;10点&#123;&#125;分&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>)]</span><br><span class="line">_xtick_labels += [<span class="string">&quot;11点&#123;&#125;分&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>)]</span><br><span class="line">plt.xticks(_x, _xtick_labels[::<span class="number">5</span>], rotation=<span class="number">45</span>, fontproperties=my_font)  <span class="comment"># rotation旋转的度数</span></span><br><span class="line"><span class="comment"># 添加描述信息</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;时间&quot;</span>, fontproperties=my_font)</span><br><span class="line">plt.ylabel(<span class="string">&quot;温度 单位(℃)&quot;</span>, fontproperties=my_font)</span><br><span class="line">plt.title(<span class="string">&quot;10点到12点每分钟的气温变化情况&quot;</span>, fontproperties=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>最终效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bddb36.png" alt="图片7.png"></p><p><mark>动手一练</mark></p><p>假设大家在30岁的时候,根据自己的实际情况,统计出来了你和你同桌各自从11岁到30岁每年交的女(男)朋友的数量如列表a和b,请在一个图中绘制出该数据的折线图,以便比较自己和同桌20年间的差异,同时分析每年交女(男)朋友的数量走势</p><p>a = [1,0,1,1,2,4,3,2,3,4,4,5,6,5,4,3,3,1,1,1]</p><p>b = [1,0,3,1,2,2,3,3,2,1 ,2,1,1,1,1,1,1,1,1,1]</p><p>要求:</p><p>y轴表示个数</p><p>x轴表示岁数,比如11岁,12岁等</p><p><mark>代码展示</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&quot;C:/Windows/Fonts/SimHei.ttf&quot;</span>, size=<span class="number">14</span>)</span><br><span class="line">y1 = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">y2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">11</span>, <span class="number">31</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>), dpi=<span class="number">80</span>)</span><br><span class="line">plt.plot(x, y1, label=<span class="string">&quot;自己&quot;</span>)</span><br><span class="line">plt.plot(x, y2, label=<span class="string">&quot;同桌&quot;</span>)</span><br><span class="line">_xtick = [<span class="string">&quot;&#123;&#125;岁&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">plt.xticks(x, _xtick, rotation=<span class="number">45</span>, fontproperties=my_font)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制网格</span></span><br><span class="line">plt.grid(alpha=<span class="number">0.4</span>)</span><br><span class="line">plt.legend(prop=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>在上一个案例中如果大家希望自定义绘制图形的风格怎么办?</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd369f.png" alt="图片8.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd7729.png" alt="图片9.png"></p><p><mark>虽然线条有了不一样的风格,但是读者还是不知道那条线是谁怎么办?</mark></p><p><strong>为每条线添加图例</strong></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bdbff9.png" alt="图片10.png"></p><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120c91049.png" alt="图片11.png"></p><p><mark>总结:前面我们都做了什么</mark>？</p><p>1.绘制了折线图(plt.plot)</p><p>2.设置了图片的大小和分辨率(plt.figure)</p><p>3.实现了图片的保存(plt.savefig)</p><p>4.设置了xy轴上的刻度和字符串(xticks)</p><p>5.解决了刻度稀疏和密集的问题(xticks)</p><p>6.设置了标题,xy轴的lable(title,xlable,ylable)</p><p>7.设置了字体(font_manager. fontProperties,matplotlib.rc)</p><p>8.在一个图上绘制多个图形(plt多次plot即可)</p><p>9.为不同的图形添加图例</p><p>以上统统很重要</p><h3 id="2-2散点图">2.2散点图</h3><p>eg:假设通过爬虫你获取到了北京2016年3,10月份每天白天的最高气温(分别位于列表a,b),那么此时如何寻找出气温和随时间(天)变化的某种规律?</p><p>a = [11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23]</p><p>b = [26,26,28,19,21,17,16,19,18,20,20,19,22,23,17,20,21,20,22,15,11,15,5,13,17,10,11,13,12,13,6]</p><p><mark>代码展示</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=&quot;C:/Windows/Fonts/SimHei.ttf&quot;, size=14)</span><br><span class="line">y_3 = [11, 17, 16, 11, 12, 11, 12, 6, 6, 7, 8, 9, 12, 15, 14, 17, 18, 21, 16, 17, 20, 14, 15, 15, 15, 19, 21, 22, 22,</span><br><span class="line">       22, 23]</span><br><span class="line">y_10 = [26, 26, 28, 19, 21, 17, 16, 19, 18, 20, 20, 19, 22, 23, 17, 20, 21, 20, 22, 15, 11, 15, 5, 13, 17, 10, 11, 13,</span><br><span class="line">        12, 13, 6]</span><br><span class="line">x_3 = range(1, 32)</span><br><span class="line">x_10 = range(41, 72)</span><br><span class="line">x = list(x_3) + list(x_10)</span><br><span class="line">plt.figure(figsize=(20, 10), dpi=80)</span><br><span class="line">plt.scatter(x_3, y_3, label=&quot;3月&quot;)</span><br><span class="line">plt.scatter(x_10, y_10, label=&quot;10月&quot;)</span><br><span class="line">_xtick = [&quot;3月&#123;&#125;日&quot;.format(i) for i in x_3]</span><br><span class="line">_xtick += [&quot;10月&#123;&#125;日&quot;.format(i) for i in x_3]</span><br><span class="line">plt.xticks(x[::3], _xtick[::3], rotation=45, fontproperties=my_font)</span><br><span class="line">plt.xlabel(&quot;时间&quot;, fontproperties=my_font)</span><br><span class="line">plt.ylabel(&quot;温度&quot;, fontproperties=my_font)</span><br><span class="line">plt.title(&quot;标题&quot;, fontproperties=my_font)</span><br><span class="line">plt.legend(loc=&quot;upper left&quot;, prop=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120cabc50.png" alt="图片12.png"></p><h3 id="2-3条形图">2.3条形图</h3><p>eg:假设你获取到了2017年内地电影票房前20的电影(列表a)和电影票房数据(列表b),那么如何更加直观的展示该数据?</p><p>a = [“战狼2”,“速度与激情8”,“功夫瑜伽”,“西游伏妖篇”,“变形金刚5：最后的骑士”,“摔跤吧！爸爸”,“加勒比海盗5：死无对证”,“金刚：骷髅岛”,“极限特工：终极回归”,“生化危机6：终章”,“乘风破浪”,“神偷奶爸3”,“智取威虎山”,“大闹天竺”,“金刚狼3：殊死一战”,“蜘蛛侠：英雄归来”,“悟空传”,“银河护卫队2”,“情圣”,“新木乃伊”,]</p><p>b=[56.01,26.94,17.53,16.49,15.45,12.96,11.8,11.61,11.28,11.12,10.49,10.3,8.75,7.55,7.32,6.99,6.88,6.86,6.58,6.23] 单位:亿</p><p><img src="https://bu.dusays.com/2022/12/31/63b0120cc2aa6.png" alt="图片13.png"></p><p><mark>完整代码展示</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=&quot;C:/Windows/Fonts/SimHei.ttf&quot;, size=14)</span><br><span class="line">a = [&quot;战狼2&quot;, &quot;速度与激情8&quot;, &quot;功夫瑜伽&quot;, &quot;西游伏妖篇&quot;, &quot;变形金刚5：最后的骑士&quot;, &quot;摔跤吧！爸爸&quot;, &quot;加勒比海盗5：死无对证&quot;, &quot;金刚：骷髅岛&quot;, &quot;极限特工：终极回归&quot;, &quot;生化危机6：终章&quot;,</span><br><span class="line">     &quot;乘风破浪&quot;, &quot;神偷奶爸3&quot;, &quot;智取威虎山&quot;, &quot;大闹天竺&quot;, &quot;金刚狼3：殊死一战&quot;, &quot;蜘蛛侠：英雄归来&quot;, &quot;悟空传&quot;, &quot;银河护卫队2&quot;, &quot;情圣&quot;, &quot;新木乃伊&quot;, ]</span><br><span class="line"></span><br><span class="line">b = [56.01, 26.94, 17.53, 16.49, 15.45, 12.96, 11.8, 11.61, 11.28, 11.12, 10.49, 10.3, 8.75, 7.55, 7.32, 6.99, 6.88,</span><br><span class="line">     6.86, 6.58, 6.23]</span><br><span class="line">plt.figure(figsize=(20, 15), dpi=80)</span><br><span class="line">plt.bar(range(len(a)), b, width=0.3)</span><br><span class="line">plt.xticks(range(len(a)), a, rotation=90, fontproperties=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120cea641.png" alt="图片14.png"></p><p><mark>动手一练</mark></p><p>假设你知道了列表a中电影分别在2017-09-14(b_14), 2017-09-15(b_15), 2017-09-16(b_16)三天的票房,为了展示列表中电影本身的票房以及同其他电影的数据对比情况,应该如何更加直观的呈现该数据?</p><p>a = [“猩球崛起3：终极之战”,“敦刻尔克”,“蜘蛛侠：英雄归来”,“战狼2”]</p><p>b_16 = [15746,312,4497,319]</p><p>b_15 = [12357,156,2045,168]</p><p>b_14 = [2358,399,2358,362]</p><p><mark>代码展示</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=&quot;C:/Windows/Fonts/SimHei.ttf&quot;, size=14)</span><br><span class="line">a = [&quot;猩球崛起3：终极之战&quot;, &quot;敦刻尔克&quot;, &quot;蜘蛛侠：英雄归来&quot;, &quot;战狼2&quot;]</span><br><span class="line">b_16 = [15746, 312, 4497, 319]</span><br><span class="line">b_15 = [12357, 156, 2045, 168]</span><br><span class="line">b_14 = [2358, 399, 2358, 362]</span><br><span class="line">bar_width = 0.2</span><br><span class="line">x_14 = list(range(len(a)))</span><br><span class="line">x_15 = [i + bar_width for i in x_14]</span><br><span class="line">x_16 = [i + bar_width * 2 for i in x_14]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(20, 10), dpi=80)</span><br><span class="line">plt.bar(range(len(a)), b_14, width=bar_width, label=&quot;9月14日&quot;)</span><br><span class="line">plt.bar(x_15, b_15, width=bar_width, label=&quot;9月15日&quot;)</span><br><span class="line">plt.bar(x_16, b_16, width=bar_width, label=&quot;9月15日&quot;)</span><br><span class="line">plt.legend(prop=my_font)</span><br><span class="line">plt.xticks(x_15, a, fontproperties=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120d17a0a.png" alt="图片15.png"></p><h3 id="2-4直方图">2.4直方图</h3><p>eg:假设你获取了250部电影的时长(列表a中),希望统计出这些电影时长的分布状态(比如时长为100分钟到120分钟电影的数量,出现的频率)等信息,你应该如何呈现这些数据?</p><p>a=[131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, 142, 127, 130, 124, 101, 110, 116, 117, 110, 128, 128, 115, 99, 136, 126, 134, 95, 138, 117, 111,78, 132, 124, 113, 150, 110, 117, 86, 95, 144, 105, 126, 130,126, 130, 126, 116, 123, 106, 112, 138, 123, 86, 101, 99, 136,123, 117, 119, 105, 137, 123, 128, 125, 104, 109, 134, 125, 127,105, 120, 107, 129, 116, 108, 132, 103, 136, 118, 102, 120, 114,105, 115, 132, 145, 119, 121, 112, 139, 125, 138, 109, 132, 134,156, 106, 117, 127, 144, 139, 139, 119, 140, 83, 110, 102,123,107, 143, 115, 136, 118, 139, 123, 112, 118, 125, 109, 119, 133,112, 114, 122, 109, 106, 123, 116, 131, 127, 115, 118, 112, 135,115, 146, 137, 116, 103, 144, 83, 123, 111, 110, 111, 100, 154,136, 100, 118, 119, 133, 134, 106, 129, 126, 110, 111, 109, 141,120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126,114, 140, 103, 130, 141, 117, 106, 114, 121, 114, 133, 137, 92,121, 112, 146, 97, 137, 105, 98, 117, 112, 81, 97, 139, 113,134, 106, 144, 110, 137, 137, 111, 104, 117, 100, 111, 101, 110,105, 129, 137, 112, 120, 113, 133, 112, 83, 94, 146, 133, 101,131, 116, 111, 84, 137, 115, 122, 106, 144, 109, 123, 116, 111,111, 133, 150]</p><p><img src="https://bu.dusays.com/2022/12/31/63b0120d4a7c7.png" alt="图片16.png"></p><p><mark>代码展示</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=&quot;C:/Windows/Fonts/SimHei.ttf&quot;, size=14)</span><br><span class="line">a = [131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, 142, 127, 130, 124,</span><br><span class="line">     101, 110, 116, 117, 110, 128, 128, 115, 99, 136, 126, 134, 95, 138, 117, 111, 78, 132, 124, 113, 150, 110, 117, 86,</span><br><span class="line">     95, 144, 105, 126, 130, 126, 130, 126, 116, 123, 106, 112, 138, 123, 86, 101, 99, 136, 123, 117, 119, 105, 137,</span><br><span class="line">     123, 128, 125, 104, 109, 134, 125, 127, 105, 120, 107, 129, 116, 108, 132, 103, 136, 118, 102, 120, 114, 105, 115,</span><br><span class="line">     132, 145, 119, 121, 112, 139, 125, 138, 109, 132, 134, 156, 106, 117, 127, 144, 139, 139, 119, 140, 83, 110, 102,</span><br><span class="line">     123, 107, 143, 115, 136, 118, 139, 123, 112, 118, 125, 109, 119, 133, 112, 114, 122, 109, 106, 123, 116, 131, 127,</span><br><span class="line">     115, 118, 112, 135, 115, 146, 137, 116, 103, 144, 83, 123, 111, 110, 111, 100, 154, 136, 100, 118, 119, 133, 134,</span><br><span class="line">     106, 129, 126, 110, 111, 109, 141, 120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126, 114, 140, 103,</span><br><span class="line">     130, 141, 117, 106, 114, 121, 114, 133, 137, 92, 121, 112, 146, 97, 137, 105, 98, 117, 112, 81, 97, 139, 113, 134,</span><br><span class="line">     106, 144, 110, 137, 137, 111, 104, 117, 100, 111, 101, 110, 105, 129, 137, 112, 120, 113, 133, 112, 83, 94, 146,</span><br><span class="line">     133, 101, 131, 116, 111, 84, 137, 115, 122, 106, 144, 109, 123, 116, 111, 111, 133, 150]</span><br><span class="line"># 计算组数</span><br><span class="line">d = 3</span><br><span class="line">num_bins = (max(a) - min(a)) // d</span><br><span class="line">plt.figure(figsize=(20, 15), dpi=80)</span><br><span class="line">plt.hist(a, num_bins, density=True)</span><br><span class="line">plt.xticks(range(min(a), max(a) + d, d))</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120d5db0c.png" alt="图片17.png"></p><p><mark>matplotlib常见问题总结</mark></p><p>1.应该选择那种图形来呈现数据</p><p>2.matplotlib.plot(x,y)</p><p>3.matplotlib.bar(x,y)</p><p>4.matplotlib.scatter(x,y)</p><p>5.matplotlib.hist(data,bins,normed)</p><p>6.xticks和yticks的设置</p><p>7.label和titile,grid的设置</p><p>8.绘图的大小和保存图片</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1hx411d7jb?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=2896408aa1ddac57180818bd00dd</summary>
      
    
    
    
    <category term="Python" scheme="https://billysturate.github.io/categories/Python/"/>
    
    
    <category term="Matplotlib" scheme="https://billysturate.github.io/tags/Matplotlib/"/>
    
    <category term="Python" scheme="https://billysturate.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Qt5.15.2中编译报错：“invalid use of incomplete type &#39;class Ui::xxx&#39;”的解决方法</title>
    <link href="https://billysturate.github.io/posts/c53a16ca.html"/>
    <id>https://billysturate.github.io/posts/c53a16ca.html</id>
    <published>2022-07-17T10:13:54.000Z</published>
    <updated>2023-01-28T12:48:27.198Z</updated>
    
    <content type="html"><![CDATA[<p>今天新建项目，用Qt连接数据库时，发现如下报错：</p><p><a href="https://bu.dusays.com/2022/12/31/63b0104259b03.png"><img src="https://bu.dusays.com/2022/12/31/63b0104259b03.png" alt="Snipaste_2022-07-17_20-10-30.png"></a></p><p>在网上找了很多解决方法，但是发现好像都不行，还是会报错，最后认真重新检查了一下文件，发现竟然是没有加头文件，然后把头文件</p><p>**#include “ui_mainwindow.h”**加上，如下图所示</p><p><a href="https://bu.dusays.com/2022/12/31/63b01057075ee.png"><img src="https://bu.dusays.com/2022/12/31/63b01057075ee.png" alt="Snipaste_2022-07-17_20-13-13.png"></a></p><p>然后再重新编译，成功运行</p><p><a href="https://bu.dusays.com/2022/12/31/63b0106e00925.png"><img src="https://bu.dusays.com/2022/12/31/63b0106e00925.png" alt="Snipaste_2022-07-17_20-19-19.png"></a></p><p>浪费了很多时间，特此记录</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天新建项目，用Qt连接数据库时，发现如下报错：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bu.dusays.com/2022/12/31/63b0104259b03.png&quot;&gt;&lt;img src=&quot;https://bu.dusays.com/2022/12/31/6</summary>
      
    
    
    
    <category term="Qt" scheme="https://billysturate.github.io/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://billysturate.github.io/tags/Qt/"/>
    
  </entry>
  
</feed>
