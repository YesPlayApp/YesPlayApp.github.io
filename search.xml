<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Json详解</title>
      <link href="/2022/08/19/JSON%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/19/JSON%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://subingwen.cn/qt/json/">原文链接</a><br>JSON(JavaScrip Object Notation) 是一种<mark>轻量级的数据交换格式</mark>。它基于 ECMAScript (欧洲计算机协会制定的 js 规范) 的一个子集，<mark>采用完全独立于编程语言的文本格式来存储和表示数据</mark>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>关于上面的描述可以精简为一句话：<mark>Json 是一种数据格式，和语言无关，在什么语言中都可以使用 Json</mark>。基于这种通用的数据格式，一般处理两方面的任务：</p><p>组织数据（数据序列化），用于数据的网络传输组织数据（数据序列化），写磁盘文件实现数据的持久化存储(一般以 <mark>.json</mark> 作为文件后缀)<br>Json 中主要有两种数据格式：Json 数组和 Json 对象，并且这两种格式可以交叉嵌套使用，下面依次介绍下这两种数据格式：</p><h2 id="1-Json-数组">1.Json 数组</h2><p>Json 数组使用 [] 表示，[] 里边是元素，元素和元素之间使用逗号间隔，<mark>最后一个元素后边没有逗号</mark>，一个 Json 数组中支持同时存在多种不同类型的成员，包括：<mark>整形</mark>、<mark>浮点</mark>、 <mark>字符串</mark>、 <mark>布尔类型</mark>、 <mark>json数组</mark>、 <mark>json对象</mark>、 <mark>空值-null</mark>。由此可见 Json 数组比起 C/C++ 数组要灵活很多。</p><blockquote><p>Json 数组中的元素数据类型一致</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整形</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;luffy&quot;</span><span class="punctuation">,</span> <span class="string">&quot;sanji&quot;</span><span class="punctuation">,</span> <span class="string">&quot;zoro&quot;</span><span class="punctuation">,</span> <span class="string">&quot;nami&quot;</span><span class="punctuation">,</span> <span class="string">&quot;robin&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><blockquote><p>Json 数组中的元素数据类型不一致</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="number">12</span><span class="punctuation">,</span> <span class="number">13.34</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="string">&quot;hello,world&quot;</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><blockquote><p>Json 数组中的数组嵌套使用</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;cat&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dog&quot;</span><span class="punctuation">,</span> <span class="string">&quot;panda&quot;</span><span class="punctuation">,</span> <span class="string">&quot;beer&quot;</span><span class="punctuation">,</span> <span class="string">&quot;rabbit&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;北京&quot;</span><span class="punctuation">,</span> <span class="string">&quot;上海&quot;</span><span class="punctuation">,</span> <span class="string">&quot;天津&quot;</span><span class="punctuation">,</span> <span class="string">&quot;重庆&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;luffy&quot;</span><span class="punctuation">,</span> <span class="string">&quot;boy&quot;</span><span class="punctuation">,</span> <span class="number">19</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><blockquote><p>Json 数组和对象嵌套使用</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;luffy&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">19</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;father&quot;</span><span class="punctuation">:</span><span class="string">&quot;Monkey·D·Dragon&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;grandpa&quot;</span><span class="punctuation">:</span><span class="string">&quot;Monkey D Garp&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brother1&quot;</span><span class="punctuation">:</span><span class="string">&quot;Portgas D Ace&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brother2&quot;</span><span class="punctuation">:</span><span class="string">&quot;Sabo&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="2-Json-对象">2.Json 对象</h2><p>Json 对象使用 {} 来描述，每个 Json 对象中可以存储若干个元素，每一个元素对应一个键值对（key：value 结构），元素和元素之间使用逗号间隔，最后一个元素后边没有逗号。对于每个元素中的键值对有以下细节需要注意：</p><p>1.键值（key）必须是字符串，位于同一层级的键值不要重复（因为是通过键值取出对应的 value 值）<br>2.value 值的类型是可选的，可根据实际需求指定，可用类型包括：<mark>整形</mark>、 <mark>浮点</mark>、 <mark>字符串</mark>、 <mark>布尔类型</mark>、<mark>json数组</mark>、 <mark>json对象</mark>、 <mark>空值-null</mark>。<br><strong>使用 Json 对象描述一个人的信息:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Name&quot;:&quot;Ace&quot;,</span><br><span class="line">    &quot;Sex&quot;:&quot;man&quot;,</span><br><span class="line">    &quot;Age&quot;:20,</span><br><span class="line">    &quot;Family&quot;:&#123;</span><br><span class="line">        &quot;Father&quot;:&quot;Gol·D·Roger&quot;,</span><br><span class="line">        &quot;Mother&quot;:&quot;Portgas·D·Rouge&quot;,</span><br><span class="line">        &quot;Brother&quot;:[&quot;Sabo&quot;, &quot;Monkey D. Luffy&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IsAlive&quot;:false,</span><br><span class="line">    &quot;Comment&quot;:&quot;yyds&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注意事项">3.注意事项</h2><p>通过上面的介绍可用看到，Json 的结构虽然简单，但是进行嵌套之后就可以描述很复杂的事情，在项目开发过程中往往需要我们根据实际需求自己定义 Json 格式用来存储项目数据。</p><p>另外，如果需要将 Json 数据持久化到磁盘文件中，需要注意一个问题：<mark>在一个 Json 文件中只能有一个 Json 数组或者 Json 对象的根节点，不允许同时存储多个并列的根节点</mark>。下面举例说明：</p><blockquote><p>错误的写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// test.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;luffy&quot;,</span><br><span class="line">    &quot;age&quot;:19</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot;:&quot;ace&quot;,</span><br><span class="line">    &quot;passwd&quot;:&quot;123456&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误原因：<mark>在一个 Json 文件中有两个并列的 Json 根节点（并列包含 Json 对象和 Json 对象、Json 对象和 Json 数组、Json 数组和 Json 数组），根节点只能有一个。</mark></p><blockquote><p>正确的写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// test.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Name&quot;:&quot;Ace&quot;,</span><br><span class="line">    &quot;Sex&quot;:&quot;man&quot;,</span><br><span class="line">    &quot;Age&quot;:20,</span><br><span class="line">    &quot;Family&quot;:&#123;</span><br><span class="line">        &quot;Father&quot;:&quot;Gol·D·Roger&quot;,</span><br><span class="line">        &quot;Mother&quot;:&quot;Portgas·D·Rouge&quot;,</span><br><span class="line">        &quot;Brother&quot;:[&quot;Sabo&quot;, &quot;Monkey D. Luffy&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IsAlive&quot;:false,</span><br><span class="line">    &quot;Comment&quot;:&quot;yyds&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>在上面的例子中通过Json对象以及Json数组的嵌套描述了一个人的身份信息，并且根节点只有一个就是Json对象，如果还需要使用Json数组或者Json对象描述其他信息，需要将这些信息写入到其他文件中，不要和这个Json对象并列写入到同一个文件里边，切记！！！</mark></p>]]></content>
      
      
      <categories>
          
          <category> Json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++命名空间详解</title>
      <link href="/2022/08/18/c++%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/18/c++%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-作用域运算符">1. ::作用域运算符</h2><p>通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//全局a被隐藏</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是a:20。在test函数的输出语句中，使用的变量a是test函数内定义的局部变量，因此输出的结果为局部变量a的值。</p><p>作用域运算符可以用来解决局部变量与全局变量的重名问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//1. 局部变量和全局变量同名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//打印局部变量a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">//打印全局变量a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量a:&quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子可以看出，作用域运算符可以用来解决局部变量与全局变量的重名问题，即在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。</p><h2 id="2-C-命名空间-namespace">2.  C++命名空间(namespace)</h2><p>在c++ 中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等。工程越大，名称互相冲突性的可能性越大。另外使用多个厂商的类库时，也可能导致名称冲突。为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++ 库时，这些标识符的命名发生冲突，标准C++ 引入关键字namespace（命名空间/名字空间/名称空间），可以更好地控制标识符的作用域。</p><h3 id="2-1命名空间使用语法">2.1命名空间使用语法</h3><p><mark>创建一个命名空间:</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>命名空间只能全局范围内定义（<strong>以下错误写法</strong>）</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>命名空间可嵌套命名空间</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::B::a : &quot;</span> &lt;&lt; A::B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>命名空间是开放的，即可以随时把新的成员加入已有的命名空间中</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello namespace!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">A::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>声明和实现可分离</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MySpace&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MySpace::func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func2</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MySpace::func2 : &quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><mark>无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; a &lt;&lt; endl;<span class="comment">//直接访问就行，可以看成静态变量</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>命名空间别名</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> veryLongName&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> shortName = veryLongName;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;veryLongName::a : &quot;</span> &lt;&lt; shortName::a &lt;&lt; endl;</span><br><span class="line">veryLongName::<span class="built_in">func</span>();</span><br><span class="line">shortName::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-using声明">2.2 using声明</h3><p>using声明可使得指定的标识符可用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">  <span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1. 通过命名空间域运算符</span></span><br><span class="line">cout &lt;&lt; A::paramA &lt;&lt; endl;</span><br><span class="line">A::<span class="built_in">funcA</span>();</span><br><span class="line"><span class="comment">//2. using声明</span></span><br><span class="line"><span class="keyword">using</span> A::paramA;</span><br><span class="line"><span class="keyword">using</span> A::funcA;</span><br><span class="line">cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; paramB &lt;&lt; endl; //不可直接访问</span></span><br><span class="line"><span class="built_in">funcA</span>();</span><br><span class="line"><span class="comment">//3. 同名冲突,using声明和就近原则不要同时出现</span></span><br><span class="line"><span class="comment">//int paramA = 20; //相同作用域注意同名冲突</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>using声明碰到函数重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> A::func;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。</p><h3 id="2-3-using编译指令">2.3 using编译指令</h3><p>using编译指令使整个命名空间标识符可用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcB&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; paramB &lt;&lt; endl;</span><br><span class="line"><span class="built_in">funcA</span>();</span><br><span class="line"><span class="built_in">funcB</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//不会产生二义性，using编译指令和就近原则同时出现，优先使用就近原则</span></span><br><span class="line"><span class="type">int</span> paramA = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcB&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line"><span class="comment">//二义性产生，不知道调用A还是B的paramA</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; paramA &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：使用using声明或using编译指令会增加命名冲突的可能性。也就是说，如果有名称空间，并在代码中使用作用域解析运算符，则不会出现二义性</strong></p></blockquote><h3 id="2-4-命名空间使用">2.4 命名空间使用</h3><p>我们刚讲的一些东西一开始会觉得难一些，这些东西以后还是挺常用，只要理解了它们的工作机理，使用它们非常简单。</p><p>需要记住的关键问题是当引入一个全局的using编译指令时，就为该文件打开了该命名空间，它不会影响任何其他的文件，所以可以在每一个实现文件中调整对命名空间的控制。比如，如果发现某一个实现文件中有太多的using指令而产生的命名冲突，就要对该文件做个简单的改变，通过明确的限定或者using声明来消除名字冲突，这样不需要修改其他的实现文件。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类型转换详解</title>
      <link href="/2022/08/18/c++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2022/08/18/c++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>类型转换(cast)是将一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。</p><p>转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的数据。</p><p>应该小心类型转换，因为转换也就相当于对编译器说：忘记类型检查，把它看做其他的类型。</p><blockquote><p>一般情况下，尽量少的去使用类型转换，除非用来解决非常特殊的问题。 无论什么原因，任何一个程序如果使用很多类型转换都值得怀疑.</p></blockquote><p>标准c++提供了一个显示的转换的语法，来替代旧的C风格的类型转换。</p><p>使用C风格的强制转换可以把想要的任何东西转换成我们需要的类型。那为什么还需要一个新的C++类型的强制转换呢？</p><p>新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。</p><h2 id="1-静态转换-static-cast">1. 静态转换(static_cast)</h2><p>用于<a href="http://baike.baidu.com/view/2405425.htm">类层次结构</a>中基类（父类）和<a href="http://baike.baidu.com/view/535532.htm">派生类</a>（子类）之间指针或引用的转换。</p><p>进行向上转换（把派生类的指针或引用转换成基类表示）是安全的；</p><p>进行向下转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</p><p>用于基本数据类型之间的转换，如把int转换成char，把char转换成int。这种转换的安全性也要开发人员来保证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;&#125;;</span><br><span class="line">class Dog : public Animal&#123;&#125;;</span><br><span class="line">class Other&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//基础数据类型转换</span><br><span class="line">void test01()&#123;</span><br><span class="line">char a = &#x27;a&#x27;;</span><br><span class="line">double b = static_cast&lt;double&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承关系指针互相转换</span><br><span class="line">void test02()&#123;</span><br><span class="line">//继承关系指针转换</span><br><span class="line">Animal* animal01 = NULL;</span><br><span class="line">Dog* dog01 = NULL;</span><br><span class="line">//子类指针转成父类指针,安全</span><br><span class="line">Animal* animal02 = static_cast&lt;Animal*&gt;(dog01);</span><br><span class="line">//父类指针转成子类指针，不安全</span><br><span class="line">Dog* dog02 = static_cast&lt;Dog*&gt;(animal01);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承关系引用相互转换</span><br><span class="line">void test03()&#123;</span><br><span class="line"></span><br><span class="line">Animal ani_ref;</span><br><span class="line">Dog dog_ref;</span><br><span class="line">//继承关系指针转换</span><br><span class="line">Animal&amp; animal01 = ani_ref;</span><br><span class="line">Dog&amp; dog01 = dog_ref;</span><br><span class="line">//子类指针转成父类指针,安全</span><br><span class="line">Animal&amp; animal02 = static_cast&lt;Animal&amp;&gt;(dog01);</span><br><span class="line">//父类指针转成子类指针，不安全</span><br><span class="line">Dog&amp; dog02 = static_cast&lt;Dog&amp;&gt;(animal01);</span><br><span class="line">&#125;</span><br><span class="line">//无继承关系指针转换</span><br><span class="line">void test04()&#123;</span><br><span class="line"></span><br><span class="line">Animal* animal01 = NULL;</span><br><span class="line">Other* other01 = NULL;</span><br><span class="line"></span><br><span class="line">//转换失败</span><br><span class="line">//Animal* animal02 = static_cast&lt;Animal*&gt;(other01);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-动态转换-dynamic-cast">2. 动态转换(dynamic_cast)</h2><p>dynamic_cast主要用于类层次间的向上转换和向下转换；</p><p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；</p><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowName</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I am a dog!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是其他类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不支持基础数据类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//double a = dynamic_cast&lt;double&gt;(a);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承关系指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Dog* dog01 = <span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类指针转换成父类指针 可以</span></span><br><span class="line">Animal* animal02 = <span class="built_in">dynamic_cast</span>&lt;Animal*&gt;(dog01);</span><br><span class="line">animal02-&gt;<span class="built_in">ShowName</span>();</span><br><span class="line"><span class="comment">//父类指针转换成子类指针 不可以</span></span><br><span class="line"><span class="comment">//Dog* dog02 = dynamic_cast&lt;Dog*&gt;(animal01);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承关系引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Dog dog_ref;</span><br><span class="line">Dog&amp; dog01 = dog_ref;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类引用转换成父类引用 可以</span></span><br><span class="line">Animal&amp; animal02 = <span class="built_in">dynamic_cast</span>&lt;Animal&amp;&gt;(dog01);</span><br><span class="line">animal02.<span class="built_in">ShowName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无继承关系指针转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Other* other = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可以</span></span><br><span class="line"><span class="comment">//Animal* animal02 = dynamic_cast&lt;Animal*&gt;(other);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-常量转换-const-cast">3. 常量转换(const_cast)</h2><p>该运算符用来修改类型的const属性。</p><p>常量指针被转化成非常量指针，并且仍然指向原来的对象；</p><p>常量引用被转换成非常量引用，并且仍然指向原来的对象；</p><p>**注意:**不能直接对非指针和非引用的变量使用const_cast操作符去直接移除它的const.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量指针转换成非常量指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>* np = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* pp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* npp = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(pp);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">//不能对非指针或非引用进行转换</span></span><br><span class="line"><span class="comment">//int b = const_cast&lt;int&gt;(a); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量引用转换成非常量引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp; refNum = num;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; refNum2 = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>&amp;&gt;(refNum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3-重新解释转换-reinterpret-cast-不建议使用">2.3 重新解释转换(reinterpret_cast)(不建议使用)</h2><p>这是最不安全的一种转换机制，最有可能出问题。</p><p>主要用于将一种数据类型从一种类型转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针.</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb详解</title>
      <link href="/2022/08/12/gdb%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/12/gdb%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>一、调试前的准备</h1><p>用gcc编译源程序的时候，编译后的可执行文件不会包含源程序代码，如果您打算编译后的程序可以被调试，编译的时候要加-g的参数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o book113 book113.c</span><br></pre></td></tr></table></figure><p>在命令提示符下输入gdb book113就可以调试book113程序了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb book113</span><br></pre></td></tr></table></figure><h1>二、基本调试命令</h1><table><thead><tr><th><strong>命令</strong></th><th><strong>命令</strong>缩写</th><th>命令说明</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>列出源码，根据源码指定行号，设置断点</td></tr><tr><td>set args</td><td></td><td>设置主程序的参数。例如：./book119 /oracle/c/book1.c /tmp/book1.c设置参数的方法是：gdb book119(gdb) set args /oracle/c/book1.c /tmp/book1.c</td></tr><tr><td>break</td><td>b</td><td>设置断点，b 20 表示在第20行设置断点，可以设置多个断点。</td></tr><tr><td>run</td><td>r</td><td>开始运行程序, 程序运行到断点的位置会停下来，如果没有遇到断点，程序一直运行下去。</td></tr><tr><td>next</td><td>n</td><td>执行当前行语句，如果该语句为函数调用，不会进入函数内部执行。</td></tr><tr><td>step</td><td>s</td><td>执行当前行语句，如果该语句为函数调用，则进入函数执行其中的第一条语句。注意了，如果函数是库函数或第三方提供的函数，用s也是进不去的，因为没有源代码，如果是您自定义的函数，只要有源码就可以进去。</td></tr><tr><td>print</td><td>p</td><td>显示变量值，例如：p name表示显示变量name的值。</td></tr><tr><td>continue</td><td>c</td><td>继续程序的运行，直到遇到下一个断点。</td></tr><tr><td>set var name=value</td><td></td><td>设置变量的值，假设程序有两个变量：int ii; char name[21];set var ii=10 把ii的值设置为10；set var name=“fsda” 把name的值设置为&quot;fsda&quot;，注意，不是strcpy。</td></tr><tr><td>finish</td><td></td><td>结束当前函数调用，返回到函数调用点</td></tr><tr><td>info b</td><td></td><td>info b 查看设置的断点信息</td></tr><tr><td>ptype</td><td></td><td>查看变量类型 例如：ptype name表示查看变量name的类型</td></tr><tr><td>bt</td><td></td><td>列出当前程序存活者的栈帧</td></tr><tr><td>frame</td><td></td><td>根据栈帧编号,替换栈帧</td></tr><tr><td>(un)display</td><td></td><td>设置跟踪变量</td></tr><tr><td>quit</td><td>q</td><td>退出gdb环境。</td></tr></tbody></table><p>注意，在gdb环境中，可以用上下光标键选择执行过的gdb命令。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim/Vi常用命令总结</title>
      <link href="/2022/08/11/Vim_Vi%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2022/08/11/Vim_Vi%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、是什么">一、是什么</h2><p>VI 是Unix操作系统和类Unix操作系统中最通用的文本编辑器。</p><p>VIM编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM与VI 编辑器完全兼容。</p><h2 id="二、创建-打开文件">二、创建/打开文件</h2><p>vim 文件名</p><p>打开一个文件，如果文件不存在，将会自动创建它。</p><p>示例：</p><p>vim book.c</p><h2 id="三、vim的三种模式">三、vim的三种模式</h2><p>vim 有三种模式，命令行模式、插入模式和替换模式，在命令行模式下，任何键盘输入都是命令，在插入模式和替换模式下，键盘输入的才是字符。</p><p>插入模式和替换模式也合称为编辑模式。</p><p><img src="https://bu.dusays.com/2022/12/31/63b00cb58dcdb.png" alt="p1.png"></p><h2 id="四、vim的常用命令">四、vim的常用命令</h2><p>Esc    从编辑模式切换到命令行模式。</p><p>i   在光标所在位置前面开始插入。</p><p>a   在光标所在的位置后面开始插入。</p><p>o  在光标所在位置行的下面插入空白行。</p><p>O  在光标所在位置行的上面插入空白行。</p><p>I   在光标所在位置行的行首开始插入。</p><p>A  在光标所在位置行的行末开始插入。</p><p>k   类似方向键上。</p><p>j   类似方向键下。</p><p>h  类似方向键左。</p><p>l   类是方向键右。</p><p>Ctrl+u  向上翻半页。</p><p>Ctrl+d  向下翻页。</p><p>Ctrl+g    显示光标所在位置的行号和文件的总行数。</p><p>nG 光标跳到文件的第n行行首。</p><p>G  光标跳到文件最后一行。</p><p>:5回车  光标跳到第5行。</p><p>:n回车  光标跳到第n行。</p><p>:set nu 设置行号</p><p>:set nonu 关闭行号</p><p>0   光标跳到当前行的行首。</p><p>$   光标跳到当前行的行尾。</p><p>Ctrl+Home 光标跳到整篇文章开头</p><p>Ctrl+End 光标跳到整篇文章结尾</p><p>w   光标跳到下个单词的开头。</p><p>b   光标跳到上个单词的开头。</p><p>e  光标跳到本单词的尾部。</p><p>x    每按一次，删除光标所在位置的一个字符。</p><p>nx  如&quot;3x&quot;表示删除光标所在位置开始的3个字符。</p><p>dw 删除光标所在位置到本单词结尾的字符。</p><p>D  删除本行光标所在位置后面全部的内容。</p><p>dd  删除光标所在位置的一行。</p><p>ndd 如&quot;3dd&quot;表示删除光标所在位置开始的3行。</p><p>yy  将光标所在位置的一行复制到缓冲区。</p><p>nyy 将光标所在位置的n行复制到缓冲区。</p><p>p   将缓冲区里的内容粘贴到光标所在位置。</p><p>r   替换光标所在位置的一个字符 replace。</p><p>R  从光标所在位置开始替换，直到按下&quot;Esc&quot;。</p><p>cw 从光标所在位置开始替换单词，直到按下&quot;Esc&quot;。</p><p>u  撤销命令，可多次撤销。</p><p>J  把当前行的下一行接到当前行的尾部。</p><p>/abcd  在当前打开的文件中查找“abcd”文本内容。</p><p>n   查找下一个。</p><p>N   查找上一下。</p><p>.  重复执行上一次执行的vi命令。</p><p>~  对光标当前所在的位置的字符进行大小写转换。</p><p>列操作</p><p>Ctrl+V  光标上或下  大写的I  输入内容  Esc</p><p>:w回车  存盘。</p><p>:w!回车  强制存盘。</p><p>:wq回车 存盘退出。</p><p>:x回车  存盘退出。</p><p>:q回车 不存盘退出。</p><p>:q!回车  不存盘强制退出。</p><p>:g/aaaaaaaaa/s//bbbbbb/g回车  把文件中全部的aaaaaaaaa替换成bbbbbb。</p><p>Ctl+insert  复制鼠标选中的文本，相当于Ctl+c。</p><p>Shift+insert 输出鼠标选中的文本，相当于Ctl+v。</p><p>以上两个命令在windows和UNIX中是通用的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim/Vi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas详解</title>
      <link href="/2022/08/05/pandas%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/05/pandas%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1hx411d7jb?spm_id_from=333.337.search-card.all.click&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><h2 id="1-pandas的常用数据类型">1.pandas的常用数据类型</h2><p>1.Series 一维，带标签数组</p><p>2.DataFrame 二维，Series容器</p><h2 id="2-pandas之Series创建">2.pandas之Series创建</h2><p><img src="https://img-blog.csdnimg.cn/bb43d34acca640a49f6235918cdc9d91.png#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/234e646df7ca4617a62cb02967d66d7d.png#pic_center" alt="图片2"></p><h2 id="3-pandas之Series切片和索引">3.pandas之Series切片和索引</h2><p><img src="https://img-blog.csdnimg.cn/a317d112aac84680ba7668555d2d12a5.png#pic_center" alt="图片3"></p><h2 id="4-pandas之Series的索引和值">4.pandas之Series的索引和值</h2><p><img src="https://img-blog.csdnimg.cn/eb431cfe4c154698ad432933016f986d.png#pic_center" alt="图片4"></p><h2 id="5-pandas之读取外部数据">5.pandas之读取外部数据</h2><p>我们的这组数据存在csv中，我们直接使用pd. read_csv即可</p><p>和我们想象的有些差别，我们以为他会是一个Series类型，但是他是一个DataFrame，那么接下来我们就来了解这种数据类型</p><p><mark>小示例：</mark></p><p>现在假设我们有一个组关于狗的名字的统计数据，那么为了观察这组数据的情况，我们应该怎么做呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">df = pd.read_csv(&#x27;./dogNames2.csv&#x27;)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://img-blog.csdnimg.cn/68be90dd4ba5438998639c7eec18efe3.png#pic_center" alt="图片5"></p><h2 id="6-pandas之DataFrame">6.pandas之DataFrame</h2><p><img src="https://img-blog.csdnimg.cn/be5b901ba4fb47cea1bd2ec48f9ae57e.png#pic_center" alt="图片6"></p><p><strong>DataFrame对象既有行索引，又有列索引</strong></p><p>行索引，表明不同行，横向索引，叫index，0轴，axis=0</p><p>列索引，表名不同列，纵向索引，叫columns，1轴，axis=1</p><p><img src="https://img-blog.csdnimg.cn/9ca03dc5756543d0b8912fdf772ef66a.png#pic_center" alt="图片7"></p><p><img src="https://img-blog.csdnimg.cn/52b5430936d04a96b1506fe210c93b5b.png#pic_center" alt="图片8"></p><p>那么回到之前我们读取的狗名字统计的数据上，我们尝试一下刚刚的方法</p><p>那么问题来了：</p><p>很多同学肯定想知道使用次数最高的前几个名字是什么呢？</p><p><code>df.sort_values(by=&quot;Count_AnimalName&quot;,ascending=*False*)</code></p><p><mark>dataframe排序</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">df = pd.read_csv(&#x27;./dogNames2.csv&#x27;)</span><br><span class="line"># print(df)</span><br><span class="line"># print(&#x27;*&#x27;*100)</span><br><span class="line"># print(df.head())</span><br><span class="line"># print(&#x27;*&#x27;*100)</span><br><span class="line"># print(df.info())</span><br><span class="line"># print(&#x27;*&#x27;*100)</span><br><span class="line"># print(df.describe())</span><br><span class="line"></span><br><span class="line"># 以Count_AnimalName来排序（默认升序）</span><br><span class="line"># df = df.sort_values(by=&#x27;Count_AnimalName&#x27;)</span><br><span class="line"># ascending=True 为升序，False为倒序</span><br><span class="line">df = df.sort_values(by=&#x27;Count_AnimalName&#x27;,ascending=False)</span><br><span class="line">print(df.head(10))</span><br></pre></td></tr></table></figure><h2 id="7-pandas之取行或者列">7.pandas之取行或者列</h2><p>刚刚我们知道了如何给数据按照某一行或者列排序，那么现在我们想单独研究使用次数前100的数据，应该如何做？</p><p><code>df_sorted = df.sort_values(by=&quot;Count_AnimalName&quot;)</code></p><p><code>df_sorted[:100]</code></p><p>那么问题来了：</p><p>我们具体要选择某一列该怎么选择呢？<code>df[&quot; Count_AnimalName &quot;]</code></p><p>我们要同时选择行和列改怎么办？<code>df[:100][&quot; Count_AnimalName &quot;]</code></p><h2 id="8-pandas之loc">8.pandas之loc</h2><p>还有更多的经过pandas优化过的选择方式：</p><p>1.df.loc 通过<strong>标签</strong>索引行数据</p><p>2.df.iloc 通过<strong>位置</strong>获取行数据</p><p><img src="https://img-blog.csdnimg.cn/4b62f336e82e420dac4b8bd321307195.png#pic_center" alt="图片9"></p><p><img src="https://img-blog.csdnimg.cn/9110f21838ff4e9d8834322a3ae3730b.png#pic_center" alt="图片10"></p><h2 id="9-pandas之布尔索引">9.pandas之布尔索引</h2><p>回到之前狗的名字的问题上，假如我们想找到所有的使用次数超过800的狗的名字，应该怎么选择？</p><p><img src="https://img-blog.csdnimg.cn/41bbcc62c40c42ed9f26ec43fd426cf9.png#pic_center" alt="图片11"></p><p>回到之前狗的名字的问题上，假如我们想找到所有的使用次数超过700并且名字的字符串的长度大于4的狗的名字，应该怎么选择？</p><p><img src="https://img-blog.csdnimg.cn/e9560f381945448db72ee3e53ed7c2b6.png#pic_center" alt="图片12"></p><h2 id="10-pandas之字符串方法">10.pandas之字符串方法</h2><p><img src="https://img-blog.csdnimg.cn/4c472eb7157b44a19c24e1e0d4dd2670.png#pic_center" alt="图片13"></p><h2 id="11-缺失数据的处理">11.缺失数据的处理</h2><p>观察下面这组数据</p><p><img src="https://img-blog.csdnimg.cn/e5e6a7182e0c45a9ac32234186f9d287.png#pic_center" alt="图片14"></p><p>我们的数据缺失通常有两种情况：</p><p>一种就是空，None等，在pandas是NaN(和np.nan一样)另一种是我们让其为0，蓝色框中</p><p>对于NaN的数据，在numpy中我们是如何处理的？</p><p>在pandas中我们处理起来非常容易</p><p>判断数据是否为NaN：<code>pd.isnull(df),pd.notnull(df)</code></p><p>处理方式1：删除NaN所在的行列<code>dropna (axis=0, how='any', inplace=False)</code></p><p>处理方式2：填充数据，<code>t.fillna(t.mean()),t.fiallna(t.median()),t.fillna(0)</code></p><p>处理为0的数据：<code>t[t==0]=np.nan</code></p><p>当然并不是每次为0的数据都需要处理</p><p>计算平均值等情况，nan是不参与计算的，但是0会</p><p><mark>示例</mark></p><p>假设现在我们有一组从2006年到2016年1000部最流行的电影数据，我们想知道这些电影数据中评分的平均分，导演的人数等信息，我们应该怎么获取？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd, numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;IMDB-Movie-Data.csv&#x27;)</span><br><span class="line">print(type(df))</span><br><span class="line">print(df.info())</span><br><span class="line">print(df.head())</span><br><span class="line">print(df[&#x27;Rating&#x27;].values)</span><br><span class="line">print(df[&#x27;Rating&#x27;].describe())</span><br><span class="line"># df[&#x27;Rating&#x27;].mean()为numpy类型的数据，不能使用字符串拼接，需要先转换为字符串</span><br><span class="line"># 电影评分平均值</span><br><span class="line">print(&#x27;电影平均分：&#x27; + str(df[&#x27;Rating&#x27;].mean()))</span><br><span class="line"># 导演的人数</span><br><span class="line"># df[&#x27;Director&#x27;].tolist()  #  python tolist()方法:将数组或者矩阵转换成列表</span><br><span class="line"># set(df[&#x27;Director&#x27;].tolist()) # 使用set() 将数组去重并转换为set集合，集合是一个无序的不重复元素序列</span><br><span class="line">print(&#x27;导演人数：&#x27;, len(set(df[&#x27;Director&#x27;].tolist())))</span><br><span class="line"># 别一种方法：df[&#x27;Director&#x27;].unique()可以将df[&#x27;Director&#x27;]去重，并返回</span><br><span class="line">print(&#x27;导演人数：&#x27;, len(df[&#x27;Director&#x27;].unique()))</span><br><span class="line"># 由于每一部电影的演员有多人，所以先使用split(&#x27;,&#x27;)以逗号分隔，让每组数据的字符串重组为数组</span><br><span class="line">print(&#x27;所有演员二维数据：&#x27;)</span><br><span class="line">print(df[&#x27;Actors&#x27;].str.split(&#x27;,&#x27;).tolist())</span><br><span class="line">temp_list = df[&#x27;Actors&#x27;].str.split(&#x27;,&#x27;).tolist()</span><br><span class="line"># 将二维数组展开</span><br><span class="line">nums = [i for j in temp_list for i in j]</span><br><span class="line">print(&#x27;所有演员一维数组：&#x27;)</span><br><span class="line">print(nums)</span><br><span class="line"># 数组去重,并取总数</span><br><span class="line">actors = len(set(nums))  # 使用set集合的特点去重</span><br><span class="line">actors2 = len(pd.Series(nums).unique())  # 使用pandas的unique方法去重</span><br><span class="line">print(&#x27;去重后演员的总人数：&#x27;, actors, actors2)</span><br><span class="line"># 电影时长的最大最小值：</span><br><span class="line">max_runtime = df[&#x27;Runtime (Minutes)&#x27;].max()</span><br><span class="line">max_runtime_index = df[&#x27;Runtime (Minutes)&#x27;].argmax()</span><br><span class="line">min_runtime = df[&#x27;Runtime (Minutes)&#x27;].min()</span><br><span class="line">min_runtime_index = df[&#x27;Runtime (Minutes)&#x27;].argmin()</span><br><span class="line">runtime_median = df[&#x27;Runtime (Minutes)&#x27;].median()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7a158f5466e84d30bc4962abb4d77a75.png#pic_center" alt="图片15"></p><p><mark>示例</mark></p><p>对于这一组电影数据，如果我们希望统计电影分类(genre)的情况，应该如何处理数据？</p><p>思路：重新构造一个全为0的数组，列名为分类，如果某一条数据中分类出现过，就让0变为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;IMDB-Movie-Data.csv&#x27;)</span><br><span class="line">print(df[&#x27;Genre&#x27;])</span><br><span class="line">temp_list = df[&#x27;Genre&#x27;].str.split(&#x27;,&#x27;).tolist()</span><br><span class="line">print(temp_list)</span><br><span class="line"># 利用set展开二维列表并去重</span><br><span class="line">genre_list = list(set([i for j in temp_list for i in j]))</span><br><span class="line">print(genre_list)</span><br><span class="line"># 构造全为0的DataFrame:df一样的行数，分类总数的列数，索引为分类数据genre_list</span><br><span class="line"># np.zeros((a,b))里面传的是元组</span><br><span class="line">zeros_df = pd.DataFrame(np.zeros((df.shape[0], len(genre_list))), columns=genre_list)</span><br><span class="line">print(zeros_df)</span><br><span class="line">for i in range(df.shape[0]):</span><br><span class="line">    zeros_df.loc[i, temp_list[i]] = 1</span><br><span class="line"># 显示所有列</span><br><span class="line">pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># 显示所有列</span><br><span class="line"># pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># #显示所有行</span><br><span class="line"># pd.set_option(&#x27;display.max_rows&#x27;, None)</span><br><span class="line"># #设置value的显示长度为100，默认为50</span><br><span class="line"># pd.set_option(&#x27;max_colwidth&#x27;,100)</span><br><span class="line">print(zeros_df.head(1))</span><br><span class="line"># 统计每个分类的电影的数量和</span><br><span class="line">genre_count = zeros_df.sum(axis=0)</span><br><span class="line">print(genre_count)</span><br><span class="line"># 排序</span><br><span class="line">genre_count = genre_count.sort_values()</span><br><span class="line"># 画柱状图</span><br><span class="line">_x = genre_count.index</span><br><span class="line">_y = genre_count.values</span><br><span class="line">plt.figure(figsize=(20, 8), dpi=80)</span><br><span class="line">plt.bar(range(len(_x)), _y)</span><br><span class="line">plt.xticks(range(len(_x)), _x)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/378e9f5eeb7d4373940e2aa3f7131f91.png#pic_center" alt="图片16"></p><h2 id="12-数据合并之join">12.数据合并之join</h2><p>join:默认情况下他是把行索引相同的数据合并到一起</p><p><img src="https://img-blog.csdnimg.cn/a2b0d6d56c47431baf76ad4ab8f1c9fa.png#pic_center" alt="图片17"></p><h2 id="13-数据合并之merge">13.数据合并之merge</h2><p>merge:按照指定的列把数据按照一定的方式合并到一起</p><p><img src="https://img-blog.csdnimg.cn/1ba88efd40d944d3a995597ec1d810a4.png#pic_center" alt="图片18"></p><p><mark>示例：</mark></p><p>现在我们有一组关于全球星巴克店铺的统计数据，如果我想知道美国的星巴克数量和中国的哪个多，或者我想知道中国每个省份星巴克的数量的情况，那么应该怎么办？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;starbucks_store_worldwide.csv&#x27;)</span><br><span class="line"># print(df)</span><br><span class="line"># print(df.info())</span><br><span class="line"># df_country = df.groupby(&#x27;Country&#x27;)  # 生成一个DataFrameGroupBy object</span><br><span class="line"># print(df_country)</span><br><span class="line"># # 显示所有列</span><br><span class="line"># pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># # 遍历</span><br><span class="line"># # for i in df_country:</span><br><span class="line"># #     print(i) # 遍历后的每一个数据都是一个元组</span><br><span class="line">#</span><br><span class="line"># # 由于遍历后的每一个值都是元组，所以还可以这样遍历</span><br><span class="line"># for i, j in df_country:</span><br><span class="line">#     print(i, j, type(j))  # i为国家信息，j为一个DataFrame,其中所有的country字段均为i</span><br><span class="line">#     print(&#x27;*&#x27; * 100)</span><br><span class="line">#</span><br><span class="line"># # 调用聚合方法</span><br><span class="line"># print(df_country.count())  # count()可以统计每个字段的总数</span><br><span class="line"># print(df_country[&#x27;City&#x27;].count())  # 单独统计一个字段的总数</span><br><span class="line"># #</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">平均值，中位数等方法也可以使用，但这里使用没有意义，因为都是字符串</span><br><span class="line">count:分组中非NA值的数量</span><br><span class="line">sum:非NA的和</span><br><span class="line">mean:非NA值的平均值 </span><br><span class="line">median:非NA值的算术中位数</span><br><span class="line">std、var: 无偏（分母为n-a)标准差和方差</span><br><span class="line">min,max:非NA值的最小值和最大值 &quot;&quot;&quot;</span><br><span class="line"># country_count = df_country[&#x27;City&#x27;].count()</span><br><span class="line"># # 美国和中国的星巴克店铺数量</span><br><span class="line"># print(&#x27;美国：&#x27;, country_count[&#x27;US&#x27;])</span><br><span class="line"># print(&#x27;中国：&#x27;, country_count[&#x27;CN&#x27;])</span><br><span class="line"></span><br><span class="line"># 统计中国每个省份的星巴克</span><br><span class="line">china_data = df[df[&#x27;Country&#x27;] == &#x27;CN&#x27;]  # 取出中国的星巴克数据，这里可以不需要分组，直接取数据</span><br><span class="line"># print(china_data)</span><br><span class="line"># print(china_data.info())</span><br><span class="line"># province_data = china_data.groupby(&#x27;State/Province&#x27;).count()[&#x27;Brand&#x27;]</span><br><span class="line"># print(province_data)</span><br><span class="line"># groupby可以传入多个条件来分组</span><br><span class="line">print(df[&#x27;Brand&#x27;])</span><br><span class="line">china_data_group = df.groupby(</span><br><span class="line">    by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]]).count()  # 返回一个Series,列索引有两个，一个是country,一个是State/Province</span><br><span class="line">print(china_data_group)</span><br><span class="line">print(china_data_group[&#x27;Brand&#x27;])</span><br><span class="line"></span><br><span class="line"># 以下三种写法，结果相同</span><br><span class="line">group1 = df.groupby(by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]]).count()[&#x27;Brand&#x27;]</span><br><span class="line">group2 = df[&#x27;Brand&#x27;].groupby(by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]]).count()</span><br><span class="line">group3 = df.groupby(by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]])[&#x27;Brand&#x27;].count()</span><br><span class="line">print(group1, type(group1))</span><br><span class="line">print(&#x27;*&#x27; * 100)</span><br><span class="line">print(group2, type(group2))</span><br><span class="line">print(&#x27;*&#x27; * 100)</span><br><span class="line">print(group3, type(group3))</span><br><span class="line"># 取值可以为DataFrame,需要使用一个小技巧</span><br><span class="line">group4 = df[[&#x27;Brand&#x27;]].groupby(by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]]).count()</span><br><span class="line">print(&#x27;*&#x27; * 100)</span><br><span class="line">print(group4, type(group4))</span><br><span class="line">print(group1.index)</span><br></pre></td></tr></table></figure><h2 id="14-分组和聚合">14.分组和聚合</h2><p><code>grouped = df.groupby(by=&quot;columns_name&quot;)</code></p><p>grouped是一个DataFrameGroupBy对象，是可迭代的</p><p>grouped中的每一个元素是一个元组</p><p>元组里面是（索引(分组的值)，分组之后的DataFrame）</p><p>DataFrameGroupBy对象有很多经过优化的方法</p><p><img src="https://img-blog.csdnimg.cn/139e675a90e1446098f585c5279e346c.png#pic_center" alt="图片19"></p><p>如果我们需要对国家和省份进行分组统计，应该怎么操作呢？</p><p><code>grouped = df.groupby(by=[df[&quot;Country&quot;],df[&quot;State/Province&quot;]])</code></p><p>很多时候我们只希望对获取分组之后的某一部分数据，或者说我们只希望对某几列数据进行分组，这个时候我们应该怎么办呢？</p><p>获取分组之后的某一部分数据：</p><p><code>df.groupby(by=[&quot;Country&quot;,&quot;State/Province&quot;])[&quot;Country&quot;].count()</code></p><p>对某几列数据进行分组：</p><p><code>df[&quot;Country&quot;].groupby(by=[df[&quot;Country&quot;],df[&quot;State/Province&quot;]]).count()</code></p><p>观察结果，由于只选择了一列数据，所以结果是一个Series类型</p><p>如果我想返回一个DataFrame类型呢？</p><p><code>t1 = df[[&quot;Country&quot;]].groupby(by=[df[&quot;Country&quot;],df[&quot;State/Province&quot;]]).count()</code><br><code>t2 = df.groupby(by=[&quot;Country&quot;,&quot;State/Province&quot;])[[&quot;Country&quot;]].count()</code></p><p>以上的两条命令结果一样</p><p>和之前的结果的区别在于当前返回的是一个DataFrame类型</p><p>简单的索引操作：</p><p>•获取index：<code>df.index</code></p><p>•指定index ：<code>df.index = ['x','y']</code></p><p>•重新设置index : <code>df.reindex(list(&quot;abcedf&quot;))</code></p><p>•指定某一列作为index ：<code>df.set_index(&quot;Country&quot;,drop=False)</code></p><p>•返回index的唯一值：<code>df.set_index(&quot;Country&quot;).index.unique()</code></p><h2 id="15-Series复合索引">15.Series复合索引</h2><p><img src="https://img-blog.csdnimg.cn/65d81c0cc1934479aeb8cee008889f63.png#pic_center" alt="图片20"></p><p><img src="https://img-blog.csdnimg.cn/40eeea952b1340a594e96bb67792006c.png#pic_center" alt="图片21"></p><p><img src="https://img-blog.csdnimg.cn/89c065dd558b4334bddd49b9ddab9b90.png#pic_center" alt="图片22"></p><p><mark>示例</mark></p><p>现在我们有2015到2017年25万条911的紧急电话的数据，请统计出出这些数据中不同类型的紧急情况的次数，如果我们还想统计出不同月份不同类型紧急电话的次数的变化情况，应该怎么做呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd, numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;911.csv&#x27;)</span><br><span class="line"># 显示所有列</span><br><span class="line">pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># print(df.head())</span><br><span class="line"># print(df.info())</span><br><span class="line"># print(df[&#x27;title&#x27;].str.split(&#x27;:&#x27;))</span><br><span class="line"># print(df[&#x27;title&#x27;].str.split(&#x27;:&#x27;)[0]) # 不能取到数据</span><br><span class="line"># to_list()将序列转换为数组</span><br><span class="line">temp_list = df[&#x27;title&#x27;].str.split(&#x27;:&#x27;).to_list()</span><br><span class="line"># temp_list = df[&#x27;title&#x27;].str.split(&#x27;:&#x27;).tolist()</span><br><span class="line">print(temp_list)</span><br><span class="line"># 遍历并取出第一项数据并去重</span><br><span class="line">cate_list = list(set([i[0] for i in temp_list]))</span><br><span class="line">print(cate_list)</span><br><span class="line"># 构造一个DataFrame,三列，与df同行，数据全为0</span><br><span class="line">zeros_df = pd.DataFrame(np.zeros((df.shape[0], len(cate_list))), columns=cate_list)</span><br><span class="line">print(zeros_df)</span><br><span class="line"># 　由于df数据量太大，如果直接遍历，会消耗很长时间</span><br><span class="line"># for i in range(df.shape[0]):</span><br><span class="line">#     zeros_df.loc[i,temp_list[i][0]] = 1</span><br><span class="line">#</span><br><span class="line"># print(zeros_df)</span><br><span class="line"></span><br><span class="line"># 遍历cate_list,只需要循环三次</span><br><span class="line">for cate in cate_list:</span><br><span class="line">    # df[&#x27;title&#x27;].str.contains(cate)返回的是一个布尔型数组，行数与zeros_df相同，列数为三列，</span><br><span class="line">    # 包含cate的那一列为True,具体可见5.62布尔索引章节</span><br><span class="line">    zeros_df[cate][df[&#x27;title&#x27;].str.contains(cate)] = 1</span><br><span class="line"></span><br><span class="line"># print(zeros_df)</span><br><span class="line"></span><br><span class="line"># 统计邮寄类型的数量</span><br><span class="line">sum_ret = zeros_df.sum(axis=0)</span><br><span class="line">print(sum_ret)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd, numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;911.csv&#x27;)</span><br><span class="line"># #显示所有行</span><br><span class="line">pd.set_option(&#x27;display.max_rows&#x27;, None)</span><br><span class="line">print(df.head())</span><br><span class="line">print(df.info())</span><br><span class="line"></span><br><span class="line"># to_list()将序列转换为数组</span><br><span class="line">temp_list = df[&#x27;title&#x27;].str.split(&#x27;:&#x27;).to_list()</span><br><span class="line"></span><br><span class="line"># print(temp_list)</span><br><span class="line"># 遍历并取出第一项的分类</span><br><span class="line">cate_list = [i[0] for i in temp_list]</span><br><span class="line"># print(cate_list)</span><br><span class="line">cate_df = pd.DataFrame(np.array(cate_list).reshape((df.shape[0]), 1), columns=[&#x27;cate&#x27;])</span><br><span class="line">print(cate_df)</span><br><span class="line"># 添加一列，列索引为cate</span><br><span class="line">df[&#x27;cate&#x27;] = cate_df</span><br><span class="line"># print(df[&#x27;cate&#x27;])</span><br><span class="line">print(df.groupby(by=&#x27;cate&#x27;).count()[&#x27;title&#x27;])</span><br></pre></td></tr></table></figure><h2 id="16-pandas中的时间序列">16.pandas中的时间序列</h2><p><mark>生成一段时间范围</mark></p><p><code>pd.date_range(start=None, end=None, periods=None, freq='D')</code></p><p>start和end以及freq配合能够生成start和end范围内以频率freq的一组时间索引</p><p>start和periods以及freq配合能够生成从start开始的频率为freq的periods个时间索引</p><p><img src="https://img-blog.csdnimg.cn/94cf1dc007ba4c459281320984f69db1.png#pic_center" alt="图片23"></p><p><mark>关于频率的更多缩写</mark></p><p><img src="https://img-blog.csdnimg.cn/4615b163445f4fd8a3e88cdf7cfc452a.png#pic_center" alt="图片24"></p><p><mark>在DataFrame中使用时间序列</mark></p><p><code>index=pd.date_range(&quot;20170101&quot;,periods=10)</code></p><p><code>df = pd.DataFrame(np.random.rand(10),index=index)</code></p><p>回到最开始的911数据的案例中，我们可以使用pandas提供的方法把时间字符串转化为时间序列</p><p><code>df[&quot;timeStamp&quot;] = pd.to_datetime(df[&quot;timeStamp&quot;],format=&quot;&quot;)</code></p><p>format参数大部分情况下可以不用写，但是对于pandas无法格式化的时间字符串，我们可以使用该参数，比如包含中文</p><p>那么问题来了：</p><p>我们现在要统计每个月或者每个季度的次数怎么办呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">df = pd.read_csv(&#x27;911.csv&#x27;)</span><br><span class="line">#显示所有列</span><br><span class="line">pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># #显示所有行</span><br><span class="line">pd.set_option(&#x27;display.max_rows&#x27;, None)</span><br><span class="line">print(df.info())</span><br><span class="line">print(df.head())</span><br><span class="line"># 将时间字符串转换为时间类型数据datetime64，以便进一步处理</span><br><span class="line">print(pd.to_datetime(df[&#x27;timeStamp&#x27;]).head())</span><br><span class="line"># 重新赋值df[&#x27;timeStamp&#x27;]</span><br><span class="line">df[&#x27;timeStamp&#x27;] = pd.to_datetime(df[&#x27;timeStamp&#x27;])</span><br><span class="line"># 将列timeStamp转换为行索引</span><br><span class="line">df.set_index(&#x27;timeStamp&#x27;,inplace=True)</span><br><span class="line">print(df.head())</span><br><span class="line"></span><br><span class="line"># 统计出911数据中不同月份电话次数</span><br><span class="line">count_by_month = df.resample(&#x27;M&#x27;).count()[&#x27;title&#x27;]</span><br><span class="line">print(count_by_month)</span><br><span class="line"></span><br><span class="line">_x = count_by_month.index</span><br><span class="line">_y = count_by_month.values</span><br><span class="line">print(_x)</span><br><span class="line">print(_y)</span><br><span class="line">_x = [i.strftime(&#x27;%Y%m%d&#x27;) for i in _x]</span><br><span class="line">plt.figure(figsize=(20,8), dpi=80)</span><br><span class="line">plt.plot(_x,_y)</span><br><span class="line"># plt.plot(range(len(_x)),_y)</span><br><span class="line">plt.xticks(_x,rotation=45)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="17-pandas重采样">17.pandas重采样</h2><p><img src="https://img-blog.csdnimg.cn/b7551d9e0d7a43e09dd27e6fbc66121d.png#pic_center" alt="图片25"></p><p><mark>示例</mark></p><p>1.统计出911数据中不同月份电话次数的变化情况</p><p>2.统计出911数据中不同月份不同类型的电话的次数的变化情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import pandas as pd,numpy as np</span><br><span class="line">df = pd.read_csv(&#x27;911.csv&#x27;)</span><br><span class="line"># 重新赋值df[&#x27;timeStamp&#x27;]</span><br><span class="line">df[&#x27;timeStamp&#x27;] = pd.to_datetime(df[&#x27;timeStamp&#x27;])</span><br><span class="line">#添加列，表示分类</span><br><span class="line">temp_list = df[&quot;title&quot;].str.split(&quot;: &quot;).tolist()</span><br><span class="line">cate_list = [i[0] for i in temp_list]</span><br><span class="line"># 创建列</span><br><span class="line">df[&quot;cate&quot;] = pd.DataFrame(np.array(cate_list).reshape((df.shape[0],1)))</span><br><span class="line"># 将时间列转化为索引</span><br><span class="line">df.set_index(&quot;timeStamp&quot;,inplace=True)</span><br><span class="line">print(df.head(1))</span><br><span class="line">dk = df.groupby(&#x27;cate&#x27;)</span><br><span class="line">print(dk)</span><br><span class="line">plt.figure(figsize=(20, 8), dpi=80)</span><br><span class="line">for group_name,group_data in dk:</span><br><span class="line">    print(group_name,group_data)</span><br><span class="line">    # 对不同的分类都进行绘图</span><br><span class="line">    count_by_month = group_data.resample(&quot;M&quot;).count()[&quot;title&quot;]</span><br><span class="line">    # 画图</span><br><span class="line">    _x = count_by_month.index</span><br><span class="line">    print(_x)</span><br><span class="line">    _y = count_by_month.values</span><br><span class="line">    print(_y)</span><br><span class="line">    _x = [i.strftime(&quot;%Y%m%d&quot;) for i in _x]</span><br><span class="line"></span><br><span class="line">    plt.plot(range(len(_x)), _y, label=group_name)</span><br><span class="line"></span><br><span class="line">plt.xticks(range(len(_x)), _x, rotation=45)</span><br><span class="line">plt.legend(loc=&quot;best&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>现在我们有北上广、深圳、和沈阳5个城市空气质量数据，请绘制出5个城市的PM2.5随时间的变化情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">import pandas as pd</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">file_path = &quot;./PM2.5/BeijingPM20100101_20151231.csv&quot;</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(file_path)</span><br><span class="line">print(df.head())</span><br><span class="line">print(df.info())</span><br><span class="line"># 把分开的时间字符串通过periodIndex的方法转化为pandas的时间类型</span><br><span class="line">period = pd.PeriodIndex(year=df[&quot;year&quot;], month=df[&quot;month&quot;], day=df[&quot;day&quot;], hour=df[&quot;hour&quot;], freq=&quot;H&quot;)</span><br><span class="line"># 增加一列df[&quot;datetime&quot;]</span><br><span class="line">df[&quot;datetime&quot;] = period</span><br><span class="line">print(df.head(10))</span><br><span class="line">#</span><br><span class="line"># 把datetime 设置为索引</span><br><span class="line">df.set_index(&quot;datetime&quot;, inplace=True)</span><br><span class="line">#</span><br><span class="line"># 进行降采样,如果按日来排序，数据图不好看，按月份太稀疏，按日太绸</span><br><span class="line">df = df.resample(&quot;7D&quot;).mean()</span><br><span class="line">print(df.head())</span><br><span class="line"># 处理缺失数据，删除缺失数据</span><br><span class="line">print(df[&quot;PM_US Post&quot;])</span><br><span class="line"># dropna()该函数主要用于滤除缺失数据。</span><br><span class="line"># 如果是Series,则返回一个仅含非空数据和索引值的Series，默认丢弃含有缺失值的行。</span><br><span class="line"># 美国数据</span><br><span class="line">data = df[&quot;PM_US Post&quot;].dropna()  # 使用降采样后，会计算均值，这里再使用dropna()过滤空值意义不大</span><br><span class="line"># 中国数据</span><br><span class="line">data_china = df[&quot;PM_Nongzhanguan&quot;]</span><br><span class="line"></span><br><span class="line">print(data_china.head(100))</span><br><span class="line">#画图</span><br><span class="line"></span><br><span class="line">_x = data.index</span><br><span class="line">_x = [i.strftime(&quot;%Y%m%d&quot;) for i in _x]</span><br><span class="line"># 取中国PM2.5数据</span><br><span class="line">_x_china = [i.strftime(&quot;%Y%m%d&quot;) for i in data_china.index]</span><br><span class="line">print(len(_x_china),len(_x_china))</span><br><span class="line">_y = data.values</span><br><span class="line">_y_china = data_china.values</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(20,8),dpi=80)</span><br><span class="line"></span><br><span class="line">plt.plot(range(len(_x)),_y,label=&quot;US_POST&quot;,alpha=0.7)</span><br><span class="line">plt.plot(range(len(_x_china)),_y_china,label=&quot;CN_POST&quot;,alpha=0.7)</span><br><span class="line"></span><br><span class="line">plt.xticks(range(0,len(_x_china),10),list(_x_china)[::10],rotation=45)</span><br><span class="line"></span><br><span class="line">plt.legend(loc=&quot;best&quot;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于多信息融合的疲劳驾驶检测系统</title>
      <link href="/2022/08/02/%E7%96%B2%E6%80%81%E6%A3%80%E6%B5%8B/"/>
      <url>/2022/08/02/%E7%96%B2%E6%80%81%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-眨眼检测原理">1.眨眼检测原理</h2><p>基于dlib人脸识别68特征点检测、分别获取左右眼面部标志的索引，通过opencv对视频流进行灰度化处理，检测出人眼的位置信息。人脸特征点检测用到了dlib，dlib有两个关键函数：dlib.get_frontal_face_detector()和dlib.shape_predictor(predictor_path)。</p><p>前者是内置的人脸检测算法，检测人脸区域的界限后者是用来检测一个区域内的特征点，并输出这些特征点的坐标，它需要一个预先训练好的模型（通过文件路径的方法传入），才能正常工作。使用开源模型shape_predictor_68_face_landmarks.dat，可以得到68个特征点位置的坐标</p><p><a href="https://pypi.org/simple/dlib/">点我下载开源数据集</a></p><p>基本原理：计算 眼睛长宽比EAR.当人眼在正常状态下时，EAR在某个值上下波动，当人眼闭合时，EAR迅速下降。所以我们认为当EAR低于某个阈值时，眼睛处于闭合状态。为检测眨眼次数，我们设置了阈值为0.2，如果当前帧两双眼睛宽高比的平均值小于0.2，则加1，如果连续3次都小于阈值，则表示进行了一次眨眼活动。</p><p><img src="https://img-blog.csdnimg.cn/20191211162451238.png" alt="在这里插入图片描述"></p><p>（68点landmark中可以看到37-42为左眼，43-48为右眼）</p><p><img src="https://img-blog.csdnimg.cn/20191210164401726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1bmd1ZGFmYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>右眼开合度可以通过以下公式得到（左眼同理）：</p><p><img src="https://img-blog.csdnimg.cn/2019121016443063.png#pic_center" alt="在这里插入图片描述"></p><p>通过计算38、39、42、41的纵坐标、37、40的横坐标来计算眼睛的睁开度。如：1/2*[(y42+y41)-(y38+y39)]/(x40-x37)通过一个阈值确定眼睛是睁开还是闭上。也可以将这个值与初始的值的比值作为睁开度，根据不同程度来进行比较。睁开度从大到小为进入闭眼期，从小到大为进入睁眼期，计算 最长闭眼时间（可用帧数来代替）闭眼次数为进入闭眼、进入睁眼的次数 。</p><p>主要代码思路</p><p>第一步：使用dlib.get_frontal_face_detector() 获得脸部位置检测器第二步：使用dlib.shape_predictor获得脸部特征位置检测器第三步：分别获取左右眼面部标志的索引第四步：打开cv2 本地摄像头第五步：从视频流进行循环，读取图片，并对图片做维度扩大，并进灰度化第六步：使用detector(gray, 0) 进行脸部位置检测第七步：循环脸部位置信息，使用predictor(gray, rect)获得脸部特征位置的信息第八步：将脸部特征信息转换为数组array的格式第九步：提取左眼和右眼坐标第十步：构造函数计算左右眼的EAR值，使用平均值作为最终的EAR<br>第十一步：使用cv2.convexHull获得凸包位置，使用drawContours画出轮廓位置进行画图操作第十二步：进行画图操作，用矩形框标注人脸第十三步：分别计算左眼和右眼的评分求平均作为最终的评分，如果小于阈值，则加1，如果连续3次都小于阈值，则表示进行了一次眨眼活动第十四步：进行画图操作，68个特征点标识第十五步：进行画图操作，同时使用cv2.putText将眨眼次数进行显示</p><h2 id="2-打哈欠检测原理">2.打哈欠检测原理</h2><p>嘴部主要取六个参考点：</p><p><img src="https://img-blog.csdnimg.cn/20191211181733274.png#pic_center" alt="在这里插入图片描述"></p><p>打哈欠可利用嘴巴处通过计算51、59、53、57、的纵坐标、49、55的横坐标来计算眼睛的睁开度。如：1/2*[(y51+y53)-(y59+y57)]/(x55-x49)点的距离来判断是否张嘴及张嘴时间，从而确定人是否是在打哈欠，同时这个阈值应当合理，能够与正常说话或哼歌区分开来。</p><p>同眼睛相类似方法求嘴部欧式距离：</p><p><img src="https://img-blog.csdnimg.cn/20191211162451238.png" alt="在这里插入图片描述"></p><p><mark>主要代码思路</mark></p><p>Step1:提取帧图像检测人脸，嘴部粗定位进行肤色分割；<br>Step2: 嘴部精确定位，获取嘴部欧式距离K1，若k1大于阈值T1，则Step3,并且count+1；否则count=0回到step1，检测下一帧。<br>Step3: 统计哈欠特征值count,当count超过阈值3,则记作打一次哈欠，保存count到Yawn，Yawn(i)=count，count=0（count清0）回到Step1，否则的话也直接转回Step1。</p><h2 id="3-瞌睡点头检测原理">3.瞌睡点头检测原理</h2><p>采用Head Pose Estimation(头部姿态估计) 算法,该算法的步骤一般为：2D人脸关键点检测；3D人脸模型匹配；求解3D点和对应2D点的转换关系；根据旋转矩阵求解欧拉角</p><p><a href="https://developer.aliyun.com/article/674048">https://developer.aliyun.com/article/674048</a></p><p><a href="https://blog.csdn.net/lql0716/article/details/72597719">https://blog.csdn.net/lql0716/article/details/72597719</a></p><p>具体原理请看上面那两篇博客，网上有开源代码(如下)，大神已经帮我们搞好了，我们拿来直接用就行，最后得到欧拉角</p><p><a href="https://developer.aliyun.com/article/674048">点我查看参考代码</a></p><p><mark>主要代码思路</mark></p><p>头部姿态判断打瞌睡得到实时头部姿态的旋转角度过后,如下所示为头部旋转角度的3个参数Yaw,Pitch和Roll的示意图,驾驶员在打瞌睡时，显然头部会做类似于点头和倾斜的动作.而根据一般人的打瞌睡时表现出来的头部姿态，显然很少会在Yaw上有动作，而主要集中在Pitch和Roll的行为.设定参数阈值为0.3,在一个时间段内10 s内，当I PitchI≥20°或者|Rolll≥20°的时间比例超过0.3时,就认为驾驶员处于点头打瞌睡的状态</p><p><img src="https://img-blog.csdnimg.cn/20191212141457194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1bmd1ZGFmYQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-多信息融合的疲劳判断">4.多信息融合的疲劳判断</h2><p>我们分别计算出单位时间内瞌睡点头的频率，眨眼频率以及打哈欠的频率分别赋予他们不同的权值，采用信息融合的方式进行综合打分，最后根据最终分数，设置疲劳等级，分别为轻度疲劳，中度疲劳和重度疲劳，相应的做出报警等操作</p><h2 id="5-效果展示">5.效果展示</h2><h3 id="5-1ui界面设计">5.1ui界面设计</h3><p>[<img src="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue%20driving%20detection%20system/images/123.png" alt="img">](<a href="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue">https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue</a> driving detection system/images/123.png)</p><h3 id="5-2效果演示">5.2效果演示</h3><p>[<img src="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue%20driving%20detection%20system/images/%E6%BC%94%E7%A4%BA%E7%94%BB%E9%9D%A2.png" alt="img">](<a href="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue">https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue</a> driving detection system/images/演示画面.png)</p><h3 id="5-3报表界面部分演示">5.3报表界面部分演示</h3><p>[<img src="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue%20driving%20detection%20system/images/%E6%89%87%E5%BD%A2%E5%9B%BE.png" alt="img">](<a href="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue">https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue</a> driving detection system/images/扇形图.png)</p><p>[<img src="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue%20driving%20detection%20system/images/%E6%8A%98%E7%BA%BF%E5%9B%BE.png" alt="img">](<a href="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue">https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue</a> driving detection system/images/折线图.png)</p><h2 id="6-项目进展">6.项目进展</h2><table><thead><tr><th><s><strong>眨眼检测</strong></s></th><th><strong>DONE</strong></th></tr></thead><tbody><tr><td><s><strong>打哈欠检测</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>瞌睡点头检测</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>实时眨眼频率计算</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>实时打哈欠频率</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>实时瞌睡点头频率</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>疲劳程度的计算</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>疲劳程度划分</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>UI界面设计</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>FPS计算以及语音播报</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>报表界面设计</strong></s></td><td><strong>DONE</strong></td></tr></tbody></table><h2 id="7-界面参数介绍">7.界面参数介绍</h2><table><thead><tr><th>Blinks</th><th>眨眼次数</th></tr></thead><tbody><tr><td><strong>Yawning</strong></td><td><strong>打哈欠次数</strong></td></tr><tr><td><strong>Nod</strong></td><td><strong>瞌睡点头次数</strong></td></tr><tr><td><strong>Blink Frequency</strong></td><td><strong>实时眨眼频率</strong></td></tr><tr><td><strong>Yawing Frequency</strong></td><td><strong>实时打哈欠频率</strong></td></tr><tr><td><strong>Nod Frequency</strong></td><td><strong>实时瞌睡点头频率</strong></td></tr><tr><td><strong>Score</strong></td><td><strong>疲劳程度</strong></td></tr><tr><td><strong>FPS</strong></td><td><strong>视频帧率</strong></td></tr></tbody></table><h2 id="8-文件介绍">8.文件介绍</h2><p>main.py-------------------------主程序</p><p>sats2.py--------------------------报表界面制作(pyecharts,感觉还是挺好用的，具体操作可以看官网文档，中国人开发的库值得推荐)</p><p><a href="https://gallery.pyecharts.org/#/Bar/stack_bar_percent">pyecharts gallery</a> <a href="https://pyecharts.org/#/zh-cn/intro">pyecharts操作手册</a></p><p>images目录下存放图片png以及ico</p><p>model目录下存放68人脸关键点模型</p><p>fatigue_detect.html-----------------可视化报表</p><h2 id="9-项目所有源代码获取">9.项目所有源代码获取</h2><p><a href="https://github.com/BillySturate/Fatigue-driving-detection-system-based-on-opencv-dlib">https://github.com/BillySturate/Fatigue-driving-detection-system-based-on-opencv-dlib</a></p><h2 id="10-参考博客">10.参考博客</h2><p><a href="https://blog.csdn.net/cungudafa/article/details/103477960">https://blog.csdn.net/cungudafa/article/details/103477960</a></p><p><a href="https://blog.csdn.net/cungudafa/article/details/103499230">https://blog.csdn.net/cungudafa/article/details/103499230</a></p><p><a href="https://blog.csdn.net/cungudafa/article/details/103496881">https://blog.csdn.net/cungudafa/article/details/103496881</a></p><p><a href="https://blog.csdn.net/lql0716/article/details/72597719">https://blog.csdn.net/lql0716/article/details/72597719</a></p><p><a href="https://developer.aliyun.com/article/674048">https://developer.aliyun.com/article/674048</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy详解</title>
      <link href="/2022/07/28/Numpy/"/>
      <url>/2022/07/28/Numpy/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1hx411d7jb?spm_id_from=333.337.search-card.all.click&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><h2 id="1-什么是numpy">1.什么是numpy</h2><p>一个在Python中做科学计算的基础库，重在数值计算，也是大部分PYTHON科学计算库的基础库，多用于在大型、多维数组上执行数值运算</p><p><mark>为什么学习numpy?</mark></p><p>1.快速</p><p>2.方便</p><p>3.科学计算的基础库</p><h2 id="2-numpy基础">2.numpy基础</h2><h3 id="2-1numpy创建数组-矩阵">2.1numpy创建数组(矩阵)</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acb56f6.png" alt="图片1.png"></p><h3 id="2-2numpy中常见的更多数据类型">2.2numpy中常见的更多数据类型</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acbefda.png" alt="图片2.png"></p><h3 id="2-3数据类型的操作">2.3数据类型的操作</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acc056e.png" alt="图片3.png"></p><p><mark>代码示例</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">import numpy as np</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">#使用numpy生成数组,得到ndarray的类型</span><br><span class="line">t1 = np.array([1,2,3,])</span><br><span class="line">print(t1)</span><br><span class="line">print(type(t1))</span><br><span class="line"></span><br><span class="line">t2 = np.array(range(10))</span><br><span class="line">print(t2)</span><br><span class="line">print(type(t2))</span><br><span class="line"></span><br><span class="line">t3 = np.arange(4,10,2)</span><br><span class="line">print(t3)</span><br><span class="line">print(type(t3))</span><br><span class="line"></span><br><span class="line">print(t3.dtype)</span><br><span class="line">print(&quot;*&quot;*100)</span><br><span class="line">#numpy中的数据类型</span><br><span class="line"></span><br><span class="line">t4 = np.array(range(1,4),dtype=&quot;i1&quot;)</span><br><span class="line">print(t4)</span><br><span class="line">print(t4.dtype)</span><br><span class="line"></span><br><span class="line">##numpy中的bool类型</span><br><span class="line">t5 = np.array([1,1,0,1,0,0],dtype=bool)</span><br><span class="line">print(t5)</span><br><span class="line">print(t5.dtype)</span><br><span class="line"></span><br><span class="line">#调整数据类型</span><br><span class="line">t6 = t5.astype(&quot;int8&quot;)</span><br><span class="line">print(t6)</span><br><span class="line">print(t6.dtype)</span><br><span class="line"></span><br><span class="line">#numpy中的小数</span><br><span class="line">t7 = np.array([random.random() for i in range(10)])</span><br><span class="line">print(t7)</span><br><span class="line">print(t7.dtype)</span><br><span class="line"></span><br><span class="line">t8 = np.round(t7,2)</span><br><span class="line">print(t8)</span><br></pre></td></tr></table></figure><h3 id="2-4数组的形状">2.4数组的形状</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acbdfef.png" alt="图片4.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013acc138e.png" alt="图片5.png"></p><h3 id="2-5数组和数的计算">2.5数组和数的计算</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acc50d8.png" alt="图片6.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013acc136b.png" alt="图片7.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013acc4f33.png" alt="图片8.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013acc5caa.png" alt="图片9.png"></p><h3 id="2-7广播原则">2.7广播原则</h3><p><img src="https://bu.dusays.com/2022/12/31/63b015961bd39.png" alt="图片10.png"></p><p>怎么理解呢?</p><p>可以把维度指的是shape所对应的数字个数</p><p>那么问题来了:</p><p>shape为(3,3,3)的数组能够和(3,2)的数组进行计算么?   <mark>不能</mark></p><p>shape为(3,3,2)的数组能够和(3,2)的数组进行计算么?<mark>能</mark></p><p>有什么好处呢?</p><p>举个例子:每列的数据减去列的平均值的结果</p><h3 id="2-8轴-axis">2.8轴(axis)</h3><p>在numpy中可以理解为方向,使用0,1,2…数字表示,对于一个一维数组,只有一个0轴,对于2维数组(shape(2,2)),有0轴和1轴,对于三维数组(shape(2,2, 3)),有0,1,2轴</p><p>有了轴的概念之后,我们计算会更加方便,比如计算一个2维数组的平均值,必须指定是计算哪个方向上面的数字的平均值</p><p>那么问题来了:</p><p>在前面的知识,轴在哪里?</p><p>回顾np.arange(0,10).reshape((2,5)),reshpe中2表示0轴长度(包含数据的条数)为2,1轴长度为5,2X5一共10个数据</p><p><mark>二维数组的轴</mark></p><p><img src="https://img-blog.csdnimg.cn/e9bbdf8a2c874bac9c160dfaf8e866c8.png#pic_center" alt=""></p><p><mark>三维数组的轴</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b013ada241e.png" alt="图片12.png"></p><h3 id="2-9numpy读取数据">2.9numpy读取数据</h3><p>CSV:Comma-Separated Value,逗号分隔值文件</p><p>显示：表格状态</p><p>源文件：换行和逗号分隔行列的格式化文本,每一行的数据表示一条记录</p><p>由于csv便于展示,读取和写入,所以很多地方也是用csv的格式存储和传输中小型的数据,为了方便教学,我们会经常操作csv格式的文件,但是操作数据库中的数据也是很容易的实现的</p><p><code>np.loadtxt(fname,dtype=np.float,delimiter=None,skiprows=0,usecols=None,unpack=False)</code></p><p><img src="https://bu.dusays.com/2022/12/31/63b013adc062d.png" alt="图片13.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013adf27fc.png" alt="图片14.png"></p><h3 id="2-10numpy中的转置">2.10numpy中的转置</h3><p>转置是一种变换,对于numpy中的数组来说,就是在对角线方向交换数据,目的也是为了更方便的去处理数据</p><p><img src="https://bu.dusays.com/2022/12/31/63b013ae1a505.png" alt="图片15.png"></p><p>以上的三种方法都可以实现二维数组的转置的效果,大家能够看出来,转置和交换轴的效果一样</p><p><mark>示例</mark></p><p>现在这里有一个英国和美国各自youtube1000多个视频的点击,喜欢,不喜欢,评论数量([“views”,“likes”,“dislikes”,“comment_total”])的csv,运用刚刚所学习的只是,我们尝试来对其进行操作，那么,结合之前的所学的matplotlib把英国和美国的数据呈现出来?</p><p>看到这个问题,我们应该考虑什么?</p><p>1.我们想要反映出什么样的结果,解决什么问题?</p><p>2.选择什么样的呈现方式?</p><p>3.数据还需要做什么样的处理?</p><p>4.写代码</p><h3 id="2-11numpy索引和切片">2.11numpy索引和切片</h3><p>对于刚刚加载出来的数据,我如果只想选择其中的某一列(行)我们应该怎么做呢?</p><p>其实操作很简单,和python中列表的操作一样</p><p><img src="https://bu.dusays.com/2022/12/31/63b013ae34081.png" alt="图片16.png"></p><p><mark>代码示例</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">us_file_path = &quot;./youtube_video_data/US_video_data_numbers.csv&quot;</span><br><span class="line">uk_file_path = &quot;./youtube_video_data/GB_video_data_numbers.csv&quot;</span><br><span class="line"></span><br><span class="line"># t1 = np.loadtxt(us_file_path,delimiter=&quot;,&quot;,dtype=&quot;int&quot;,unpack=True)</span><br><span class="line">t2 = np.loadtxt(us_file_path,delimiter=&quot;,&quot;,dtype=&quot;int&quot;)</span><br><span class="line"></span><br><span class="line"># print(t1)</span><br><span class="line">print(t2)</span><br><span class="line"></span><br><span class="line">print(&quot;*&quot;*100)</span><br><span class="line"></span><br><span class="line">#取行</span><br><span class="line"># print(t2[2])</span><br><span class="line"></span><br><span class="line">#取连续的多行</span><br><span class="line"># print(t2[2:])</span><br><span class="line"></span><br><span class="line">#取不连续的多行</span><br><span class="line"># print(t2[[2,8,10]])</span><br><span class="line"></span><br><span class="line"># print(t2[1,:])</span><br><span class="line"># print(t2[2:,:])</span><br><span class="line"># print(t2[[2,10,3],:])</span><br><span class="line"></span><br><span class="line">#取列</span><br><span class="line"># print(t2[:,0])</span><br><span class="line"></span><br><span class="line">#取连续的多列</span><br><span class="line"># print(t2[:,2:])</span><br><span class="line"></span><br><span class="line">#取不连续的多列</span><br><span class="line"># print(t2[:,[0,2]])</span><br><span class="line"></span><br><span class="line">#去行和列，取第3行，第四列的值</span><br><span class="line"># a = t2[2,3]</span><br><span class="line"># print(a)</span><br><span class="line"># print(type(a))</span><br><span class="line"></span><br><span class="line">#取多行和多列，取第3行到第五行，第2列到第4列的结果</span><br><span class="line">#去的是行和列交叉点的位置</span><br><span class="line">b = t2[2:5,1:4]</span><br><span class="line"># print(b)</span><br><span class="line"></span><br><span class="line">#取多个不相邻的点</span><br><span class="line">#选出来的结果是（0，0） （2，1） （2，3）</span><br><span class="line">c = t2[[0,2,2],[0,1,3]]</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h3 id="2-12numpy中数值的修改">2.12numpy中数值的修改</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013ae5a6c8.png" alt="图片17.png"></p><h3 id="2-13numpy中布尔索引">2.13numpy中布尔索引</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013ae866a9.png" alt="图片18.png"></p><h3 id="2-14numpy中三元运算符">2.14numpy中三元运算符</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013aea983a.png" alt="图片19.png"></p><h3 id="2-15numpy中的clip-裁剪">2.15numpy中的clip(裁剪)</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013aec2565.png" alt="图片20.png"></p><p>观察上方的操作：</p><p>小于10的替换为10，大于18的替换为了18，nan不会被替换</p><h3 id="2-16numpy中的nan和inf">2.16numpy中的nan和inf</h3><p>nan(NAN,Nan):not a number表示不是一个数字</p><p>什么时候numpy中会出现nan：</p><p>当我们读取本地的文件为float的时候，如果有缺失，就会出现nan</p><p>当做了一个不合适的计算的时候(比如无穷大(inf)减去无穷大)</p><p>inf(-inf,inf):infinity,inf表示正无穷，-inf表示负无穷</p><p>什么时候回出现inf包括（-inf，+inf）</p><p>比如一个数字除以0，（python中直接会报错，numpy中是一个inf或者-inf）</p><p><img src="https://bu.dusays.com/2022/12/31/63b013aee5dab.png" alt="图片21.png"></p><p><mark>numpy中的nan的注意点</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b013af24d7d.png" alt="图片22.png"></p><p>那么问题来了，在一组数据中单纯的把nan替换为0，合适么？会带来什么样的影响？</p><p>比如，全部替换为0后，替换之前的平均值如果大于0，替换之后的均值肯定会变小，所以更一般的方式是把缺失的数值替换为均值（中值）或者是直接删除有缺失值的一行</p><h3 id="2-17numpy中常用统计函数">2.17numpy中常用统计函数</h3><p>求和：t.sum(axis=None)</p><p>均值：t.mean(a,axis=None) 受离群点的影响较大</p><p>中值：np.median(t,axis=None)</p><p>最大值：t.max(axis=None)</p><p>最小值：t.min(axis=None)</p><p>极值：np.ptp(t,axis=None) 即最大值和最小值只差</p><p>标准差：t.std(axis=None)</p><p>默认返回多维数组的全部的统计结果,如果指定axis则返回一个当前轴上的结果</p><h3 id="2-18-一个小案例">2.18 一个小案例</h3><p>t中存在nan值，如何操作把其中的nan填充为每一列的均值</p><p>t = array([[ 0.,  1.,  2.,  3.,  4.,  5.],</p><p>​    [ 6.,  7., nan,  9., 10., 11.],</p><p>​    [ 12., 13., 14., nan, 16., 17.],</p><p>​    [ 18., 19., 20., 21., 22., 23.]])</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">def Fill_Ndarry(r1):</span><br><span class="line">    for i in range(r1.shape[1]):</span><br><span class="line">        temp_col = r1[:, i]</span><br><span class="line">        nan_num = np.count_nonzero(temp_col != temp_col)</span><br><span class="line">        if nan_num != 0:</span><br><span class="line">            temp_not_nan = temp_col[temp_col == temp_col]</span><br><span class="line">            # print(temp_not_nan)</span><br><span class="line">            temp_col[np.isnan(temp_col)] = temp_not_nan.mean()</span><br><span class="line">            # print(temp_col[np.isnan(temp_col)])</span><br><span class="line">    return r1</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    t1 = np.arange(24).reshape((4, 6)).astype(&quot;float&quot;)</span><br><span class="line">    t1[1, 2:] = np.nan</span><br><span class="line">    print(t1)</span><br><span class="line">    t1 = Fill_Ndarry(t1)</span><br><span class="line">    print(t1)</span><br></pre></td></tr></table></figure><h3 id="2-19数组的拼接及行列交换">2.19数组的拼接及行列交换</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013af34138.png" alt="图片23.png"></p><p><mark>数组的行列交换</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b013af52fd3.png" alt="图片24.png"></p><p><mark>numpy更多好用的方法</mark></p><p>1.获取最大值最小值的位置</p><p>​ np.argmax(t,axis=0)</p><p>​ np.argmin(t,axis=1)</p><p>2.创建一个全0的数组: np.zeros((3,4))</p><p>3.创建一个全1的数组:np.ones((3,4))</p><p>4.创建一个对角线为1的正方形数组(方阵)：np.eye(3)</p><h3 id="2-20numpy生成随机数">2.20numpy生成随机数</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013af8130a.png" alt="图片25.png"></p><p><mark>分布的补充</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b013afbdc30.png" alt="图片26.png"></p><h3 id="2-21numpy的注意点copy和view">2.21numpy的注意点copy和view</h3><p>1.a=b 完全不复制，a和b相互影响</p><p>2.a = b[:],视图的操作，一种切片，会创建新的对象a，但是a的数据完全由b保管，他们两个的数据变化是一致的，</p><p>3.a = b.copy(),复制，a和b互不影响</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib详解</title>
      <link href="/2022/07/25/Matplotlib%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/07/25/Matplotlib%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1hx411d7jb?spm_id_from=333.337.search-card.all.click&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><h2 id="1-什么是matplotlib">1.什么是matplotlib</h2><p>matplotlib: 最流行的Python底层绘图库，主要做数据可视化图表,名字取材于MATLAB，模仿MATLAB构建</p><h2 id="2-样例">2.样例</h2><h3 id="2-1折线图">2.1折线图</h3><p>eg：假设一天中每隔两个小时(range(2,26,2))的气温(℃)分别是[15,13,14.5,17,20,25,26,26,27,22,18,15]</p><p><mark>matplotlib基本要点</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bc4084.png" alt="图片1.png"></p><p><mark>设置图片大小</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bca508.png" alt="图片2.png"></p><p><mark>调整X或者Y轴上的刻度</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bca5a2.png" alt="图片3.png"></p><p>那么问题来了:</p><p>​    如果列表a表示10点到12点的每一分钟的气温,如何绘制折线图观察每分钟气温的变化情况?</p><p>​    <code>a= [random.randint(20,35) for i in range(120)]</code></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd4ea9.png" alt="图片4.png"></p><p><mark>设置中文显示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd9667.png" alt="图片5.png"></p><p><mark>给图像添加描述信息</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd3f81.png" alt="图片6.png"></p><p><mark>最终代码展示</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager</span><br><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&quot;C:/Windows/Fonts/SimHei.ttf&quot;</span>, size=<span class="number">14</span>)</span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">120</span>)</span><br><span class="line">y = [random.randint(<span class="number">20</span>, <span class="number">35</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">120</span>)]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>), dpi=<span class="number">80</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">_x = x[::<span class="number">5</span>]</span><br><span class="line">_xtick_labels = [<span class="string">&quot;10点&#123;&#125;分&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>)]</span><br><span class="line">_xtick_labels += [<span class="string">&quot;11点&#123;&#125;分&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>)]</span><br><span class="line">plt.xticks(_x, _xtick_labels[::<span class="number">5</span>], rotation=<span class="number">45</span>, fontproperties=my_font)  <span class="comment"># rotation旋转的度数</span></span><br><span class="line"><span class="comment"># 添加描述信息</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;时间&quot;</span>, fontproperties=my_font)</span><br><span class="line">plt.ylabel(<span class="string">&quot;温度 单位(℃)&quot;</span>, fontproperties=my_font)</span><br><span class="line">plt.title(<span class="string">&quot;10点到12点每分钟的气温变化情况&quot;</span>, fontproperties=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>最终效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bddb36.png" alt="图片7.png"></p><p><mark>动手一练</mark></p><p>假设大家在30岁的时候,根据自己的实际情况,统计出来了你和你同桌各自从11岁到30岁每年交的女(男)朋友的数量如列表a和b,请在一个图中绘制出该数据的折线图,以便比较自己和同桌20年间的差异,同时分析每年交女(男)朋友的数量走势</p><p>a = [1,0,1,1,2,4,3,2,3,4,4,5,6,5,4,3,3,1,1,1]</p><p>b = [1,0,3,1,2,2,3,3,2,1 ,2,1,1,1,1,1,1,1,1,1]</p><p>要求:</p><p>y轴表示个数</p><p>x轴表示岁数,比如11岁,12岁等</p><p><mark>代码展示</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&quot;C:/Windows/Fonts/SimHei.ttf&quot;</span>, size=<span class="number">14</span>)</span><br><span class="line">y1 = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">y2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">11</span>, <span class="number">31</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>), dpi=<span class="number">80</span>)</span><br><span class="line">plt.plot(x, y1, label=<span class="string">&quot;自己&quot;</span>)</span><br><span class="line">plt.plot(x, y2, label=<span class="string">&quot;同桌&quot;</span>)</span><br><span class="line">_xtick = [<span class="string">&quot;&#123;&#125;岁&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">plt.xticks(x, _xtick, rotation=<span class="number">45</span>, fontproperties=my_font)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制网格</span></span><br><span class="line">plt.grid(alpha=<span class="number">0.4</span>)</span><br><span class="line">plt.legend(prop=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>在上一个案例中如果大家希望自定义绘制图形的风格怎么办?</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd369f.png" alt="图片8.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd7729.png" alt="图片9.png"></p><p><mark>虽然线条有了不一样的风格,但是读者还是不知道那条线是谁怎么办?</mark></p><p><strong>为每条线添加图例</strong></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bdbff9.png" alt="图片10.png"></p><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120c91049.png" alt="图片11.png"></p><p><mark>总结:前面我们都做了什么</mark>？</p><p>1.绘制了折线图(plt.plot)</p><p>2.设置了图片的大小和分辨率(plt.figure)</p><p>3.实现了图片的保存(plt.savefig)</p><p>4.设置了xy轴上的刻度和字符串(xticks)</p><p>5.解决了刻度稀疏和密集的问题(xticks)</p><p>6.设置了标题,xy轴的lable(title,xlable,ylable)</p><p>7.设置了字体(font_manager. fontProperties,matplotlib.rc)</p><p>8.在一个图上绘制多个图形(plt多次plot即可)</p><p>9.为不同的图形添加图例</p><p>以上统统很重要</p><h3 id="2-2散点图">2.2散点图</h3><p>eg:假设通过爬虫你获取到了北京2016年3,10月份每天白天的最高气温(分别位于列表a,b),那么此时如何寻找出气温和随时间(天)变化的某种规律?</p><p>a = [11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23]</p><p>b = [26,26,28,19,21,17,16,19,18,20,20,19,22,23,17,20,21,20,22,15,11,15,5,13,17,10,11,13,12,13,6]</p><p><mark>代码展示</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=&quot;C:/Windows/Fonts/SimHei.ttf&quot;, size=14)</span><br><span class="line">y_3 = [11, 17, 16, 11, 12, 11, 12, 6, 6, 7, 8, 9, 12, 15, 14, 17, 18, 21, 16, 17, 20, 14, 15, 15, 15, 19, 21, 22, 22,</span><br><span class="line">       22, 23]</span><br><span class="line">y_10 = [26, 26, 28, 19, 21, 17, 16, 19, 18, 20, 20, 19, 22, 23, 17, 20, 21, 20, 22, 15, 11, 15, 5, 13, 17, 10, 11, 13,</span><br><span class="line">        12, 13, 6]</span><br><span class="line">x_3 = range(1, 32)</span><br><span class="line">x_10 = range(41, 72)</span><br><span class="line">x = list(x_3) + list(x_10)</span><br><span class="line">plt.figure(figsize=(20, 10), dpi=80)</span><br><span class="line">plt.scatter(x_3, y_3, label=&quot;3月&quot;)</span><br><span class="line">plt.scatter(x_10, y_10, label=&quot;10月&quot;)</span><br><span class="line">_xtick = [&quot;3月&#123;&#125;日&quot;.format(i) for i in x_3]</span><br><span class="line">_xtick += [&quot;10月&#123;&#125;日&quot;.format(i) for i in x_3]</span><br><span class="line">plt.xticks(x[::3], _xtick[::3], rotation=45, fontproperties=my_font)</span><br><span class="line">plt.xlabel(&quot;时间&quot;, fontproperties=my_font)</span><br><span class="line">plt.ylabel(&quot;温度&quot;, fontproperties=my_font)</span><br><span class="line">plt.title(&quot;标题&quot;, fontproperties=my_font)</span><br><span class="line">plt.legend(loc=&quot;upper left&quot;, prop=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120cabc50.png" alt="图片12.png"></p><h3 id="2-3条形图">2.3条形图</h3><p>eg:假设你获取到了2017年内地电影票房前20的电影(列表a)和电影票房数据(列表b),那么如何更加直观的展示该数据?</p><p>a = [“战狼2”,“速度与激情8”,“功夫瑜伽”,“西游伏妖篇”,“变形金刚5：最后的骑士”,“摔跤吧！爸爸”,“加勒比海盗5：死无对证”,“金刚：骷髅岛”,“极限特工：终极回归”,“生化危机6：终章”,“乘风破浪”,“神偷奶爸3”,“智取威虎山”,“大闹天竺”,“金刚狼3：殊死一战”,“蜘蛛侠：英雄归来”,“悟空传”,“银河护卫队2”,“情圣”,“新木乃伊”,]</p><p>b=[56.01,26.94,17.53,16.49,15.45,12.96,11.8,11.61,11.28,11.12,10.49,10.3,8.75,7.55,7.32,6.99,6.88,6.86,6.58,6.23] 单位:亿</p><p><img src="https://bu.dusays.com/2022/12/31/63b0120cc2aa6.png" alt="图片13.png"></p><p><mark>完整代码展示</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=&quot;C:/Windows/Fonts/SimHei.ttf&quot;, size=14)</span><br><span class="line">a = [&quot;战狼2&quot;, &quot;速度与激情8&quot;, &quot;功夫瑜伽&quot;, &quot;西游伏妖篇&quot;, &quot;变形金刚5：最后的骑士&quot;, &quot;摔跤吧！爸爸&quot;, &quot;加勒比海盗5：死无对证&quot;, &quot;金刚：骷髅岛&quot;, &quot;极限特工：终极回归&quot;, &quot;生化危机6：终章&quot;,</span><br><span class="line">     &quot;乘风破浪&quot;, &quot;神偷奶爸3&quot;, &quot;智取威虎山&quot;, &quot;大闹天竺&quot;, &quot;金刚狼3：殊死一战&quot;, &quot;蜘蛛侠：英雄归来&quot;, &quot;悟空传&quot;, &quot;银河护卫队2&quot;, &quot;情圣&quot;, &quot;新木乃伊&quot;, ]</span><br><span class="line"></span><br><span class="line">b = [56.01, 26.94, 17.53, 16.49, 15.45, 12.96, 11.8, 11.61, 11.28, 11.12, 10.49, 10.3, 8.75, 7.55, 7.32, 6.99, 6.88,</span><br><span class="line">     6.86, 6.58, 6.23]</span><br><span class="line">plt.figure(figsize=(20, 15), dpi=80)</span><br><span class="line">plt.bar(range(len(a)), b, width=0.3)</span><br><span class="line">plt.xticks(range(len(a)), a, rotation=90, fontproperties=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120cea641.png" alt="图片14.png"></p><p><mark>动手一练</mark></p><p>假设你知道了列表a中电影分别在2017-09-14(b_14), 2017-09-15(b_15), 2017-09-16(b_16)三天的票房,为了展示列表中电影本身的票房以及同其他电影的数据对比情况,应该如何更加直观的呈现该数据?</p><p>a = [“猩球崛起3：终极之战”,“敦刻尔克”,“蜘蛛侠：英雄归来”,“战狼2”]</p><p>b_16 = [15746,312,4497,319]</p><p>b_15 = [12357,156,2045,168]</p><p>b_14 = [2358,399,2358,362]</p><p><mark>代码展示</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=&quot;C:/Windows/Fonts/SimHei.ttf&quot;, size=14)</span><br><span class="line">a = [&quot;猩球崛起3：终极之战&quot;, &quot;敦刻尔克&quot;, &quot;蜘蛛侠：英雄归来&quot;, &quot;战狼2&quot;]</span><br><span class="line">b_16 = [15746, 312, 4497, 319]</span><br><span class="line">b_15 = [12357, 156, 2045, 168]</span><br><span class="line">b_14 = [2358, 399, 2358, 362]</span><br><span class="line">bar_width = 0.2</span><br><span class="line">x_14 = list(range(len(a)))</span><br><span class="line">x_15 = [i + bar_width for i in x_14]</span><br><span class="line">x_16 = [i + bar_width * 2 for i in x_14]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(20, 10), dpi=80)</span><br><span class="line">plt.bar(range(len(a)), b_14, width=bar_width, label=&quot;9月14日&quot;)</span><br><span class="line">plt.bar(x_15, b_15, width=bar_width, label=&quot;9月15日&quot;)</span><br><span class="line">plt.bar(x_16, b_16, width=bar_width, label=&quot;9月15日&quot;)</span><br><span class="line">plt.legend(prop=my_font)</span><br><span class="line">plt.xticks(x_15, a, fontproperties=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120d17a0a.png" alt="图片15.png"></p><h3 id="2-4直方图">2.4直方图</h3><p>eg:假设你获取了250部电影的时长(列表a中),希望统计出这些电影时长的分布状态(比如时长为100分钟到120分钟电影的数量,出现的频率)等信息,你应该如何呈现这些数据?</p><p>a=[131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, 142, 127, 130, 124, 101, 110, 116, 117, 110, 128, 128, 115, 99, 136, 126, 134, 95, 138, 117, 111,78, 132, 124, 113, 150, 110, 117, 86, 95, 144, 105, 126, 130,126, 130, 126, 116, 123, 106, 112, 138, 123, 86, 101, 99, 136,123, 117, 119, 105, 137, 123, 128, 125, 104, 109, 134, 125, 127,105, 120, 107, 129, 116, 108, 132, 103, 136, 118, 102, 120, 114,105, 115, 132, 145, 119, 121, 112, 139, 125, 138, 109, 132, 134,156, 106, 117, 127, 144, 139, 139, 119, 140, 83, 110, 102,123,107, 143, 115, 136, 118, 139, 123, 112, 118, 125, 109, 119, 133,112, 114, 122, 109, 106, 123, 116, 131, 127, 115, 118, 112, 135,115, 146, 137, 116, 103, 144, 83, 123, 111, 110, 111, 100, 154,136, 100, 118, 119, 133, 134, 106, 129, 126, 110, 111, 109, 141,120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126,114, 140, 103, 130, 141, 117, 106, 114, 121, 114, 133, 137, 92,121, 112, 146, 97, 137, 105, 98, 117, 112, 81, 97, 139, 113,134, 106, 144, 110, 137, 137, 111, 104, 117, 100, 111, 101, 110,105, 129, 137, 112, 120, 113, 133, 112, 83, 94, 146, 133, 101,131, 116, 111, 84, 137, 115, 122, 106, 144, 109, 123, 116, 111,111, 133, 150]</p><p><img src="https://bu.dusays.com/2022/12/31/63b0120d4a7c7.png" alt="图片16.png"></p><p><mark>代码展示</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=&quot;C:/Windows/Fonts/SimHei.ttf&quot;, size=14)</span><br><span class="line">a = [131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, 142, 127, 130, 124,</span><br><span class="line">     101, 110, 116, 117, 110, 128, 128, 115, 99, 136, 126, 134, 95, 138, 117, 111, 78, 132, 124, 113, 150, 110, 117, 86,</span><br><span class="line">     95, 144, 105, 126, 130, 126, 130, 126, 116, 123, 106, 112, 138, 123, 86, 101, 99, 136, 123, 117, 119, 105, 137,</span><br><span class="line">     123, 128, 125, 104, 109, 134, 125, 127, 105, 120, 107, 129, 116, 108, 132, 103, 136, 118, 102, 120, 114, 105, 115,</span><br><span class="line">     132, 145, 119, 121, 112, 139, 125, 138, 109, 132, 134, 156, 106, 117, 127, 144, 139, 139, 119, 140, 83, 110, 102,</span><br><span class="line">     123, 107, 143, 115, 136, 118, 139, 123, 112, 118, 125, 109, 119, 133, 112, 114, 122, 109, 106, 123, 116, 131, 127,</span><br><span class="line">     115, 118, 112, 135, 115, 146, 137, 116, 103, 144, 83, 123, 111, 110, 111, 100, 154, 136, 100, 118, 119, 133, 134,</span><br><span class="line">     106, 129, 126, 110, 111, 109, 141, 120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126, 114, 140, 103,</span><br><span class="line">     130, 141, 117, 106, 114, 121, 114, 133, 137, 92, 121, 112, 146, 97, 137, 105, 98, 117, 112, 81, 97, 139, 113, 134,</span><br><span class="line">     106, 144, 110, 137, 137, 111, 104, 117, 100, 111, 101, 110, 105, 129, 137, 112, 120, 113, 133, 112, 83, 94, 146,</span><br><span class="line">     133, 101, 131, 116, 111, 84, 137, 115, 122, 106, 144, 109, 123, 116, 111, 111, 133, 150]</span><br><span class="line"># 计算组数</span><br><span class="line">d = 3</span><br><span class="line">num_bins = (max(a) - min(a)) // d</span><br><span class="line">plt.figure(figsize=(20, 15), dpi=80)</span><br><span class="line">plt.hist(a, num_bins, density=True)</span><br><span class="line">plt.xticks(range(min(a), max(a) + d, d))</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120d5db0c.png" alt="图片17.png"></p><p><mark>matplotlib常见问题总结</mark></p><p>1.应该选择那种图形来呈现数据</p><p>2.matplotlib.plot(x,y)</p><p>3.matplotlib.bar(x,y)</p><p>4.matplotlib.scatter(x,y)</p><p>5.matplotlib.hist(data,bins,normed)</p><p>6.xticks和yticks的设置</p><p>7.label和titile,grid的设置</p><p>8.绘图的大小和保存图片</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt5.15.2中编译报错：“invalid use of incomplete type &#39;class Ui::xxx&#39;”的解决方法</title>
      <link href="/2022/07/17/QtUI/"/>
      <url>/2022/07/17/QtUI/</url>
      
        <content type="html"><![CDATA[<p>今天新建项目，用Qt连接数据库时，发现如下报错：</p><p><a href="https://bu.dusays.com/2022/12/31/63b0104259b03.png"><img src="https://bu.dusays.com/2022/12/31/63b0104259b03.png" alt="Snipaste_2022-07-17_20-10-30.png"></a></p><p>在网上找了很多解决方法，但是发现好像都不行，还是会报错，最后认真重新检查了一下文件，发现竟然是没有加头文件，然后把头文件</p><p>**#include “ui_mainwindow.h”**加上，如下图所示</p><p><a href="https://bu.dusays.com/2022/12/31/63b01057075ee.png"><img src="https://bu.dusays.com/2022/12/31/63b01057075ee.png" alt="Snipaste_2022-07-17_20-13-13.png"></a></p><p>然后再重新编译，成功运行</p><p><a href="https://bu.dusays.com/2022/12/31/63b0106e00925.png"><img src="https://bu.dusays.com/2022/12/31/63b0106e00925.png" alt="Snipaste_2022-07-17_20-19-19.png"></a></p><p>浪费了很多时间，特此记录</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>do{...}while(0)的妙用</title>
      <link href="/2022/07/14/do-while(0)/"/>
      <url>/2022/07/14/do-while(0)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzkwNzMwNzI1Ng==&amp;mid=2247483674&amp;idx=3&amp;sn=458052f964148f7f71d96c037b726635&amp;chksm=c0da708df7adf99b931f22a0e61251f6f0fcce5e8494d7c5911155ecffb0cfca8343241d71da&amp;token=2107487666&amp;lang=zh_CN#rd">原文地址</a></p><p>第一次见到 do{…}while(0)是在学习libevent的时候，看到里面有很多类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define TT_URI(want) do &#123; \</span><br><span class="line">char *ret = evhttp_uri_join(uri, url_tmp, sizeof(url_tmp));\</span><br><span class="line">tt_want(ret != NULL);\</span><br><span class="line">tt_want(ret == url_tmp);\</span><br><span class="line">if (strcmp(ret,want) != 0)\</span><br><span class="line">TT_FAIL((&quot;\&quot;%s\&quot; != \&quot;%s\&quot;&quot;,ret,want));\</span><br><span class="line">&#125; while(0)</span><br></pre></td></tr></table></figure><p>当时特别疑惑，do{…}while()不是做循环的吗，类似for,while的语法，不过现实开发中，用for和while的比较多，do{…}while()比较少了，算是比较不常用的语法。但是在这里，这样的代码一看就不是一个循环，do…while表面上在这里一点意义都没有，那么为什么要这么用呢？特别疑惑的google之，恍然大悟，原来do{…}while()还有此等妙用，看来自己还差得远啊。</p><p>总体来说，do{…}while(0)有两种用法。</p><h3 id="一-定义宏，实现局部作用域。"><strong>一.定义宏，实现局部作用域。</strong></h3><p>1.大家做c语言题目的时候，一道必考题就是 #define的算术运算。比如，我随手写一个最简单的#define</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define FUNC(x) x*3+4</span><br><span class="line">...</span><br><span class="line">int result = 2 * FUNC(3);</span><br></pre></td></tr></table></figure><p>result输出多少?  26？错！这是c语言新手一定会犯的错误，至少我第一次看到这，我就做错了。要知道这道题答案是多少，首先就要知道#define的作用。<br>1).#define M (a+b)　它的作用是指定标识符M来代替表达式(a+b)。在编写源程序时，所有的(a+b)都可由M代替，而对源程序作编译时，将先由预处理程序进行宏代换，即用(a+b)表达式去置换所有的宏名M，然后再进行编译。<br>2).c语言允许宏带有参数。在宏定义中的参数称为形式参数，在宏调用中的参数称为实际参数。对带参数的宏，在调用中，不仅要宏展开，而且要用实参去代换形参。(以上两句来自百度百科)</p><p>也就是 #define是在预处理的时候进行直接替换！(这句话是这一节的重点)<br>例如之上的展开就是.<br>int result = 2 * x * 3 + 4<br>x用实参3代替就是：<br>int result = 2 * 3 * 3 + 4 = 22而不是26.</p><p>有些人可能说，这些我都知道，这跟do{…}while(0)有什么关系。</p><p>其实，我只是为了告诉你，#define使用的时候要特别小心，尤其是#define一个很复杂的逻辑的时候。</p><p>我们举个简单的#define的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;print: &quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void send()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;&quot;send: &quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define LOG print();send();</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (false)</span><br><span class="line">LOG</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码输出什么?理论上，if(false)里面的代码不会被执行，也就是LOG不会被执行，所以只应该打印出&quot;hello world&quot;.</p><p>但是事实上：</p><p><img src="https://img-blog.csdn.net/20150424152000982" alt="01"></p><p>纳闷？</p><p>注意我上面说的一句话：</p><p>也就是 #define是在预处理的时候进行直接替换！(这句话是这一节的重点)</p><p>也就是说，上面的if(false)…在这里是：</p><pre><code>if (false)print();send(); cout &lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</code></pre><p>懂了吧。</p><p>怎么解决了，有些人马上想到，用{…}把#define 的值括住不就可以了。的确，在这里是可以的。</p><p>我们在写代码的时候都习惯在语句右面加上分号，如果在宏中使用{},我们通常会这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define LOG &#123;print();send();&#125;;</span><br></pre></td></tr></table></figure><p>当我们的if后面有一个else呢？</p><p>就变成了：</p><pre><code>if (false)&#123;print();send();&#125;;else&#123;cout &lt;&lt;&quot;hello&quot;&lt;&lt;endl;&#125;</code></pre><p>这样就会因为if语句后面多加了个;而编译不通过。不要说你说，那我不加;那要是你开发一个大型项目的时候你自己也不知道你自己要不要加;了，你就会被自己给绕晕了，所以统一的规范很重要。</p><p>那么来我们的最终版本：do{…}while(0);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define LOG do&#123;print();send();&#125;while (0);</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">if (false)</span><br><span class="line">LOG</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;&quot;hello&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">cout &lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就相当于：</p><pre><code>if (false)do&#123;print();send();&#125;while (0);else&#123;cout &lt;&lt;&quot;hello&quot;&lt;&lt;endl;&#125;cout &lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</code></pre><p>用do{…}while(0);包裹住要操作的#define,无论你外面怎么操作，都不会影响#define的操作。妙哉妙哉啊。</p><h3 id="二-替代goto">二.替代goto.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int dosomething()</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int clear()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int foo()</span><br><span class="line">&#123;</span><br><span class="line">int error = dosomething();</span><br><span class="line"></span><br><span class="line">if(error = 1)</span><br><span class="line">&#123;</span><br><span class="line">goto END;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if(error = 2)</span><br><span class="line">&#123;</span><br><span class="line">goto END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line">clear();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这只是一个简单的例子，有些人说，我可以不用goto，在每一个goto调用的地方直接，那么加一个判断，你就要加一条clear()，万一你漏了呢？而且正常情况下,foo里面的if有很多个，你要写很多goto,END里面的逻辑也更复杂。这样就更要小心。</p><p>由于goto不符合软件工程的结构化，而且有可能使得代码难懂，所以很多人都不倡导使用，那这个时候就可以用do{}while(0)来进行统一的管理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int foo()</span><br><span class="line">&#123;</span><br><span class="line">do </span><br><span class="line">&#123;</span><br><span class="line">int error = dosomething();</span><br><span class="line"></span><br><span class="line">if(error = 1)</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if(error = 2)</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (0);</span><br><span class="line"></span><br><span class="line">clear();</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是看起来好看多了，而且还避免了由于错误导致的严重bug（比如你在clear里面是清理内存的操作，你忘记了写goto，而走不到END里面）。</p><p>在do{…}while(0)里面，在任何地方都可以break跳出，然后继续下面的执行逻辑。即使你不写break，也会在执行完一遍do之后，while(0)不满足，自己跳出去。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC详解</title>
      <link href="/2022/07/11/GCC%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/07/11/GCC%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1fy4y1b7TC/?spm_id_from=333.999.0.0&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><p><strong>前言</strong>：</p><ol><li class="lvl-3"><p><strong>GCC 编译器</strong>支持编译 Go、Objective-C，Objective-C ++，Fortran，Ada，D 和 BRIG（HSAIL）等程序；</p></li><li class="lvl-3"><p>Linux  开发C/C++ <strong>一定</strong>要熟悉 GCC</p></li><li class="lvl-3"><p><strong>VSCode是通过调用GCC编译器来实现C/C++的编译工作的；</strong></p></li></ol><p>实际使用中：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>使用 gcc 指令编译 C 代码</strong></p></li><li class="lvl-2"><p><strong>使用 g<ins>指令编译 C</ins> 代码</strong></p></li></ul><h3 id="1-编译过程">1. 编译过程</h3><ol><li class="lvl-3"><p><strong>预处理-Pre-Processing        //.i文件</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -E 选项指示编译器仅对输入文件进行预处理</span><br><span class="line">g++  -E  test.cpp  -o  test.i    //.i文件</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>编译-Compiling             // .s文件</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译</span><br><span class="line">#  g++ 产生的汇编语言文件的缺省扩展名是 .s </span><br><span class="line">g++  -S  test.i  -o   test.s</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>汇编-Assembling          // .o文件</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码</span><br><span class="line"># 缺省时 g++ 建立的目标代码文件有一个 .o 的扩展名。</span><br><span class="line">g++  -c  test.s  -o  test.o</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>链接-Linking            // bin文件</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -o 编译选项来为将产生的可执行文件用指定的文件名</span><br><span class="line">g++  test.o  -o  test</span><br></pre></td></tr></table></figure><h3 id="2-g-重要编译参数">2. g++重要编译参数</h3><ol><li class="lvl-3"><p><strong>-g</strong>   编译带调试信息的可执行文件</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -g 选项告诉 GCC 产生能被 GNU 调试器GDB使用的调试信息，以调试程序。</span><br><span class="line"></span><br><span class="line"># 产生带调试信息的可执行文件test</span><br><span class="line">g++ -g test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-O[n]</strong>   优化源代码</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## 所谓优化，例如省略掉代码中从未使用过的变量、直接将常量表达式用结果值代替等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。</span><br><span class="line"></span><br><span class="line"># -O 选项告诉 g++ 对源代码进行基本优化。这些优化在大多数情况下都会使程序执行的更快。 -O2 选项告诉 g++ 产生尽可能小和尽可能快的代码。 如-O2，-O3，-On（n 常为0–3）</span><br><span class="line"># -O 同时减小代码的长度和执行时间，其效果等价于-O1</span><br><span class="line"># -O0 表示不做优化</span><br><span class="line"># -O1 为默认优化</span><br><span class="line"># -O2 除了完成-O1的优化之外，还进行一些额外的调整工作，如指令调整等。</span><br><span class="line"># -O3 则包括循环展开和其他一些与处理特性相关的优化工作。</span><br><span class="line"># 选项将使编译的速度比使用 -O 时慢， 但通常产生的代码执行速度会更快。</span><br><span class="line"></span><br><span class="line"># 使用 -O2优化源代码，并输出可执行文件</span><br><span class="line">g++ -O2 test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-l  和  -L</strong>   指定库文件  |  指定库文件路径</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># -l参数(小写)就是用来指定程序要链接的库，-l参数紧接着就是库名</span><br><span class="line"># 在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接</span><br><span class="line"></span><br><span class="line"># 链接glog库</span><br><span class="line">g++ -lglog test.cpp</span><br><span class="line"></span><br><span class="line"># 如果库文件没放在上面三个目录里，需要使用-L参数(大写)指定库文件所在目录</span><br><span class="line"># -L参数跟着的是库文件所在的目录名</span><br><span class="line"></span><br><span class="line"># 链接mytest库，libmytest.so在/home/bing/mytestlibfolder目录下</span><br><span class="line">g++ -L/home/bing/mytestlibfolder -lmytest test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-I</strong>   指定头文件搜索目录</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -I </span><br><span class="line"># /usr/include目录一般是不用指定的，gcc知道去那里找，但 是如果头文件不在/usr/icnclude里我们就要用-I参数指定了，比如头文件放在/myinclude目录里，那编译命令行就要加上-I/myinclude 参数了，如果不加你会得到一个”xxxx.h: No such file or directory”的错误。-I参数可以用相对路径，比如头文件在当前 目录，可以用-I.来指定。上面我们提到的–cflags参数就是用来生成-I参数的。</span><br><span class="line"></span><br><span class="line">g++ -I/myinclude test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-Wall</strong>   打印警告信息</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 打印出gcc提供的警告信息</span><br><span class="line">g++ -Wall test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-w</strong>   关闭警告信息</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 关闭所有警告信息</span><br><span class="line">g++ -w test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-std=c++11</strong>   设置编译标准</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 c++11 标准编译 test.cpp</span><br><span class="line">g++ -std=c++11 test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-o</strong>   指定输出文件名</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 指定即将产生的文件名</span><br><span class="line"></span><br><span class="line"># 指定输出可执行文件名为test</span><br><span class="line">g++ test.cpp -o test</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-D</strong>   定义宏</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在使用gcc/g++编译的时候定义宏</span><br><span class="line"></span><br><span class="line"># 常用场景：</span><br><span class="line"># -DDEBUG 定义DEBUG宏，可能文件中有DEBUG宏部分的相关信息，用个DDEBUG来选择开启或关闭DEBUG</span><br></pre></td></tr></table></figure><p><strong>示例代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// -Dname 定义宏name,默认定义内容为字符串“1”</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   #ifdef DEBUG</span><br><span class="line">       printf(&quot;DEBUG LOG\n&quot;);</span><br><span class="line">   #endif</span><br><span class="line">       printf(&quot;in\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1. 在编译的时候，使用gcc -DDEBUG main.cpp</span><br><span class="line">// 2. 第七行代码可以被执行</span><br></pre></td></tr></table></figure><p>注：使用 <code>man gcc</code>命令可以查看gcc英文使用手册</p><h3 id="3-【实战】g-命令行编译">3 .【实战】g++命令行编译</h3><p>**案例：**最初目录结构: 2 directories, 3 files</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 最初目录结构</span><br><span class="line"></span><br><span class="line">├── include</span><br><span class="line">│   └── Swap.h</span><br><span class="line">├── main.cpp</span><br><span class="line">└── src</span><br><span class="line">    └── Swap.cpp</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br></pre></td></tr></table></figure><h4 id="3-1-直接编译">3.1 直接编译</h4><p><strong>最简单的编译，并运行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将 main.cpp src/Swap.cpp 编译为可执行文件</span><br><span class="line">g++ main.cpp src/Swap.cpp -Iinclude</span><br><span class="line"># 运行a.out</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure><p><strong>增加参数编译，并运行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将 main.cpp src/Swap.cpp 编译为可执行文件 附带一堆参数</span><br><span class="line">g++ main.cpp src/Swap.cpp -Iinclude -std=c++11 -O2 -Wall -o b.out</span><br><span class="line"># 运行 b.out</span><br><span class="line">./b.out</span><br></pre></td></tr></table></figure><h4 id="3-2-生成库文件并编译">3.2 生成库文件并编译</h4><p>链接<strong>静态库</strong>生成可执行文件①：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">## 进入src目录下</span><br><span class="line">$cd src</span><br><span class="line"></span><br><span class="line"># 汇编，生成Swap.o文件</span><br><span class="line">g++ Swap.cpp -c -I../include</span><br><span class="line"># 生成静态库libSwap.a</span><br><span class="line">ar rs libSwap.a Swap.o</span><br><span class="line"></span><br><span class="line">## 回到上级目录</span><br><span class="line">$cd ..</span><br><span class="line"></span><br><span class="line"># 链接，生成可执行文件:staticmain</span><br><span class="line">g++ main.cpp -Iinclude -Lsrc -lSwap -o staticmain</span><br></pre></td></tr></table></figure><p>链接<strong>动态库</strong>生成可执行文件②：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">## 进入src目录下</span><br><span class="line">$cd src</span><br><span class="line"></span><br><span class="line"># 生成动态库libSwap.so</span><br><span class="line">g++ Swap.cpp -I../include -fPIC -shared -o libSwap.so</span><br><span class="line">## 上面命令等价于以下两条命令</span><br><span class="line"># gcc Swap.cpp -I../include -c -fPIC</span><br><span class="line"># gcc -shared -o libSwap.so Swap.o</span><br><span class="line"></span><br><span class="line">## 回到上级目录</span><br><span class="line">$cd ..</span><br><span class="line"></span><br><span class="line"># 链接，生成可执行文件:sharemain</span><br><span class="line">g++ main.cpp -Iinclude -Lsrc -lSwap -o sharemain</span><br></pre></td></tr></table></figure><p><strong>编译完成后的目录结构</strong></p><p>最终目录结构：2 directories, 8 files</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 最终目录结构</span><br><span class="line"></span><br><span class="line">├── include</span><br><span class="line">│   └── Swap.h</span><br><span class="line">├── main.cpp</span><br><span class="line">├── sharemain</span><br><span class="line">├── src</span><br><span class="line">│   ├── libSwap.a</span><br><span class="line">│   ├── libSwap.so</span><br><span class="line">│   ├── Swap.cpp</span><br><span class="line">│   └── Swap.o</span><br><span class="line">└── staticmain</span><br><span class="line"></span><br><span class="line">2 directories, 8 files</span><br></pre></td></tr></table></figure><h4 id="3-3-运行可执行文件">3.3 运行可执行文件</h4><p>运行可执行文件①</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 运行可执行文件</span><br><span class="line">./staticmain</span><br></pre></td></tr></table></figure><p>运行可执行文件②</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 运行可执行文件</span><br><span class="line">LD_LIBRARY_PATH=src ./sharemain</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCC </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake详解</title>
      <link href="/2022/07/11/CMake%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/07/11/CMake%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1fy4y1b7TC/?spm_id_from=333.999.0.0&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><h3 id="1-前言：">1.前言：</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>CMake</strong>是一个<strong>跨平台</strong>的安装<strong>编译工具</strong>，可以用<strong>简单</strong>的语句来描述<strong>所有平台</strong>的安装(编译过程)。</p></li><li class="lvl-2"><p>CMake可以说已经成为<strong>大部分C++开源项目标配</strong></p></li></ul><h3 id="2-语法特性介绍">2. 语法特性介绍</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>基本语法格式：指令(参数 1 参数 2…)</strong></p><ul class="lvl-2"><li class="lvl-4">参数使用<strong>括弧</strong>括起</li></ul><ul class="lvl-2"><li class="lvl-4"><p>参数之间使用<strong>空格</strong>或<strong>分号</strong>分开</p></li></ul></li><li class="lvl-2"><p><strong>指令是大小写无关的，参数和变量是大小写相关的</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(HELLO hello.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cpp hello.cpp)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.cpp <span class="variable">$&#123;HELLO&#125;</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</strong></p></li></ul><h3 id="3-重要指令和CMake常用变量">3. 重要指令和CMake常用变量</h3><h4 id="3-1-重要指令">3.1 重要指令</h4><ul class="lvl-0"><li class="lvl-2"><p><mark><strong>cmake_minimum_required</strong></mark> <strong>- 指定CMake的最小版本要求</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>cmake_minimum_required(VERSION versionNumber [FATAL_ERROR])</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake最小版本要求为2.8.3</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><mark><strong>project</strong></mark> <strong>- 定义工程名称，并可指定工程支持的语言</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>project(projectname [CXX] [C] [Java])</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定工程名为HELLOWORLD</span></span><br><span class="line"><span class="keyword">project</span>(HELLOWORLD)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><mark><strong>set</strong></mark> <strong>- 显式的定义变量</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>set(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义SRC变量，其值为main.cpp hello.cpp</span></span><br><span class="line"><span class="keyword">set</span>(SRC sayhello.cpp hello.cpp)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><mark><strong>include_directories</strong></mark> <strong>- 向工程添加多个特定的头文件搜索路径</strong> —&gt;相当于指定g++编译器的-I参数</p><ul class="lvl-2"><li class="lvl-4">语法：<strong>include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将/usr/include/myincludefolder 和 ./include 添加到头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(/usr/<span class="keyword">include</span>/myincludefolder ./<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><mark><strong>link_directories</strong></mark> <strong>- 向工程添加多个特定的库文件搜索路径</strong> —&gt;相当于指定g++编译器的-L参数</p><ul class="lvl-2"><li class="lvl-4">语法：**link_directories(dir1 dir2 …) **</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(/usr/lib/mylibfolder ./lib)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong><mark>add_library</mark></strong> <strong>- 生成库文件</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 … sourceN)</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过变量 SRC 生成 libhello.so 共享库</span></span><br><span class="line"><span class="keyword">add_library</span>(hello SHARED <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong><mark>add_compile_options</mark></strong> - 添加编译参数</p><ul class="lvl-2"><li class="lvl-4">语法：<strong>add_compile_options(</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加编译参数 -Wall -std=c++11</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-Wall -std=c++<span class="number">11</span> -O2)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong><mark>add_executable</mark></strong> <strong>- 生成可执行文件</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>add_library(exename source1 source2 … sourceN)</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译main.cpp生成可执行文件main</span></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong><mark>target_link_libraries</mark></strong> - 为 target 添加需要链接的共享库  —&gt;相同于指定g++编译器-l参数</p><ul class="lvl-2"><li class="lvl-4">语法：<strong>target_link_libraries(target library1library2…)</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将hello动态库文件链接到可执行文件main</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main hello)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong><mark>add_subdirectory</mark> - 向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加src子目录，src中需有一个CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>aux_source_directory - 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>aux_source_directory(dir VARIABLE)</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义SRC变量，其值为当前目录下所有的源代码文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC)</span><br><span class="line"><span class="comment"># 编译SRC变量所代表的源代码文件，生成main可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-CMake常用变量">3.2 CMake常用变量</h4><ul class="lvl-0"><li class="lvl-2"><p><strong><mark>CMAKE_C_FLAGS</mark>  gcc编译选项</strong></p></li><li class="lvl-2"><p><strong><mark>CMAKE_CXX_FLAGS</mark>  g++编译选项</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在CMAKE_CXX_FLAGS编译选项后追加-std=c++11</span><br><span class="line">set( CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong><mark>CMAKE_BUILD_TYPE</mark>  编译类型(Debug, Release)</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 设定编译类型为debug，调试时需要选择debug</span><br><span class="line">set(CMAKE_BUILD_TYPE Debug) </span><br><span class="line"># 设定编译类型为release，发布时需要选择release</span><br><span class="line">set(CMAKE_BUILD_TYPE Release) </span><br></pre></td></tr></table></figure><blockquote><p><strong>CMAKE_BINARY_DIR</strong></p><p><strong>PROJECT_BINARY_DIR</strong></p><p><strong>__BINARY_DIR</strong></p></blockquote><ol><li class="lvl-3"><p>这三个变量指代的内容是一致的。</p></li><li class="lvl-3"><p>如果是 in source build，指的就是工程顶层目录。</p></li><li class="lvl-3"><p>如果是 out-of-source 编译,指的是工程编译发生的目录。</p></li><li class="lvl-3"><p>PROJECT_BINARY_DIR 跟其他指令稍有区别，不过现在，你可以理解为他们是一致的。</p></li></ol><blockquote><p><strong>CMAKE_SOURCE_DIR</strong></p><p><strong>PROJECT_SOURCE_DIR</strong><br><strong>__SOURCE_DIR</strong></p></blockquote><ol><li class="lvl-3"><p>这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录。</p></li><li class="lvl-3"><p>也就是在 in source build时,他跟 CMAKE_BINARY_DIR 等变量一致。</p></li><li class="lvl-3"><p>PROJECT_SOURCE_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><strong>CMAKE_C_COMPILER：指定C编译器</strong></p></li><li class="lvl-2"><p><strong>CMAKE_CXX_COMPILER：指定C++编译器</strong></p></li><li class="lvl-2"><p><strong>EXECUTABLE_OUTPUT_PATH：可执行文件输出的存放路径</strong></p></li><li class="lvl-2"><p><strong>LIBRARY_OUTPUT_PATH：库文件输出的存放路径</strong></p></li></ul><h3 id="4-CMake编译工程">4. CMake编译工程</h3><p>CMake目录结构：项目主目录存在一个CMakeLists.txt文件</p><p><strong>两种方式设置编译规则</strong>：</p><ol><li class="lvl-3"><p>包含源文件的子文件夹包含CMakeLists.txt文件，主目录的CMakeLists.txt通过add_subdirectory添加子目录即可；</p></li><li class="lvl-3"><p>包含源文件的子文件夹未包含CMakeLists.txt文件，子目录编译规则体现在主目录的CMakeLists.txt中；</p></li></ol><h4 id="4-1-编译流程">4.1 编译流程</h4><p><strong>在 linux 平台下使用 CMake 构建C/C++工程的流程如下:</strong></p><ul class="lvl-0"><li class="lvl-2"><p>手动编写 CmakeLists.txt。</p></li><li class="lvl-2"><p>执行命令 <code>cmake PATH</code>生成 Makefile ( PATH 是顶层CMakeLists.txt 所在的目录 )。</p></li><li class="lvl-2"><p>执行命令<code>make</code> 进行编译。</p></li></ul><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">important tips</span></span><br><span class="line">.          # 表示当前目录</span><br><span class="line">./         # 表示当前目录</span><br><span class="line"></span><br><span class="line">..      # 表示上级目录</span><br><span class="line">../     # 表示上级目录</span><br></pre></td></tr></table></figure><hr><h4 id="6-4-2-两种构建方式">6.4.2 两种构建方式</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>内部构建(in-source build)</strong>：不推荐使用</p><p>内部构建会在同级目录下产生一大堆中间文件，这些中间文件并不是我们最终所需要的，和工程源文件放在一起会显得杂乱无章。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 内部构建</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录下，编译本目录的CMakeLists.txt，生成Makefile和其他文件</span></span><br><span class="line">cmake .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行make命令，生成target</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>外部构建(out-of-source build)</strong>：<mark>推荐使用</mark></p><p>将编译输出文件与源文件放到不同目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 外部构建</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 在当前目录下，创建build文件夹</span></span><br><span class="line">mkdir build </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 进入到build文件夹</span></span><br><span class="line">cd build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 编译上级目录的CMakeLists.txt，生成Makefile和其他文件</span></span><br><span class="line">cmake ..</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 执行make命令，生成target</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-【实战】CMake代码实践">5. 【实战】CMake代码实践</h3><h4 id="5-1-最小CMake工程">5.1 最小CMake工程</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the minimum version of CMake that can be used</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the project name</span></span><br><span class="line"><span class="keyword">project</span> (HELLO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add an executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello_cmake main.cpp)</span><br></pre></td></tr></table></figure><h4 id="5-2-多目录工程-直接编译">5.2 多目录工程 - 直接编译</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the minimum version of CMake that can be used</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#project name</span></span><br><span class="line"><span class="keyword">project</span>(SWAP)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#head file pat</span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="keyword">include</span> )</span><br><span class="line"> </span><br><span class="line"><span class="comment">#source directory files to var</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>( src DIR_SRCS )</span><br><span class="line"></span><br><span class="line"><span class="comment">#add executable file  </span></span><br><span class="line"><span class="keyword">add_executable</span>(swap_02 <span class="variable">$&#123;TEST_MATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#add link library  </span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;FS_BUILD_BINARY_PREFIX&#125;</span>sqrt <span class="variable">$&#123;LIBRARIES&#125;</span>) </span><br></pre></td></tr></table></figure><h4 id="6-5-3-多目录工程-生成库编译">6.5.3 多目录工程 - 生成库编译</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the minimum version of CMake that can be used</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#project name  </span></span><br><span class="line"><span class="keyword">project</span>(SWAP_LIBRARY)</span><br><span class="line"></span><br><span class="line"><span class="comment">#add compile options</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;-Wall -std=c++11&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#set CMAKE_BUILD_TYPE</span></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE Debug ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># set output binary path  </span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># Create a library</span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Generate the static library from the library sources</span></span><br><span class="line"><span class="keyword">add_library</span>( swap_library STATIC src/Swap.cpp )</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>( swap_lib PUBLIC <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># Create an executable</span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add an executable with the above sources</span></span><br><span class="line"><span class="keyword">add_executable</span>( swap_01 main.cpp )</span><br><span class="line"></span><br><span class="line"><span class="comment"># link the new swap_01 target with the swap_lib target</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( swap_01 swap_liby )</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Json+Shell联合使用</title>
      <link href="/2022/07/11/JSON+Shell/"/>
      <url>/2022/07/11/JSON+Shell/</url>
      
        <content type="html"><![CDATA[<p>json文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;options&quot;: &#123;</span><br><span class="line">        &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;/build&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;cmake&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cmake&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;..&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;make&quot;,</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: &quot;true&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;command&quot;: &quot;make -j12&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;Build&quot;,</span><br><span class="line">            &quot;dependsOn&quot;:[</span><br><span class="line">                &quot;cmake&quot;,</span><br><span class="line">                &quot;make&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;inputs&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;promptString&quot;,</span><br><span class="line">          &quot;id&quot;: &quot;commitInfo&quot;,</span><br><span class="line">          &quot;description&quot;: &quot;输入commit信息&quot;,</span><br><span class="line">          &quot;default&quot;: &quot;default information&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;提交代码&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;./push.sh&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;$&#123;input:commitInfo&#125;&quot;//inputs中的id</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &quot;test&quot;,</span><br><span class="line">            &quot;presentation&quot;: &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>shell脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -am $1</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode 调试教程 tasks.json和launch.json的设置</title>
      <link href="/2022/07/07/VScode%20%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B%20tasks.json%E5%92%8Claunch.json%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
      <url>/2022/07/07/VScode%20%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B%20tasks.json%E5%92%8Claunch.json%E7%9A%84%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>运行环境：</strong></p><p>VSCode 1.68.1</p><p>wsl：ubuntu子系统</p><p><img src="https://bu.dusays.com/2022/12/31/63affe9d58d5d.png" alt="debug.png"></p><p>废话不多说，直接开整，首先选择左侧任务栏的第四个选项<mark>运行和调试</mark>，点击创建launch.json</p><p><img src="https://bu.dusays.com/2022/12/31/63affeb0da4ac.png" alt="addconfig.png"></p><p>创建好的界面如上图所示。点击右下角的添加配置</p><p><img src="https://bu.dusays.com/2022/12/31/63affec35aae7.png" alt="addgdb.png">此时如上图所示，选择第一个<mark>c/c++(gdb)启动</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63affedb8b071.png" alt="改目录.png"></p><p>此时会生成如上图所示代码，注意我画箭头的这两个地方，那个cwd是我们当前文件所在的工作目录，把画箭头的这两个地方改成一样的</p><p><img src="https://bu.dusays.com/2022/12/31/63affeefa07c4.png" alt="改名字.png"></p><p>改完后如上图所示，后面的a.out是我们一会儿要调试的可执行文件名称，这里用系统生成的也行，改成自己的也行，接下来我们开始配置tasks.json</p><p><img src="https://bu.dusays.com/2022/12/31/63afff0234ac7.png" alt="生成task.png"></p><p>首先回到main.cpp，然后点击上方菜单栏的终端，选择最后一个<mark>配置默认生成任务</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63afff1345fea.png" alt="g++.png"></p><p>此时如上如所示，再选择第二个<mark>c/c++:g++生成活动文件</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63afff24c1d74.png" alt="初始化的tasks.png"></p><p>此时如上图所示，生成tasks.json,接着我们打开launch.json做一个比较，我们先在launch.json后面加一行代码&quot;prelaunchTask&quot;,这行代码意思就是在launch之前运行的任务名，这个名字一定要跟tasks.json中的任务名字写一致，如下图所示，tasks.json中的label要和launch.json中的prelaunchTask完全一致，因为在执行launch.json之前系统会根据这行代码先去执行tasks.json中的内容，可以简单理解为tasks.json中的代码会帮我们用g++/gcc编译生成可执行文件，而launch.json中的代码是让系统来调试我们的可执行文件。</p><p><img src="https://bu.dusays.com/2022/12/31/63afff3d70382.png" alt="Snipaste_2022-07-07_11-00-37.png"></p><p>接下来看到tasks.json中的文件，如下图所示，其中的command 配置 , 是指定编译器 , 一般是 gcc 或者 g++ 编译器 ，接着下面的args是编译器后的编译选项，注意这个-g意思就是编译出带调试信息的可执行文件，如果少了这个-g，生成的可执行文件就不能够调试了，下面的main.cpp和swap.cpp是要编译的文件名，-0参数指定生成可执行文件的名字，下一行就是生成可执行文件的位置在当前的工作目录，名字叫a.out</p><p><img src="https://bu.dusays.com/2022/12/31/63afff4e70efe.png" alt="Snipaste_2022-07-07_15-37-53.png"></p><p>大家注意，文中的画箭头部分，这两个起的名字要一样，左边的是生成可执行文件叫a.out右边的是调试的文件叫a.out，名字可以自己更换</p><p>所以tasks.json实际上就相当于帮我们完成了<mark>g++ -g main.cpp swap.cpp -o a.out</mark>的功能</p><p><img src="https://bu.dusays.com/2022/12/31/63afff6322ee7.png" alt="Snipaste_2022-07-07_15-47-13.png"></p><p>配置好上面的文件后，回到main.cpp设置自己的断点，然后按F5键进行调试，成功啦</p><p><img src="https://bu.dusays.com/2022/12/31/63afff82eabb1.png" alt="Snipaste_2022-07-07_11-00-56.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> VScode </category>
          
          <category> Json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
            <tag> C++ </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt学习笔记(下)</title>
      <link href="/2022/06/17/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%8B)/"/>
      <url>/2022/06/17/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%8B)/</url>
      
        <content type="html"><![CDATA[<h2 id="1-自定义控件封装">1.  自定义控件封装</h2><p><mark>添加新文件 - Qt – 设计师界面类 (.h .cpp .ui)</mark></p><p><mark>ui中 设计 QSpinBox和QSlider 两个控件</mark></p><p><mark>Widget中使用自定义控件，拖拽一个Widget，点击提升为，点击添加，点击提升</mark></p><p><mark>实现功能，改变数字，滑动条跟着移动 ，信号槽监听。</mark></p><p><mark>提供 getNum 和 setNum对外接口</mark></p><p><mark>测试接口</mark></p><h2 id="2-Qt中的事件">2. Qt中的事件</h2><p><mark>鼠标事件</mark></p><p><mark>鼠标进入事件 enterEvent</mark></p><p><mark>鼠标离开事件 leaveEvent</mark></p><p><mark>鼠标按下  mousePressEvent ( QMouseEvent ev)</mark></p><p><mark>鼠标释放  mouseReleaseEvent</mark></p><p><mark>鼠标移动  mouseMoveEvent</mark></p><p><mark>ev-&gt;x() x坐标 ev-&gt;y() y坐标</mark></p><p><mark>ev-&gt;button() 可以判断所有按键 Qt::LeftButton Qt::RightButton</mark></p><p><mark>ev-&gt;buttons()判断组合按键 判断move时候的左右键 结合 &amp; 操作符</mark></p><p><mark>格式化字符串 QString( “ %1 %2 ” ).arg( 111 ).arg(222)</mark></p><p><mark>设置鼠标追踪   setMouseTracking(true);</mark></p><h2 id="3-定时器1">3.  定时器1</h2><p><mark>利用事件 void timerEvent ( QTimerEvent * ev)</mark></p><p><mark>启动定时器 startTimer( 1000) 毫秒单位</mark></p><p><mark>timerEvent 的返回值是定时器的唯一标示 可以和ev-&gt;timerId 做比较</mark></p><h2 id="4-定时器2">4.  定时器2</h2><p><mark>利用定时器类 QTimer</mark></p><p><mark>创建定时器对象 QTimer * timer = new QTimer(this)</mark></p><p><mark>启动定时器 timer-&gt;start(毫秒)</mark></p><p><mark>每隔一定毫秒，发送信号 timeout ,进行监听</mark></p><p><mark>暂停 timer-&gt;stop</mark></p><h2 id="5-event事件">5.  event事件</h2><p><mark>用途：用于事件的分发</mark></p><p><mark>也可以做拦截操作，不建议</mark></p><p><mark>bool event( QEvent * e);</mark></p><p><mark>返回值 如果是true 代表用户处理这个事件，不向下分发了</mark></p><p><mark>e-&gt;type() == 鼠标按下 …</mark></p><h2 id="6-事件过滤器">6.  事件过滤器</h2><p><img src="https://bu.dusays.com/2022/12/31/63affb18b8cbb.png" alt="01.png"></p><p><mark>在程序将时间分发到事件分发器前，可以利用过滤器做拦截</mark></p><h3 id="6-2-步骤">6.2   步骤</h3><p><mark>1、给控件安装事件过滤器</mark></p><p><mark>2、重写 eventFilter函数 （obj ， ev）</mark></p><h2 id="7-QPainter-绘图">7. QPainter 绘图</h2><p><mark>绘图事件 void paintEvent()</mark></p><p><mark>声明一个画家对象 QPainter painter(this)  this指定绘图设备</mark></p><p><mark>画线、画圆、画矩形、画文字</mark></p><p><mark>设置画笔 QPen 设置画笔宽度 、风格</mark></p><p><mark>设置画刷 QBrush 设置画刷 风格</mark></p><h2 id="8-QPainter高级设置">8.  QPainter高级设置</h2><h3 id="8-1-抗锯齿-效率低">8.1  抗锯齿 效率低</h3><p><mark>painter.setRenderHint(QPainter::Antialiasing);</mark></p><h3 id="8-2-对画家进行移动">8.2  对画家进行移动</h3><p><mark>painter.translate(100,0);</mark></p><p><mark>保存状态 save</mark></p><p><mark>还原状态 restore</mark></p><h3 id="8-3-如果想手动调用绘图事件-利用update">8.3  如果想手动调用绘图事件 利用update</h3><h3 id="8-4-利用画家画图片-painter-drawPixmap-x，y，QPixmap-路飞">8.4   利用画家画图片 painter.drawPixmap( x，y，QPixmap( 路飞) )</h3><h2 id="9-QPaintDevice绘图设备">9. QPaintDevice绘图设备</h2><p><mark>QPixmap QImage QBitmap(黑白色) QPicture QWidget</mark></p><h3 id="9-1-QPixmap-对不同平台做了显示的优化">9.1   QPixmap 对不同平台做了显示的优化</h3><p><mark>QPixmap pix( 300,300)</mark></p><p><mark>pix.fill( 填充颜色 )</mark></p><p><mark>利用画家 往pix上画画 QPainter painter( &amp; pix)</mark></p><p><mark>保存 pix.save( “路径”)</mark></p><h3 id="9-2-Qimage-可以对像素进行访问">9.2   Qimage 可以对像素进行访问</h3><p><mark>使用和QPixmap差不多 QImage img(300,300,<strong>QImage::Format_RGB32</strong>);</mark></p><p><mark>其他流程和QPixmap一样</mark></p><p><mark>可以对像素进行修改 img.setPixel(i,j,value);</mark></p><h3 id="9-3-QPicture-记录和重现-绘图指令">9.3  QPicture  记录和重现 绘图指令</h3><p><mark>QPicture pic</mark></p><p><mark>painter.begin(&amp;pic);</mark></p><p><mark>保存 pic.save( 任意后缀名 )</mark></p><p><mark>重现 利用画家可以重现painter.drawPicture(0,0,pic);</mark></p><h2 id="10-QFile-对文件进行读写操作">10.  QFile 对文件进行读写操作</h2><h3 id="10-1-QFile进行读写操作">10.1   QFile进行读写操作</h3><h3 id="10-2-QFile-file-path-文件路径">10.2   QFile file( path 文件路径)</h3><h3 id="10-3-读">10.3   读</h3><p><mark>ile.open(打开方式) QIODevice::readOnly</mark></p><p><mark>全部读取 file.readAll()  按行读 file.readLine() atend()判断是否读到文件尾</mark></p><p><mark>默认支持编码格式 utf-8</mark></p><p><mark>利用编码格式类 指定格式 QTextCodeC</mark></p><p><mark>QTextCodec * codec = QTextCodec::codecForName(“gbk”);</mark></p><p><mark>//ui-&gt;textEdit-&gt;setText( codec-&gt;toUnicode(array) );</mark></p><p><mark>文件对象关闭 close</mark></p><h3 id="10-4-写">10.4   写</h3><p><mark>file.open( QIODevice::writeOnly / Append)</mark></p><p><mark>file.write(内容)</mark></p><p><mark>file.close 关闭</mark></p><h2 id="11-QFileInfo-读取文件信息">11.  QFileInfo 读取文件信息</h2><p><mark>QFileInfo info(路径)</mark></p><p><mark>qDebug() &lt;&lt; “大小：” &lt;&lt; info.size() &lt;&lt; &quot; 后缀名：&quot; &lt;&lt; <strong>info.suffix()</strong> &lt;&lt; &quot; 文件名称：“&lt;&lt;info.fileName() &lt;&lt; &quot; 文件路径：”&lt;&lt; info.filePath();</mark></p><p><mark>qDebug() &lt;&lt; “创建日期：” &lt;&lt; info.created().toString(“yyyy/MM/dd hh:mm:ss”);</mark></p><p><mark>qDebug() &lt;&lt; “最后修改日期：”&lt;&lt;info.lastModified().toString(“yyyy-MM-dd hh:mm:ss”);</mark></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt学习笔记(中)</title>
      <link href="/2022/06/17/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%AD)/"/>
      <url>/2022/06/17/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%AD)/</url>
      
        <content type="html"><![CDATA[<h1>QT学习2</h1><h2 id="1-QMainWindow">1.QMainWindow</h2><h3 id="1-1-菜单栏-最多有一个">1.1     菜单栏 最多有一个</h3><p><mark>QMenuBar * bar = MenuBar();</mark></p><p><mark>setMenuBar( bar )</mark></p><p><mark>QMenu * fileMenu = bar -&gt; addMenu(“文件”)  创建菜单</mark></p><p><mark>QAction * newAction = fileMenu -&gt;addAction(“新建”); 创建菜单项</mark></p><p><mark>添加分割线 fileMenu-&gt;addSeparator();</mark></p><h3 id="1-2-工具栏-可以有多个">1.2     工具栏 可以有多个</h3><p><mark>QToolBar * toolbar = new QToolBar(this);</mark></p><p><mark>addToolBar( 默认停靠区域， toolbar ); Qt::LeftToolBarArea</mark></p><p><mark>设置 后期停靠区域，设置浮动，设置移动</mark></p><p><mark>添加菜单项 或者添加 小控件</mark></p><h3 id="1-3-状态栏-最多一个">1.3     状态栏 最多一个</h3><p><mark>QStatusBar * stBar = statusBar();</mark></p><p><mark>设置到窗口中 setStatusBar(stBar);</mark></p><p><mark>stBar-&gt;addWidget(label);放左侧信息</mark></p><p><mark>stBar-&gt;addPermanentWidget(label2); 放右侧信息</mark></p><h3 id="1-4-铆接部件-浮动窗口-可以多个">1.4     铆接部件 浮动窗口 可以多个</h3><p><mark>QDockWidget</mark></p><p><mark>addDockWidget( 默认停靠区域，浮动窗口指针)</mark></p><p><mark>设置后期停靠区域</mark></p><h3 id="1-5-设置核心部件-只能一个">1.5     设置核心部件 只能一个</h3><p><mark>setCentralWidget(edit);</mark></p><h2 id="2-资源文件">2.  资源文件</h2><p><mark>将图片文件 拷贝到项目位置下</mark></p><p><mark>右键项目-&gt;添加新文件 –&gt; Qt - &gt; Qt recourse File  - &gt;给资源文件起名</mark></p><p><mark>res 生成 res.qrc</mark></p><p><mark>open in editor 编辑资源</mark></p><p><mark>添加前缀 添加文件</mark></p><p><mark>使用 “ : + 前缀名 + 文件名 ”</mark></p><h2 id="3-对话框">3. 对话框</h2><h3 id="3-1-分类-：">3.1 分类 ：</h3><h4 id="3-1-1-模态对话框-不可以对其他窗口进行操作-阻塞">3.1.1  模态对话框  不可以对其他窗口进行操作 阻塞</h4><p><mark>QDialog dlg(this)</mark></p><p><mark>dlg.exec();</mark></p><h4 id="3-1-2-非模态对话框-可以对其他窗口进行操作">3.1.2  非模态对话框 可以对其他窗口进行操作</h4><p><mark>防止一闪而过 创建到堆区</mark></p><p><mark>QDialog * dlg = new QDialog(this)</mark></p><p><mark>dlg-&gt;show();</mark></p><p><mark>dlg2-&gt;setAttribute(Qt::WA_DeleteOnClose); //55号 属性</mark></p><h3 id="3-2-标准对话框-–-消息对话框">3.2     标准对话框 – 消息对话框</h3><p><mark>QMessageBox 静态成员函数 创建对话框</mark></p><p><mark>错误、信息、提问、警告</mark></p><p><mark>参数1 父亲 参数2 标题 参数3 显示内容 参数4 按键类型 参数5 默认关联回车按键</mark></p><p><mark>返回值 也是StandardButton类型，利用返回值判断用户的输入</mark></p><h3 id="3-3-其他标准对话框">3.3 其他标准对话框</h3><p><mark>颜色对话框 QColorDialog：：getColor</mark></p><p><mark>文件对话框 QFileDialog：：getOpenFileName(父亲，标题，默认路径，过滤文件)</mark></p><p><mark>字体对话框 QFontDialog：：getFont</mark></p><h2 id="4-界面布局">4. 界面布局</h2><p><mark>实现登陆窗口</mark></p><p><mark>利用布局方式 给窗口进行美化</mark></p><p><mark>选取 widget 进行布局 ，水平布局、垂直布局、栅格布局</mark></p><p><mark>给用户名、密码、登陆、退出按钮进行布局</mark></p><p><mark>默认窗口和控件之间 有9间隙，可以调整 layoutLeftMargin</mark></p><p><mark>利用弹簧进行布局</mark></p><h2 id="5-控件">5. 控件</h2><h3 id="5-1-按钮组">5.1  按钮组</h3><p><mark>QPushButton 常用按钮</mark></p><p><mark>QToolButton 工具按钮 用于显示图片，如图想显示文字，修改风格：toolButtonStyle ， 凸起风格autoRaise</mark></p><p><mark>radioButton 单选按钮，设置默认 ui-&gt;rBtnMan-&gt;setChecked(true);</mark></p><p><mark>checkbox多选按钮，监听状态，2 选中 1 半选 0 未选中</mark></p><h3 id="5-2-QListWidget-列表容器">5.2  QListWidget 列表容器</h3><p><mark>QListWidgetItem * item 一行内容</mark></p><p><mark>ui-&gt;listWidget -&gt;addItem ( item )</mark></p><p><mark>设置居中方式item-&gt;setTextAlignment(Qt::AlignHCenter);</mark></p><p><mark>可以利用addItems一次性添加整个诗内容</mark></p><h3 id="5-3-QTreeWidget-树控件">5.3  QTreeWidget 树控件</h3><h4 id="5-3-1-设置头">5.3.1  设置头</h4><p><mark>ui-&gt;treeWidget-&gt;setHeaderLabels(QStringList()&lt;&lt; “英雄”&lt;&lt; “英雄介绍”);</mark></p><h4 id="5-3-2-创建根节点">5.3.2  创建根节点</h4><p><mark>QTreeWidgetItem * liItem = new QTreeWidgetItem(QStringList()&lt;&lt; “力量”);</mark></p><h4 id="5-3-3-添加根节点-到-树控件上">5.3.3  添加根节点 到 树控件上</h4><p><mark>ui-&gt;treeWidget-&gt;addTopLevelItem(liItem);</mark></p><h4 id="5-3-4-添加子节点">5.3.4  添加子节点</h4><p><mark>liItem-&gt;addChild(l1);</mark></p><h3 id="5-4-QTableWidget-表格控件">5.4     QTableWidget 表格控件</h3><h4 id="5-4-1-设置列数">5.4.1  设置列数</h4><p><mark>ui-&gt;tableWidget-&gt;setColumnCount(3);</mark></p><h4 id="5-4-2-设置水平表头">5.4.2  设置水平表头</h4><p><mark>ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;“姓名”&lt;&lt; “性别”&lt;&lt; “年龄”);</mark></p><h4 id="5-4-3-设置行数">5.4.3  设置行数</h4><p><mark>ui-&gt;tableWidget-&gt;setRowCount(5);</mark></p><h4 id="5-4-4-设置正文">5.4.4  设置正文</h4><p><mark>ui-&gt;tableWidget-&gt;setItem(0,0, new QTableWidgetItem(“亚瑟”));</mark></p><h3 id="5-5-其他控件介绍">5.5 其他控件介绍</h3><h4 id="5-5-1-stackedWidget-栈控件">5.5.1  stackedWidget 栈控件</h4><p><mark>ui-&gt;stackedWidget-&gt;setCurrentIndex(1);</mark></p><h4 id="5-5-2-下拉框">5.5.2  下拉框</h4><p><mark>ui-&gt;comboBox-&gt;addItem(“奔驰”);</mark></p><h4 id="5-5-3-QLabel-显示图片">5.5.3  QLabel 显示图片</h4><p><mark>ui-&gt;lbl_Image-&gt;setPixmap(QPixmap(“:/Image/butterfly.png”))</mark></p><h4 id="5-5-4-QLabel显示动图-gif图片">5.5.4  QLabel显示动图 gif图片</h4><p><mark>ui-&gt;lbl_movie-&gt;setMovie(movie);</mark></p><p><mark>movie-&gt;start();</mark></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt学习笔记(上)</title>
      <link href="/2022/06/17/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%8A)/"/>
      <url>/2022/06/17/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<p><img src="https://bu.dusays.com/2022/12/31/63aff83d62ff8.png" alt="Qt5 模块.png"></p><h2 id="1-Qt简介">1.  Qt简介</h2><h3 id="1-1-跨平台图形界面引擎">1.1  跨平台图形界面引擎</h3><h3 id="1-2-历史">1.2  历史</h3><p><mark>1991 奇趣科技</mark></p><h3 id="1-3-优点">1.3  优点</h3><p><mark>跨平台</mark></p><p><mark>接口简单，容易上手</mark></p><p><mark>一定程度上简化了内存回收</mark></p><h3 id="1-4-版本">1.4  版本</h3><p><mark>商业版</mark></p><p><mark>开源版</mark></p><h3 id="1-5-成功案例">1.5  成功案例</h3><p><mark>Linux桌面环境 KDE</mark></p><p><mark>谷歌地图</mark></p><p><mark>VLC多媒体播放器</mark></p><h2 id="2-创建第一个Qt程序">2.  创建第一个Qt程序</h2><h3 id="2-1创建过程">2.1创建过程</h3><p><mark>点击创建项目后，选择项目路径以及给项目起名称</mark></p><p><mark>名称 - 不能有中文不能有空格</mark></p><p><mark>路径 - 不能有中文路径</mark></p><p><mark>默认创建有窗口类，myWidget，基类有三种选择： QWidget 、QMainWindow、QDialog</mark></p><h3 id="2-2-main函数">2.2  main函数</h3><p><mark>QApplication a 应用程序对象，有且仅有一个</mark></p><p><mark>myWidget w;实例化窗口对象</mark></p><p><mark>w.show()调用show函数 显示窗口</mark></p><p><mark>return a.exec() 让应用程序对象进入消息循环机制中，代码阻塞到当前行</mark></p><h2 id="3-按钮控件常用API">3.  按钮控件常用API</h2><p><mark>创建 QPushButton * btn = new QPushButton</mark></p><p><mark>设置父亲 setParent(this)</mark></p><p><mark>设置文本 setText(“文字”)</mark></p><p><mark>设置位置 move(宽，高)</mark></p><p><mark>重新指定窗口大小 resize</mark></p><p><mark>设置窗口标题 setWindowTitle</mark></p><p><mark>设置窗口固定大小 setFixedSize</mark></p><h2 id="4-对象树">4. 对象树</h2><p><mark>当创建的对象在堆区时候，如果指定的父亲是QObject派生下来的类或者QObject子类派生下来的类，可以不用管理释放的操作，将对象会放入到对象树中。</mark></p><p><mark>一定程度上简化了内存回收机制</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63aff83d6af71.png" alt="01.png"></p><h2 id="5-Qt中的坐标系">5. Qt中的坐标系</h2><p><mark>左上角为 0 ， 0 点</mark></p><p><mark>x以右为正方向</mark></p><p><mark>y以下为正方向</mark></p><h2 id="6-信号和槽">6. 信号和槽</h2><p><mark>连接函数 ：connect</mark></p><h3 id="6-1-参数">6.1     参数</h3><p><mark>参数1 信号的发送者</mark></p><p><mark>参数2 发送的信号（函数地址）</mark></p><p><mark>参数3 信号的接受者</mark></p><p><mark>参数4 处理的槽函数 （函数的地址）</mark></p><h3 id="6-2-松散耦合">6.2     松散耦合</h3><h3 id="6-3-实现-点击按钮-关闭窗口的案例">6.3     实现 点击按钮 关闭窗口的案例</h3><h3 id="6-4-connect-btn-QPushButton-click-this-QWidget-close">6.4     connect(btn , &amp;QPushButton::click , this , &amp;QWidget::close );</h3><p><img src="https://bu.dusays.com/2022/12/31/63aff83d612f3.png" alt="02.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63aff90cf379e.png" alt="n1.png"></p><h2 id="7-自定义信号和槽">7.    自定义信号和槽</h2><h3 id="7-1-自定义信号">7.1    自定义信号</h3><p><mark>写到 signals下</mark></p><p><mark>返回 void</mark></p><p><mark>需要声明，不需要实现</mark></p><p><mark>可以有参数 ，可以重载</mark></p><h3 id="7-2-自定义槽函数">7.2 自定义槽函数</h3><p><mark>返回void</mark></p><p><mark>需要声明 ，也需要实现</mark></p><p><mark>可以有参数 ，可以重载</mark></p><p><mark>写到 public slot下 或者public 或者全局函数</mark></p><h3 id="7-3-触发自定义的信号">7.3  触发自定义的信号</h3><p><mark>emit 自定义信号</mark></p><h3 id="7-4-案例-下课后，老师触发饿了信号，学生响应信号，请客吃饭">7.4 案例-下课后，老师触发饿了信号，学生响应信号，请客吃饭</h3><p><img src="https://bu.dusays.com/2022/12/31/63aff83d67e26.png" alt="n2.png"></p><h2 id="8-当自定义信号和槽出现重载">8 当自定义信号和槽出现重载</h2><p><mark>需要利用函数指针 明确指向函数的地址</mark></p><p><mark>void( Teacher:: * tSignal )( QString ) = &amp;Teacher::hungry;</mark></p><h3 id="8-1-QString-转成-char">8.1 QString 转成 char *</h3><p><mark>ToUtf8() 转为 QByteArray</mark></p><p><mark>Data() 转为 Char *</mark></p><h3 id="8-2-信号可以连接信号">8.2 信号可以连接信号</h3><h3 id="8-3-断开信号-disconnect">8.3 断开信号 disconnect</h3><h2 id="9-拓展">9 拓展</h2><p><mark>信号可以连接信号</mark></p><p><mark>一个信号可以连接多个槽函数</mark></p><p><mark>多个信号可以连接同一个槽函数</mark></p><p><mark>信号和槽函数的参数 必须类型一一对应</mark></p><p><mark>信号和槽的参数个数 是不是要一致？信号的参数个数 可以多余槽函数的参数个数</mark></p><p><mark>信号槽可以断开连接 disconnect</mark></p><h2 id="10-Qt4版本写法">10 Qt4版本写法</h2><p><mark>connect( 信号的发送者， 发送的信号SIGNAL( 信号) ，信号接受者， 槽函数SLOT(槽函数) )</mark></p><p><mark>优点 参数直观</mark></p><p><mark>缺点 编译器不会检测参数类型</mark></p><h2 id="11-Lambda表达式">11 Lambda表达式</h2><h3 id="11-1-标识符-匿名函数">11.1 []标识符 匿名函数</h3><p><mark>值传递</mark></p><p><mark>&amp; 引用传递</mark></p><h3 id="11-2-参数">11.2 () 参数</h3><h3 id="11-3-实现体">11.3 {} 实现体</h3><h3 id="11-4-mutable-修饰-值传递变量-，可以修改拷贝出的数据，改变不了本体">11.4 mutable 修饰 值传递变量 ，可以修改拷贝出的数据，改变不了本体</h3><h3 id="11-5-返回值-int">11.5 返回值 <a href=""></a> -&gt;int {}</h3>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决win10下SecureCRT SSH连接慢的问题</title>
      <link href="/2022/06/15/%E8%A7%A3%E5%86%B3win10%E4%B8%8BSecureCRT%20SSH%E8%BF%9E%E6%8E%A5%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/06/15/%E8%A7%A3%E5%86%B3win10%E4%B8%8BSecureCRT%20SSH%E8%BF%9E%E6%8E%A5%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近用SecureCRT连接远程服务器的时候，发现真的巨慢无比，真的无法忍受啊，于是在网上查阅了大约资料后，终于完美解决了问题</p><p>首先点击Options按钮，选择Session Options，如下图所示:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c8c0c35b05c2769b9c8f1d09e94d0e9b.png" alt=""></p><p>如上图所示，选择SSH2，找到Authenticiation中的GSSAPI,选中它，点击Properties弹出如下界面:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5ae48494bd390ca5b1129ea3cd6477e7.png" alt="img"></p><p>找到Method中的MS kerberos,然后选中它，点击OK,退出。</p><p>重新连接服务器，可以看到迅速连接上，问题完美解决。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/11b06521e022b61357c92e198cbaa44a.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算法总结</title>
      <link href="/2022/06/10/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/10/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1>1.背包问题</h1><h2 id="1-1递归">1.1递归</h2><h3 id="1-1-1普通递归方法">1.1.1普通递归方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">w[]  物品的重量</span></span><br><span class="line"><span class="comment">c[]  物品的价值</span></span><br><span class="line"><span class="comment">index 物品的数量（下标）</span></span><br><span class="line"><span class="comment">capacity 背包的容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> w[maxn], c[maxn], dp[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> w[], <span class="type">int</span> c[], <span class="type">int</span> index, <span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//基准条件：如果索引无效或者容量不足，直接返回当前价值0</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//不放第index个物品所得价值</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">solve</span>(w, c, index - <span class="number">1</span>, capacity);</span><br><span class="line">  <span class="comment">//放第index个物品所得价值（前提是：第index个物品可以放得下）</span></span><br><span class="line">    <span class="keyword">if</span> (w[index] &lt;= capacity) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, c[index] + <span class="built_in">solve</span>(w, c, index - <span class="number">1</span>, capacity - w[index]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, capacity;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;capacity);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">solve</span>(w, c, n, capacity);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-2记忆化搜索递归">1.1.2记忆化搜索递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> w[maxn], c[maxn], dp[maxn];</span><br><span class="line"><span class="type">int</span> memo[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> w[], <span class="type">int</span> c[], <span class="type">int</span> index, <span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//基准条件：如果索引无效或者容量不足，直接返回当前价值0</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//不放第index个物品所得价值</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">solve</span>(w, c, index - <span class="number">1</span>, capacity);</span><br><span class="line">  <span class="comment">//如果此子问题已经求解过，则直接返回上次求解的结果</span></span><br><span class="line">    <span class="keyword">if</span> (memo[index][capacity] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[index][capacity];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//放第index个物品所得价值（前提是：第index个物品可以放得下）</span></span><br><span class="line">    <span class="keyword">if</span> (w[index] &lt;= capacity) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, c[index] + <span class="built_in">solve</span>(w, c, index - <span class="number">1</span>, capacity - w[index]));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//添加子问题的解，便于下次直接使用</span></span><br><span class="line">    memo[index][capacity] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, capacity;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;capacity);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">solve</span>(w, c, n, capacity);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-动态规划算法">1.2.动态规划算法</h2><h3 id="1-2-1下标从1开始">1.2.1下标从1开始</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> w[maxn] = &#123; <span class="number">0</span> &#125;, c[maxn] = &#123; <span class="number">0</span> &#125;, dp[maxn] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, capacity;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;capacity);</span><br><span class="line">    <span class="comment">//vector&lt;vector&lt;int&gt; &gt; a(n + 1, vector&lt;int&gt;(capacity + 1));</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">30</span>][<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">                a[i][j] = a[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                a[i][j] = <span class="built_in">max</span>(a[i - <span class="number">1</span>][j], a[i - <span class="number">1</span>][j - w[i]] + c[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] &gt; max) &#123;</span><br><span class="line">                max = a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max=%d\n&quot;</span>, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2下标从0开始">1.2.2下标从0开始</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> w[maxn] = &#123; <span class="number">0</span> &#125;, c[maxn] = &#123; <span class="number">0</span> &#125;, dp[maxn] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, capacity;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;capacity);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">a</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(capacity + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//int a[30][30] = &#123;0&#125;;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= capacity; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w[<span class="number">0</span>] &lt; i) &#123;</span><br><span class="line">            a[<span class="number">0</span>][i] = c[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">                a[i][j] = a[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                a[i][j] = <span class="built_in">max</span>(a[i - <span class="number">1</span>][j], a[i - <span class="number">1</span>][j - w[i]] + c[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] &gt; max) &#123;</span><br><span class="line">                max = a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max=%d\n&quot;</span>, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-3-深度优先搜索">1.3.深度优先搜索</h2><h3 id="1-3-1常规算法">1.3.1常规算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n, V, maxvalue = <span class="number">0</span>; <span class="comment">//物品件数n，背包容量V，最大价值maxvalue</span></span><br><span class="line"><span class="type">int</span> w[maxn], c[maxn];   <span class="comment">//w[i]为每件物品的重量，c[i]为每件物品的价值</span></span><br><span class="line"><span class="comment">//DFS,index为当前处理物品的编号</span></span><br><span class="line"><span class="comment">//sumw和sumc为当前总重量和当前总价值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> sumw, <span class="type">int</span> sumc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == n) &#123;   <span class="comment">//已经完成对n件物品的选择(死胡同)</span></span><br><span class="line">        <span class="keyword">if</span> (sumw &lt;= V &amp;&amp; sumc &gt; maxvalue) &#123;</span><br><span class="line">            maxvalue = sumc;    <span class="comment">//不超过背包容量时更新背包的最大价值</span></span><br><span class="line">        &#125;</span><br><span class="line">        retusrn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//岔道口</span></span><br><span class="line">    <span class="built_in">DFS</span>(index + <span class="number">1</span>, sumw, sumc);     <span class="comment">//不选第index件物品</span></span><br><span class="line">    <span class="built_in">DFS</span>(index + <span class="number">1</span>, sumw + w[index], sumc + c[index]);       <span class="comment">//选择第index件物品</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;V);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);     <span class="comment">//每件物品的重量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);     <span class="comment">//每件物品的价值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, maxvalue);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-2优化时间复杂度-剪枝">1.3.2优化时间复杂度(剪枝)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n, V, maxvalue = <span class="number">0</span>; <span class="comment">//物品件数n，背包容量V，最大价值maxvalue</span></span><br><span class="line"><span class="type">int</span> w[maxn], c[maxn];   <span class="comment">//w[i]为每件物品的重量，c[i]为每件物品的价值</span></span><br><span class="line"><span class="comment">//DFS,index为当前处理物品的编号</span></span><br><span class="line"><span class="comment">//sumw和sumc为当前总重量和当前总价值ji</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> sumw, <span class="type">int</span> sumc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == n) &#123;   <span class="comment">//已经完成对n件物品的选择(死胡同)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(index + <span class="number">1</span>, sumw, sumc);     <span class="comment">//不选择第index件物品</span></span><br><span class="line">    <span class="comment">//只有加入第index件物品后未超过物品的容量V，才能继续</span></span><br><span class="line">    <span class="keyword">if</span> (sumw + w[index] &lt;= V) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumc + c[index] &gt; maxvalue) &#123;</span><br><span class="line">            maxvalue = sumc + c[index];     <span class="comment">//更新最大价值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">DFS</span>(index + <span class="number">1</span>, sumw + w[index], sumc + c[index]);       <span class="comment">//选择第index件物品</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;V);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);     <span class="comment">//每件物品的重量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);     <span class="comment">//每件物品的价值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, maxvalue);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>2.贪心算法</h1><h2 id="2-1-活动选择问题">2.1.活动选择问题</h2><p>有n个需要在同一天使用同一个教室的活动a1,a2,…,an，教室同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi 。一旦被选择后，活动ai就占据半开时间区间[si,fi)。如果[si,fi]和[sj,fj]互不重叠，ai和aj两个活动就可以被安排在这一天。该问题就是要安排这些活动使得尽量多的活动能不冲突的举行。例如下图所示的活动集合S，其中各项活动按照结束时间单调递增排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">aa</span> &#123;</span><br><span class="line"><span class="type">int</span> start;</span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(aa x, aa y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.end &lt; y.end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">src</span><span class="params">(<span class="type">int</span> n, aa s[], <span class="type">bool</span> a[])</span> </span>&#123;</span><br><span class="line">a[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i].start &gt; s[j].end) &#123;</span><br><span class="line">a[i] = <span class="literal">true</span>;</span><br><span class="line">j = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">a[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">aa s[maxn];</span><br><span class="line"><span class="type">bool</span> a[maxn] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; s[i].start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; s[i].end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(s + <span class="number">1</span>, s + <span class="number">1</span> + n, cmp);</span><br><span class="line"><span class="built_in">src</span>(n, s, a);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-最优装载问题">2.2.最优装载问题</h2><p>有一批集装箱要装上一艘载重量为c的轮船。其中集装箱i的重量为Wi。最优装载问题要求确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。(意思就是在不超过载重量的情况下最多能装多少)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">300</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> weigh[maxn];<span class="comment">//集装箱重量的数组</span></span><br><span class="line"><span class="type">int</span> num;<span class="comment">//定义集装箱的总数</span></span><br><span class="line"><span class="type">int</span> max;<span class="comment">//定义船的最大载重量</span></span><br><span class="line"><span class="type">int</span> result[maxn];<span class="comment">//定义可装载集装箱的数组</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;<span class="comment">//计数器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入船的最大载重量&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; max;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入集装箱的数量&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入每个集装箱的重量&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">cin &gt;&gt; weigh[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(weigh + <span class="number">1</span>, weigh + <span class="number">1</span> + num);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">sum = sum + weigh[i];</span><br><span class="line"><span class="keyword">if</span> (sum &lt;= max) &#123;</span><br><span class="line">result[count] = weigh[i];</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;可装载货物的重量分别为:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>3.递归与分治问题</h1><h2 id="3-1-n皇后问题">3.1.n皇后问题</h2><p>N皇后问题是一个经典的问题，在一个N*N的棋盘上放置N个皇后，每行一个并使其不能互相攻击（同一行、同一列、同一斜线上的皇后都会自动攻击）。</p><h3 id="3-1-1暴力法">3.1.1暴力法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> count1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n, p[maxn], hashtable[maxn] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generatep</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == n + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(i - j) == <span class="built_in">abs</span>(p[i] - p[j])) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">count1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line"><span class="keyword">if</span> (hashtable[x] == <span class="literal">false</span>) &#123;</span><br><span class="line">p[index] = x;</span><br><span class="line">hashtable[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">generatep</span>(index + <span class="number">1</span>);</span><br><span class="line">hashtable[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入棋盘的行列数&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">generatep</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2回溯法">3.1.2回溯法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> count1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n, p[maxn], hashtable[maxn] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generatep</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == n + <span class="number">1</span>) &#123;</span><br><span class="line">count1++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line"><span class="keyword">if</span> (hashtable[x] == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> pre = <span class="number">1</span>; pre &lt; index; pre++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(index - pre) == <span class="built_in">abs</span>(x - p[pre])) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">p[index] = x;</span><br><span class="line">hashtable[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">generatep</span>(index + <span class="number">1</span>);</span><br><span class="line">hashtable[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入棋盘的行列数&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">generatep</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-二分搜索">3.2.二分搜索</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarysearch</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> mid;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] == x) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123; <span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="comment">//quicksort(a, 0, 7);</span></span><br><span class="line"><span class="comment">/*bubblesort(a, 8);</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; 8; i++) &#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">x = <span class="built_in">binarysearch</span>(a, <span class="number">0</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-棋盘覆盖问题">3.3.棋盘覆盖问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">int</span> tile=<span class="number">1</span>;                   <span class="comment">//L型骨牌的编号(递增)  </span></span><br><span class="line"><span class="type">int</span> board[<span class="number">100</span>][<span class="number">100</span>];  <span class="comment">//棋盘  </span></span><br><span class="line"><span class="comment">/***************************************************** </span></span><br><span class="line"><span class="comment">* 递归方式实现棋盘覆盖算法 </span></span><br><span class="line"><span class="comment">* 输入参数： </span></span><br><span class="line"><span class="comment">* tr--当前棋盘左上角的行号 </span></span><br><span class="line"><span class="comment">* tc--当前棋盘左上角的列号 </span></span><br><span class="line"><span class="comment">* dr--当前特殊方格所在的行号 </span></span><br><span class="line"><span class="comment">* dc--当前特殊方格所在的列号 </span></span><br><span class="line"><span class="comment">* size：当前棋盘的:2^k </span></span><br><span class="line"><span class="comment">*****************************************************/</span>  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chessBoard</span> <span class="params">( <span class="type">int</span> tr, <span class="type">int</span> tc, <span class="type">int</span> dr, <span class="type">int</span> dc, <span class="type">int</span> size )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( size==<span class="number">1</span> )    <span class="comment">//棋盘方格大小为1,说明递归到最里层  </span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    <span class="type">int</span> t=tile++;     <span class="comment">//每次递增1  </span></span><br><span class="line">    <span class="type">int</span> s=size/<span class="number">2</span>;    <span class="comment">//棋盘中间的行、列号(相等的)  </span></span><br><span class="line">    <span class="comment">//检查特殊方块是否在左上角子棋盘中  </span></span><br><span class="line">    <span class="keyword">if</span> ( dr&lt;tr+s &amp;&amp; dc&lt;tc+s )              <span class="comment">//在  </span></span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr, tc, dr, dc, s );  </span><br><span class="line">    <span class="keyword">else</span>         <span class="comment">//不在，将该子棋盘右下角的方块视为特殊方块  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        board[tr+s<span class="number">-1</span>][tc+s<span class="number">-1</span>]=t;  </span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr, tc, tr+s<span class="number">-1</span>, tc+s<span class="number">-1</span>, s );  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//检查特殊方块是否在右上角子棋盘中  </span></span><br><span class="line">    <span class="keyword">if</span> ( dr&lt;tr+s &amp;&amp; dc&gt;=tc+s )               <span class="comment">//在  </span></span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr, tc+s, dr, dc, s );  </span><br><span class="line">    <span class="keyword">else</span>          <span class="comment">//不在，将该子棋盘左下角的方块视为特殊方块  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        board[tr+s<span class="number">-1</span>][tc+s]=t;  </span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr, tc+s, tr+s<span class="number">-1</span>, tc+s, s );  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//检查特殊方块是否在左下角子棋盘中  </span></span><br><span class="line">    <span class="keyword">if</span> ( dr&gt;=tr+s &amp;&amp; dc&lt;tc+s )              <span class="comment">//在  </span></span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr+s, tc, dr, dc, s );  </span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">//不在，将该子棋盘右上角的方块视为特殊方块  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        board[tr+s][tc+s<span class="number">-1</span>]=t;  </span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr+s, tc, tr+s, tc+s<span class="number">-1</span>, s );  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//检查特殊方块是否在右下角子棋盘中  </span></span><br><span class="line">    <span class="keyword">if</span> ( dr&gt;=tr+s &amp;&amp; dc&gt;=tc+s )                <span class="comment">//在  </span></span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr+s, tc+s, dr, dc, s );  </span><br><span class="line">    <span class="keyword">else</span>         <span class="comment">//不在，将该子棋盘左上角的方块视为特殊方块  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        board[tr+s][tc+s]=t;  </span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr+s, tc+s, tr+s, tc+s, s );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> size;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输入棋盘的size(大小必须是2的n次幂): &quot;</span>;  </span><br><span class="line">    cin&gt;&gt;size;  </span><br><span class="line">    <span class="type">int</span> index_x,index_y;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输入特殊方格位置的坐标: &quot;</span>;  </span><br><span class="line">    cin&gt;&gt;index_x&gt;&gt;index_y;  </span><br><span class="line">    <span class="built_in">chessBoard</span> ( <span class="number">0</span>,<span class="number">0</span>,index_x,index_y,size );  </span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++ )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> j=<span class="number">0</span>; j&lt;size; j++ )  </span><br><span class="line">            cout&lt;&lt;board[i][j]&lt;&lt;<span class="string">&#x27;/t&#x27;</span>;  </span><br><span class="line">        cout&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-4-循环赛日程表">3.4.循环赛日程表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 50</span></span><br><span class="line"><span class="comment">//打印盒子 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> game[][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cout &lt;&lt; game[i][j] &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归函数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">arrange</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> t, <span class="type">int</span> arr[][N])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//规格为4及以上，它的左上角和右上角要递归</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">arrange</span>(p, q, t / <span class="number">2</span>, arr);</span><br><span class="line">        <span class="built_in">arrange</span>(p, q + t / <span class="number">2</span>, t / <span class="number">2</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填左下角</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = p + t / <span class="number">2</span>; i &lt; p + t; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = q; j &lt; q + t / <span class="number">2</span>; j++) &#123;</span><br><span class="line">            arr[i][j] = arr[i - t / <span class="number">2</span>][j + t / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填右下角 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = p + t / <span class="number">2</span>; i &lt; p + t; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = q + t / <span class="number">2</span>; j &lt; q + t; j++) &#123;</span><br><span class="line">            arr[i][j] = arr[i - t / <span class="number">2</span>][j - t / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> game[N][N];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入选手人数:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//初始化第一行,其他全为0 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                game[i][j] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                game[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归 </span></span><br><span class="line">    <span class="built_in">arrange</span>(<span class="number">0</span>, <span class="number">0</span>, n, game);</span><br><span class="line">    <span class="comment">//打印输出循环赛日程表 </span></span><br><span class="line">    <span class="built_in">print</span>(n, game);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-马拦过河卒">3.5.马拦过河卒</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> total;  <span class="comment">//记录路径总数</span></span><br><span class="line"><span class="type">int</span> end_r,end_c;  <span class="comment">//记录B点</span></span><br><span class="line"><span class="type">int</span> hourse_r,hourse_c;  <span class="comment">//记录马所在位置</span></span><br><span class="line"><span class="type">int</span> wayr[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,wayc[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;  <span class="comment">//用于移动卒</span></span><br><span class="line"><span class="type">int</span> territory[<span class="number">9</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;&#125;;  <span class="comment">//协助标记马的控制范围</span></span><br><span class="line"><span class="type">bool</span> map[<span class="number">20</span>][<span class="number">20</span>];  <span class="comment">//用于标记马的控制范围</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>  <span class="comment">//判断是否出界</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;end_r||y&gt;end_c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(r+wayr[i],c+wayc[i])&amp;&amp;!map[r+wayr[i]][c+wayc[i]])  <span class="comment">//判断能否到达该点，即是否出界或者被马占领</span></span><br><span class="line">&#123;</span><br><span class="line">r+=wayr[i];  <span class="comment">//移动行</span></span><br><span class="line">c+=wayc[i];  <span class="comment">//移动列</span></span><br><span class="line"><span class="keyword">if</span>(r==end_r&amp;&amp;c==end_c) total++;  <span class="comment">//若到达B点，计数</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">dfs</span>(r,c);  <span class="comment">//递归调用，继续搜索</span></span><br><span class="line">r-=wayr[i];  <span class="comment">//回溯</span></span><br><span class="line">c-=wayc[i];  <span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;end_r&gt;&gt;end_c&gt;&gt;hourse_r&gt;&gt;hourse_c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)   <span class="comment">//标记马的控制范围</span></span><br><span class="line">map[hourse_r+territory[i][<span class="number">0</span>]][hourse_c+territory[i][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">//开始回溯</span></span><br><span class="line">cout&lt;&lt;total;  <span class="comment">//输出结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4,动态规划</h1><h2 id="4-1-矩阵连乘问题">4.1.矩阵连乘问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> A[N];<span class="comment">//矩阵规模</span></span><br><span class="line"><span class="type">int</span> m[N][N];<span class="comment">//最优解</span></span><br><span class="line"><span class="type">int</span> s[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MatrixChain</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> r, i, j, k;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)<span class="comment">//初始化对角线</span></span><br><span class="line">&#123;</span><br><span class="line">m[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">2</span>; r &lt;= n; r++)<span class="comment">//r个矩阵连乘</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - r + <span class="number">1</span>; i++)<span class="comment">//r个矩阵的r-1个空隙中依次测试最优点</span></span><br><span class="line">&#123;</span><br><span class="line">j = i + r - <span class="number">1</span>;</span><br><span class="line">m[i][j] = m[i][i]+m[i + <span class="number">1</span>][j] + A[i - <span class="number">1</span>] * A[i] * A[j];</span><br><span class="line">s[i][j] = i;</span><br><span class="line"><span class="keyword">for</span> (k = i + <span class="number">1</span>; k &lt; j; k++)<span class="comment">//变换分隔位置，逐一测试</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = m[i][k] + m[k + <span class="number">1</span>][j] + A[i - <span class="number">1</span>] * A[k] * A[j];</span><br><span class="line"><span class="keyword">if</span> (t &lt; m[i][j])<span class="comment">//如果变换后的位置更优，则替换原来的分隔方法。</span></span><br><span class="line">&#123;</span><br><span class="line">m[i][j] = t;</span><br><span class="line">s[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(i, s[i][j]);</span><br><span class="line"><span class="built_in">print</span>(s[i][j] + <span class="number">1</span>, j);<span class="comment">//递归1到s[1][j]</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n个矩阵</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MatrixChain</span>(n);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最佳添加括号的方式为：&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>, n);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n最小计算量的值为：&quot;</span> &lt;&lt; m[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-最长公共子序列">4.2.最长公共子序列</h2><p>给定两个字符串（或数字序列）A和B，求一个字符串，使得这个字符串是A和B的最长公共部分（子序列可以不连续）</p><p>eg：字符串&quot;sadstory&quot;和&quot;adminsorry&quot;的最长公共子序列为&quot;adsory&quot;,长度为6</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">gets_s</span>(a + <span class="number">1</span>, maxn);</span><br><span class="line"><span class="built_in">gets_s</span>(b + <span class="number">1</span>, maxn);</span><br><span class="line"><span class="type">int</span> lena = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> lenb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lena; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= lenb; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lenb; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[lena][lenb] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-数塔问题">4.3.数塔问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[maxn][maxn], dp[maxn][maxn];</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">cin &gt;&gt; f[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">dp[n][j] = f[n][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + f[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-最大连续子序列和">4.4.最大连续子序列和</h2><p>给定一个数字序列A1,A2,…,An,求i，j(1&lt;=i&lt;=j&lt;=n),使得Ai+…+Aj最大，输出这个最大和</p><p>eg:-2 11 -4 13 -5 -2 显然最大和为20</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> src[maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; src[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>] = src[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(src[i], dp[i - <span class="number">1</span>] + src[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i] &gt; dp[k]) &#123;</span><br><span class="line">k = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>5.常见排序</h1><h2 id="5-1-选择排序">5.1.选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectsort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> k = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[k]) &#123;</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(a[i], a[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[maxn] = &#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">selectsort</span>(a, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-插入排序">5.2.插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> temp = a[i], j = i;</span><br><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; temp &lt; a[j - <span class="number">1</span>]) &#123;</span><br><span class="line">a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[maxn] = &#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">insertsort</span>(a, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-冒泡排序">5.3.冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubblesort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123; <span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">bubblesort</span>(a, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-快速排序">5.4.快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a[left];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt; temp) right--;</span><br><span class="line">a[left] = a[right];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= temp) left++;</span><br><span class="line">a[right] = a[left];</span><br><span class="line">&#125;</span><br><span class="line">a[left] = temp;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> pos = <span class="built_in">partition</span>(a, left, right);</span><br><span class="line"><span class="built_in">quicksort</span>(a, left, pos - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">quicksort</span>(a, pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123; <span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">quicksort</span>(a, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;</span><br><span class="line">       <span class="number">8</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-归并排序">5.5.归并排序</h2><h3 id="5-5-1递归实现">5.5.1递归实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = l1, j = l2;</span><br><span class="line"><span class="type">int</span> temp[maxn], index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= r1 &amp;&amp; j &lt;= r2) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">temp[index++] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp[index++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= r1) temp[index++] = a[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r2) temp[index++] = a[j++];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">a[l1 + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">mergesort</span>(a, left, mid);</span><br><span class="line"><span class="built_in">mergesort</span>(a, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="built_in">merge</span>(a, left, mid, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[maxn] = &#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">mergesort</span>(a, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-2非递归实现">5.5.2非递归实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = l1, j = l2;</span><br><span class="line"><span class="type">int</span> temp[maxn], index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= r1 &amp;&amp; j &lt;= r2) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">temp[index++] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp[index++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= r1) temp[index++] = a[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r2) temp[index++] = a[j++];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">a[l1 + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort2</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">2</span>; step / <span class="number">2</span> &lt;= n; step *= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += step) &#123;</span><br><span class="line"><span class="type">int</span> mid = i + step / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mid + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line"><span class="built_in">merge</span>(a, i, mid, mid + <span class="number">1</span>, <span class="built_in">min</span>(i + step - <span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[maxn] = &#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">mergesort2</span>(a, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Robocup3d比赛环境的搭建及常用函数简介</title>
      <link href="/2022/06/04/Robocup3d%E6%AF%94%E8%B5%9B%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/06/04/Robocup3d%E6%AF%94%E8%B5%9B%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<!-- # Robocup3d比赛环境的搭建及常用函数简介 --><h2 id="1-比赛环境的搭建">1.比赛环境的搭建</h2><h3 id="1-1-查看本机wsl子系统的版本号">1.1 查看本机wsl子系统的版本号</h3><p><mark>wsl -l -v</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63afeecbd02aa.png" alt="wsl.png"></p><h3 id="1-2-导入命令">1.2 导入命令</h3><p>首先进入想要导入的目录，如图我在E盘中创建了wslstorage目录，将压缩包移到此目录下，打开cmd输入以下代码</p><p><mark>wsl --import ubuntu ./wsl ./Ubuntu.tar</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63afeecbd0260.png" alt="daoru.png"></p><blockquote><p>补充:</p><p>注销wsl子系统：<mark>wsl --unregister Ubuntu</mark></p></blockquote><p>成功导入以后，我们就基本完成了比赛环境的搭建，这之后我们还需要一个roboviz，可以让我们用肉眼观察到仿真足球赛中发生的状况，详细的下载地址可以看学长的博客，上面写的很详细https://blog.flyme.tech/2020/11/29/robocup3d_wsl/</p><p>一切完成后,大功告成</p><p>下面我给大家演示以下如何进入我们的比赛环境，在cmd中输入<mark>wsl</mark>命令进入wsl子系统，进入后，输入<mark>rcsoccersim3d</mark>命令，如下所示</p><p><img src="https://bu.dusays.com/2022/12/31/63afeecbd028e.png" alt="cwrc.png"></p><p>接着打开roboviz，这样我们环境的搭建就完成了。</p><p><img src="https://bu.dusays.com/2022/12/31/63afeecc15838.png" alt="play.png"></p><h2 id="2-常用函数简介">2.常用函数简介</h2><h3 id="WorldModel类">WorldModel类</h3><p>WorldModel类保存了场上许多的信息，是机器人利用场上信息的重要途径，它在机器人NaoBehavior中实例化了一个对象指针WorldModel。</p><p>在机器人策略中使用时，应使用worldmodel-&gt;方法名([参数列表])的形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前机器人的编号</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getUNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用于判断自己是几号，可以在策略中设定类似“如果是几号球员，就执行什么动作”</p><p>例如在初始化beam函数中，根据unum来分配球员位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是一号球员则它的位置是</span></span><br><span class="line"><span class="keyword">if</span> (worldModel -&gt; <span class="built_in">getUNum</span>() == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  beamX = <span class="number">-15</span>;</span><br><span class="line">  beamY = <span class="number">0</span>;</span><br><span class="line">  beamAngel = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ... (其他情况)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回比赛当前时间(距离开始的秒数)(返回的是一个浮点数)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">getGameTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gametime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前比赛的周期数(每一秒是20个周期，一个周期agent和server进行通讯,server进行仿真处理后将场上的信息返回发送给agent)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title">getCycle</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cycle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取编号为i的对象的位置(以下两函数仅名称不同，效果是一样的)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VecPosition <span class="title">getOpponent</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> worldObjects[i].pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> VecPosition <span class="title">getTeammate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> worldObjects[i].pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何利用这个函数来检索指定的球员的位置呢?</p><p>在头文件WorldObject.h中，定义了一个枚举worldObjType内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">WorldObjType</span> &#123;   <span class="comment">// Types of objects</span></span><br><span class="line">    WO_BALL,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Self and Teammates</span></span><br><span class="line">    WO_TEAMMATE1,</span><br><span class="line">    WO_TEAMMATE2,</span><br><span class="line">    WO_TEAMMATE3,</span><br><span class="line">    WO_TEAMMATE4,</span><br><span class="line">    WO_TEAMMATE5,</span><br><span class="line">    WO_TEAMMATE6,</span><br><span class="line">    WO_TEAMMATE7,</span><br><span class="line">    WO_TEAMMATE8,</span><br><span class="line">    WO_TEAMMATE9,</span><br><span class="line">    WO_TEAMMATE10,</span><br><span class="line">    WO_TEAMMATE11,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Opponents</span></span><br><span class="line">    WO_OPPONENT1,</span><br><span class="line">    WO_OPPONENT2,</span><br><span class="line">    WO_OPPONENT3,</span><br><span class="line">    WO_OPPONENT4,</span><br><span class="line">    WO_OPPONENT5,</span><br><span class="line">    WO_OPPONENT6,</span><br><span class="line">    WO_OPPONENT7,</span><br><span class="line">    WO_OPPONENT8,</span><br><span class="line">    WO_OPPONENT9,</span><br><span class="line">    WO_OPPONENT10,</span><br><span class="line">    WO_OPPONENT11,</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 后面还有很多比如关节什么的枚举量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>众所周知枚举类其实就是给整数起了个别名，例如此处第一个枚举WO_BALL</p><p>在代码中和0作用一样，此后的每一个枚举在前一个的基础上加1，所以检索球员的代码可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = WO_OPPONENT; i&lt;WO_OPPONENT + OPPONENT_NUM; i++)&#123;</span><br><span class="line">  VecPosition pos = worldModel-&gt;<span class="built_in">getOpponent</span>(i);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取编号为index的WorldObject的指针</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> WorldObject* <span class="title">getWorldObject</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;worldObjects[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文的getOpponent与此函数内容类似，都是在worldObjects数组中获取对应下标的对象</p><p>WorldObjects类描述了某物体(球，球员等)的一些基本属性，可以说，是WorldObject们构成了WorldModel。</p><p>关于WorldObjects类此处不展开介绍，其方法与属性都浅显易懂，有兴趣自行学习。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下还有一些常用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取此球员的位置</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VecPosition <span class="title">getMyPosition</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> myPosition;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取球的位置</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VecPosition <span class="title">getBall</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> worldObjects[WO_BALL].pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前比赛模式(比赛进行到不同阶段会有不同模式，比如任意球，门球...有兴趣可以查看源码自行观看)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VecPosition <span class="title">getPlayMode</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> playMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取机器人是否摔跤</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isFallen</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fFallen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Naobehaviors类">Naobehaviors类</h3><p>Naobehaviors类中有许许多多机器人可以执行的高级动作，怎么使用只要关注他的返回值即可，返回值为SkillType的可以直接在selectskill()中return（或者在其他返回值为SkillType的函数中return，比如gototarget()调用了gototargetrelative(),gototargetrelative调用了getwalk()等），返回值为VecPosition的可以用表达式和判断条件中，Bool类型的判断情况的函数，多用于条件判断。下面是一些常用的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NaoBehavior::beam</span><span class="params">( <span class="type">double</span>&amp; beamX, <span class="type">double</span>&amp; beamY, <span class="type">double</span>&amp; beamAngle )</span></span>;</span><br></pre></td></tr></table></figure><p>决定球员上场位置的函数，可以依次对不同的number给其beamX和beamY赋值，也可以都设为default</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">trim</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; value,<span class="type">const</span> <span class="type">double</span>&amp; min, <span class="type">const</span> <span class="type">double</span>&amp; max)</span></span>;</span><br></pre></td></tr></table></figure><p>trim:修剪。返回值为经过判断修改的value，满足大于min，小于max</p><p>---------------------------分割线(持续更新中)----------------------------</p>]]></content>
      
      
      <categories>
          
          <category> Robocup3d </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robocup3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令总结</title>
      <link href="/2022/06/02/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/02/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>Linux的命令有几百个，但是常用的并不多，这些命令我们并不需要全部掌握。如果在学习和工作中遇到了陌生的Linux命令，多查手册，多多使用，久而久之就能熟能生巧</p><p><mark>在这给大家推荐一个Linux命令在线中文手册，方便大家在遇到没见过的命令时查看</mark></p><p><a href="http://linux.51yip.com/">点我获取地址</a></p><p>本文介绍了Linux最基础的25个命令。</p><h2 id="1、重启和关机">1、重启和关机</h2><p>重启和关机需要系统管理员用户权限。</p><p>1）重启</p><p><mark>init 6 或 reboot</mark></p><p>2）关机</p><p><mark>init 0 或 halt</mark></p><p>如果没有执行关机命令，强制断电或关闭本地虚拟机的窗口，会导致Linux操作系统文件的损坏，严重的可能导致系统无法正常启动。</p><h2 id="2、清屏">2、清屏</h2><p><mark>clear</mark></p><p>清除当前屏幕上显示的内容。</p><p><mark>Ctrl+l</mark></p><p>换页，不清屏</p><h2 id="3、查看服务器的ip地址">3、查看服务器的ip地址</h2><p><mark>ip addr</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebe6469f06.png" alt="图片1.png"></p><p>上图中，框中显示的就是IP地址。</p><h2 id="4、时间操作">4、时间操作</h2><p>普通用户可以查看时间，但设置时区和时间要系统管理员用户登录 。</p><p>1）查看时间。</p><p><mark>date</mark></p><p>2）设置时区为中国上海时间（注意不是北京时间）。</p><p><mark>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</mark></p><p>3）设置时间。</p><p><mark>date -s “yyyy-mm-dd hh:mi:ss”</mark></p><p>例如：date -s “2020-01-02 12:35:28”</p><h2 id="5、查看日历">5、查看日历</h2><p><strong>基本语法</strong></p><p><mark>cal [选项] （功能描述：不加选项，显示本月日历）</mark></p><p>选项说明：具体某一年，显示当年的日历</p><p>1）查看当前月的日历</p><p><mark>cal</mark></p><p>2）查看2017年的日历</p><p><mark>cal 2017</mark></p><h2 id="6、目录和文件">6、目录和文件</h2><p>文件系统是像一棵树，树干是/（根）目录，树枝是子目录，树枝后面还有树枝（子目录中还有子目录），树枝最后是树叶，目录的最后是文件。</p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98af19f.png" alt="图片2.png"></p><p>严谨的说，文件名是由<strong>目录+文件名</strong>组成的。</p><p>对于目录和文件，有一些约定的表述，我们以/usr/etc/readme.txt为例。</p><p>1）<strong>全路径文件名</strong>包含了完整的目录名和文件名，即/usr/etc/readme.txt，还有一个称呼是“<strong>绝对路径文件名</strong>”。</p><p>2）readme.txt是文件名，它在/usr/etc目录中。</p><p>3）目录和文件的<strong>绝对路径</strong>是从根（/）算起，在任何时候都不会有岐义。</p><p>4）登录Linux后，一定处在目录树的某个目录中，这个目录称之为当前工作目录，简称<strong>当前目录</strong>。</p><p>5）目录和文件的<strong>相对路径</strong>是从当前工作目录算起，如果当前工作目录是/usr，etc/readme.txt等同于/usr/etc/readme.txt；如果当前工作目录是/usr/etc，readme.txt等同于/usr/etc/readme.txt。</p><p>6）用Linux的命令操作目录和文件的时候，采用绝对路径和相对路径都可以。</p><p>7）一个圆点.表示当前工作目录；</p><p>8）两个圆点…表示当前工作目录的上一级目录。</p><p><strong>理解绝对路径和相对路径的概念非常重要，在日常操作中，绝对路径和相对路径会同时使用，但是程序员在编写的程序中极少使用相对路径。</strong></p><p><mark>Linux具体目录结构</mark></p><table><thead><tr><th style="text-align:left"><strong>/lib</strong></th><th style="text-align:left">系统开机所需要最基本的动态链接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</th></tr></thead><tbody><tr><td style="text-align:left"><strong>/lost+found</strong></td><td style="text-align:left"><strong>一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</strong></td></tr><tr><td style="text-align:left"><strong>/etc [重点]</strong></td><td style="text-align:left"><strong>所有系统管理所需要的配置文件和子目录。my.conf</strong></td></tr><tr><td style="text-align:left"><strong>/usr</strong></td><td style="text-align:left"><strong>用户的很多应用程序和文件都放在这个目录下。类似于Windows下的program.files目录</strong></td></tr><tr><td style="text-align:left"><strong>/bin (重点)(usr/bin,/usr/local/bin)</strong></td><td style="text-align:left"><strong>是Binary的缩写，这个目录存放着经常使用的命令</strong></td></tr><tr><td style="text-align:left"><strong>/sbin (usr/sbin、/usr/local/sbin)</strong></td><td style="text-align:left"><strong>s就是 super user的意思，这里存放的是系统管理员使用的系统管理程序</strong></td></tr><tr><td style="text-align:left"><strong>/home [重点]</strong></td><td style="text-align:left"><strong>存放普通用户的主目录，在Linux中的每个用户都有一个自己的目录，一般该目录以用户的账号名命名</strong></td></tr><tr><td style="text-align:left"><strong>/root [重点]</strong></td><td style="text-align:left"><strong>该目录为系统管理员，超级权限者的用户目录</strong></td></tr><tr><td style="text-align:left"><strong>/boot</strong></td><td style="text-align:left"><strong>存放的启动Linux时使用的一些核心文件，包括一些链接文件和镜像文件</strong></td></tr><tr><td style="text-align:left"><strong>/proc</strong></td><td style="text-align:left"><strong>虚拟目录，是系统内存的映射，访问这个目录来获取系统信息。</strong></td></tr><tr><td style="text-align:left"><strong>/srv</strong></td><td style="text-align:left"><strong>service 的缩写，该目录是存放一些服务启动之后需要提取的数据</strong></td></tr><tr><td style="text-align:left"><strong>/sys</strong></td><td style="text-align:left"><strong>Linux2.6内核的一个很大变化，该目录安装了2.6内核中新出现的一个文件系统</strong></td></tr><tr><td style="text-align:left"><strong>/tmp</strong></td><td style="text-align:left"><strong>存放临时文件</strong></td></tr><tr><td style="text-align:left"><strong>/dev</strong></td><td style="text-align:left"><strong>类似于 windows的设备管理器,把所有的硬件用文件的形式存储</strong></td></tr><tr><td style="text-align:left"><strong>/media [重点]</strong></td><td style="text-align:left"><strong>Linux系统会自动识别一些设备,例如U盘、光驱等等,当识别后,Linux 会把识别的设备挂载到这个目录下。</strong></td></tr><tr><td style="text-align:left"><strong>/mnt [重点]</strong></td><td style="text-align:left"><strong>系统提供该目录是为了让用户临时挂载别的文件系统的,我们可以将外部的存储挂载在/mnt/上,然后进入该目录就可以查看里的内容了。d:/ myshare</strong></td></tr><tr><td style="text-align:left"><strong>/opt</strong></td><td style="text-align:left"><strong>这是给主机额外安装软件所摆放的目录。如安装 ORACLE数据库就可放到该目录下。默认为空。</strong></td></tr><tr><td style="text-align:left"><strong>/usr/local [重点]</strong></td><td style="text-align:left"><strong>这是另个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</strong></td></tr><tr><td style="text-align:left"><strong>/var [重点]</strong></td><td style="text-align:left"><strong>这个目录中存放着在不断扩充着的东西,习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</strong></td></tr><tr><td style="text-align:left"><strong>/selinux [security-enhanced linux] 类似 360</strong></td><td style="text-align:left"><strong>Selinux是一种安全子系统,它能控制程序只能访同特定文件。</strong></td></tr></tbody></table><h2 id="7、链接命令">7、链接命令</h2><p><strong>命令名称：ln</strong></p><p>命令英文原意：link</p><p>命令所在路径：/bin/ln</p><p>执行权限：所有用户</p><p><strong>语法：ln  -s  [原文件]  [目标文件]</strong></p><p><strong>-s  创建软链接(也称符号链接)</strong></p><p><strong>ln命令不带参数默认创建硬链接</strong></p><p>功能描述：生成链接文件</p><p>范例：</p><p><mark>ln -s  /etc/issue  /tmp/issue.soft</mark></p><p>创建文件/etc/issue的软链接/tmp/issue.soft</p><p><mark>ln  /etc/issue  /tmp/issue.hard</mark></p><p>创建文件/etc/issue的硬链接/tmp/issue.hard</p><p><strong>硬链接特征：</strong></p><p>1、相当于创建了源文件的副本，如果硬链接文件的内容修改了，那么源文件的内容也会改变。</p><p>2、通过文件的索引节点链接</p><p>3、只有在同一文件系统的文件才能创建硬链接，不能跨分区创建</p><p>4、不能针对目录使用</p><p><strong>软链接特征：</strong></p><p>1、软链接可以实现文件或者目录的共享，它就像Windows下的快捷方式一样</p><p>2、 软链接文件可以是指向任意一个文件系统下的任意文件或目录，不仅如此，软链接还可以指向一个不存在的文件，但是不能对不存在的文件创建硬链接</p><p>3、硬链接只能在同一文件系统下创建，那么软链接就不会有这个限制，可以理解为软链接的产生就是为了摆脱这个限制的</p><h2 id="8、查看当前工作目录">8、查看当前工作目录</h2><p><mark>pwd</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98b0ea6.png" alt="图片3.png"></p><h2 id="9、改变当前工作目录">9、改变当前工作目录</h2><p><mark>cd 目录名</mark></p><p>示例：</p><p>1）进入/tmp目录</p><p><mark>cd /tmp</mark></p><p>2）进入上一级目录</p><p><mark>cd …</mark></p><p>3）进入用户的主目录</p><p><mark>cd</mark></p><p><mark>cd~</mark></p><h2 id="10、列出目录和文件信息">10、列出目录和文件信息</h2><p><mark>语法：ls  选项[-ald]  [文件或目录]</mark></p><p><mark>-a    显示所有文件，包括隐藏文件</mark></p><p><mark>-l     详细信息显示</mark></p><p><mark>-d    查看目录属性</mark></p><p>ls是list的缩写，通过ls 命令不仅可以查看目录和文件信息，还可以目录和文件权限、大小、主人和组等信息。</p><p>选项-l列出目录和文件的详细信息。</p><p>选项-lt列出目录和文件的详细信息，按时间降序显示。</p><p>示例：</p><p>1）列出当前工作目录下全部的目录和文件名信息。</p><p><mark>ls</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98aff37.png" alt="图片4.png"></p><p>2）列出当前工作目录下全部的目录和文件名详细的信息。</p><p><mark>ls -l</mark></p><p>(下图信息内容会在文件权限那边详细介绍)</p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98b60e3.png" alt="图片5.png"></p><p>3）列出/home目录下全部的目录和文件。</p><p><mark>ls /home</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98afee8.png" alt="图片6.png"></p><p>4）正则表达式</p><p>正则表达式又称规则表达式、通配符，目录和文件名都支持正则表达式，正则表达式的规则比较多，在这里我只介绍最常用的两种：星号“*”和问号“?”。</p><p>星号“*”：匹配任意数量的字符。</p><p>问号“?”：匹配一个的字符。</p><p>5）列出/root/thread-cpp目录下以匹配*.cpp的目录和文件。</p><p><mark>ls /root/thread-cpp/*.cpp</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98b024b.png" alt="图片7.png"></p><p>6）列出/root/aaa目录下匹配*.sh的目录和文件，按时间降序显示。</p><p><mark>ls -lt /root/aaa/*.sh</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98b4709.png" alt="图片8.png"></p><h2 id="11、创建目录">11、创建目录</h2><p><mark>mkdir 目录名</mark></p><p>示例：</p><p>1）在当前工作目录下创建aaa目录。</p><p><mark>mkdir aaa</mark></p><p>2）在当前工作目录的aaa目录下创建bbb目录。</p><p><mark>mkdir aaa/bbb</mark></p><p>3）创建/tmp/aaa目录。</p><p><mark>mkdir /tmp/aaa</mark></p><h2 id="12、删除目录和文件">12、删除目录和文件</h2><p><mark>rm [-rf] 目录或文件列表</mark></p><p>选项-r可以删除目录，如果没有-r只能删除文件。</p><p>选项-f表示强制删除，不需要确认。</p><p>目录和文件列表中间用空格分隔。</p><p>示例：</p><p>1）删除当前工作目录下匹配*.log的文件。</p><p><mark>rm *.log</mark></p><p>2）强制删除当前工作目录下匹配*.log的文件。</p><p><mark>rm -f *.log</mark></p><p>3）删除/tmp/aaa目录和文件。</p><p><mark>rm -r /tmp/aaa</mark></p><p>4）强制删除/tmp目录下匹配exp*的全部目录和文件。</p><p><mark>rm -rf /tmp/exp*</mark></p><p>5）强制删除当前工作目录下的book和book.c文件</p><p><mark>rm -rf book book.c</mark></p><h2 id="13、移动目录和文件">13、移动目录和文件</h2><p><mark>mv 旧目录或文件名 新目录或文件名</mark></p><p>如果第二个参数是已经存在的目录，则把第一个参数（旧目录或文件名）移动到该目录中。</p><p>示例：</p><p>1）把当前工作目录中的book.c文件重命名为book1.c</p><p><mark>mv book.c book1.c</mark></p><p>2）如果/tmp/test3是一个已经存在的目录，以下命令将把当前工作目录下的book.c文件移动到/tmp/test3目录中。</p><p><mark>mv book.c /tmp/test3</mark></p><p>3）如果/tmp/test3目录不存在，以下命令将把当前工作目录下的book.c文件改名为/tmp/test3。</p><p><mark>mv book.c /tmp/test3</mark></p><h2 id="14、复制目录和文件">14、复制目录和文件</h2><p><mark>cp [-r] 旧目录或文件名 新目录或文件名</mark></p><p>选项-r可以复制目录，如果没有选项-r只能复制文件。</p><p>示例：</p><p>1）把当前工作目录下的book1.c文件复制为book2.c</p><p><mark>cp book1.c book2.c</mark></p><p>2）把当前工作目录下的aaa目录复制为bbb</p><p><mark>cp -r aaa bbb</mark></p><p>3）把当前工作目录下的book1.c文件复制为/tmp/book1.c</p><p><mark>cp book1.c /tmp/book1.c</mark></p><p><mark>cp book1.c /tmp/.</mark></p><p>以上两个命令的效果相同。</p><p>4）把当前工作目录下的aaa目录复制为/tmp/aaa</p><p><mark>cp -r aaa /tmp/aaa</mark></p><p><mark>cp -r aaa /tmp/.</mark></p><p>以上两个命令的效果相同。</p><h2 id="15、打包压缩和解包解压">15、打包压缩和解包解压</h2><p>tar命令用来打包压缩和解包解压文件，类似windows的winrar工具。</p><p><strong>语法：tar  选项[-zcf] [压缩后文件名] [目录]</strong></p><p><strong>-c    打包</strong></p><p><strong>-v    显示详细信息</strong></p><p><strong>-f     指定文件名</strong></p><p><strong>-z     打包同时压缩</strong></p><p>示例：</p><p>1）把当前工作目录的aaa、bbb和ccc目录打包压缩成123.tgz文件。</p><p><mark>tar zcvf 123.tgz aaa bbb ccc</mark></p><p>2）把/home/oracle/aaa、/home/oracle/bbb和/home/oracle/ccc目录打包压缩成/tmp/123.tgz文件。</p><p><mark>tar zcvf /tmp/123.tgz /home/oracle/aaa /home/oracle/bbb /home/oracle/ccc</mark></p><p><strong>tar命令解压缩语法：</strong></p><p><strong>-x     解包</strong></p><p><strong>-v    显示详细信息</strong></p><p><strong>-f     指定解压文件</strong></p><p><strong>-z     解压缩</strong></p><p>示例：</p><p>1）把/tmp/123.tgz压缩包文件在当前工作目录下解压。</p><p><mark>tar zxvf /tmp/123.tgz</mark></p><p>2）把/tmp/123.tgz压缩包文件在/tmp/aaa目录下解压。</p><p><mark>cd /tmp/aaa</mark></p><p><mark>tar zxvf /tmp/123.tgz</mark></p><p>注意：</p><p>1）用tar命令打包和解包的目录和文件没有绝对路径的说法，都成了相对的，在包中相对的。</p><p>2）用tar命令打包的文件，用winrar可以解开。</p><p>3）在Linux系统中，还有其它的打包压缩和解包解压命令，例如zip/unzip和gzip/gunzip。</p><h2 id="16、判断网络是否连通">16、判断网络是否连通</h2><p>Windows系统：</p><p><mark>ping -n 包的个数 ip地址或域名</mark></p><p>Linux系统：</p><p><mark>ping -c 包的个数 ip地址或域名</mark></p><p>ping用于确定本地主机是否能与另一台主机成功交换数据包，判断网络是否通畅。</p><p>127.0.0.1是指本地的ip地址，ping 127.0.0.1总是可以通的。</p><p>示例：</p><p>1）向本地主机（127.0.0.1）ping五个包。</p><p><mark>ping -c 5 127.0.0.1</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98b3a77.png" alt="图片9.png"></p><p>2）向百度（<a href="http://www.baidu.com">www.baidu.com</a>）的服务器ping五个包。</p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98b4709.png" alt="图片10.png"></p><p>百度的服务器是可以ping通的。</p><p>3）向谷歌（<a href="http://www.google.com">www.google.com</a>）的服务器ping五个包。</p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9968bae.png" alt="图片11.png"></p><p>谷歌的服务器是ping不通的。</p><h2 id="17、显示文本文件的内容">17、显示文本文件的内容</h2><p>显示文本文件的内容有三个命令：cat、more和tail。</p><p>1）cat命令</p><p><mark>cat 文件名</mark></p><p>cat命令一次显示整个文件的内容。</p><p><mark>cat main.cpp</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9989936.png" alt="图片12.png"></p><p>2）more命令</p><p><mark>more 文件名</mark></p><p>为了方便阅读，more命令分页显示文件的内容，按空格键显示下一页，按b键显上一页，按q键退出。</p><p>3）tail命令</p><p><mark>tail -f 文件名</mark></p><p>tail -f用于显示文本文件的最后几行，如果文件的内容有增加，就实时的刷新。对程序员来说，tail -f极其重要，可以动态显示后台服务程序的日志，用于调试和跟踪程序的运行。</p><h2 id="18、统计文本文件的行数、单词数和字节数">18、统计文本文件的行数、单词数和字节数</h2><p><mark>wc 文件名</mark></p><p>示例：</p><p>1）统计当前工作目录处book2*.c文件的行数、单词数和字节数。</p><p><mark>wc book2*.c</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd99a4327.png" alt="图片13.png"></p><h2 id="19、搜索文件中的内容">19、搜索文件中的内容</h2><p><mark>grep “内容” 文件名</mark></p><p>注意，如果内容中没有空格等特殊字符，可以不用双引号括起来。</p><p>示例：</p><p>1）在*.cpp文件中搜索thread</p><p><mark>grep thread *.cpp</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd99d076e.png" alt="图片14.png"></p><h2 id="20、搜索文件">20、搜索文件</h2><p><mark>find 目录名 -name 文件名 -print</mark></p><p>参数说明：</p><p>目录名：待搜索的目录，搜索文件的时候，除了这个目录名，还包括它的各级子目录。</p><p>文件名：待搜索的文件名匹配的规则。</p><p>示例：</p><p>1）从/tmp目录开始搜索，把全部的*.c文件显示出来。</p><p><mark>find /tmp -name *.c -print</mark></p><p>2）从当前工作目录开始搜索，把全部的*.c文件显示出来。</p><p><mark>find . -name *.c -print</mark></p><h2 id="21-、文件权限类">21 、文件权限类</h2><h3 id="21-1-文件属性">21.1 文件属性</h3><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属 的用户和组。</p><p><strong>1）从左到右的 10个字符表示，如图所示</strong></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9a03a67.png" alt="图片15.png"><br>如果没有权限，就会出现减号[ - ]。从左至右用0-9这些数字来表示:</p><p>（1）0首位表示类型 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等</p><ul class="lvl-0"><li class="lvl-2"><p>-代表文件</p></li><li class="lvl-2"><p>d 代表目录</p></li><li class="lvl-2"><p>l 链接文档(link file)；</p></li></ul><p>（2）第1-3位确定属主（该文件的所有者）拥有该文件的权限。—User</p><p>（3）第4-6位确定属组（所有者的同组用户）拥有该文件的权限，—Group</p><p>（4）第7-9位确定其他用户拥有该文件的权限 —Other<br><strong>2）rwx作用文件和目录的不同解释</strong></p><p>（1）作用到文件：</p><ul class="lvl-0"><li class="lvl-2"><p>[ r ]代表可读(read): 可以读取，查看</p></li><li class="lvl-2"><p>[ w ]代表可写(write): 可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.</p></li><li class="lvl-2"><p>[ x ]代表可执行(execute):可以被系统执行</p></li></ul><p>（2）作用到目录：</p><ul class="lvl-0"><li class="lvl-2"><p>[ r ]代表可读(read): 可以读取，可以ls查看目录内容</p></li><li class="lvl-2"><p>[ w ]代表可写(write): 可以修改，目录内创建+删除+重命名目录</p></li><li class="lvl-2"><p>[ x ]代表可执行(execute):可以进入该目录</p></li></ul><p><img src="https://bu.dusays.com/2022/12/30/63aebd9a2c723.png" alt="图片16.png"></p><p>（1）如果查看到是文件：链接数指的是硬链接个数。 （2）如果查看的是文件夹：链接数指的是子文件夹个数。</p><h3 id="21-2-chmod-改变权限">21.2 chmod 改变权限</h3><p>1）基本语法 如图 所示<img src="https://bu.dusays.com/2022/12/30/63aebd9a4b220.png" alt="图片17.png"><br>第一种方式变更权限</p><p><mark>chmod [{ugoa}{±=}{rwx}] 文件或目录</mark>第二种方式变更权限</p><p><mark>chmod [mode=421 ] [文件或目录]</mark><br>2）参数含义<br><mark>u:所属用户  g:所属组  o:其他人用户 a:所有人(u、g、o的总和)</mark></p><p>r=4 w=2 x=1 rwx=4+2+1=7<br>3）案例</p><p>(1)让houge.txt文件的所属用户具有执行权限<br><mark>chmod u+x houge.txt</mark><br>(2)让houge.txt文件的所属组具有执行权限<br><mark>chmod g+x houge.txt</mark></p><p>(3)去除houge.txt所属用户的执行权限,使其他用户具有执行权限<br><mark>chmod u-x,o+x houge.txt</mark></p><p>(4)采用数字的方式，设置文件所有者、所属组、其他用户都具有可读可写可执行权限。</p><p><mark>chmod 777 houge.txt</mark></p><p>(5)修改整个文件夹里面的所有文件的所有者、所属组、其他用户都具有可读可写可执行权限。</p><p><mark>chmod -R 777 xiyou/</mark></p><h2 id="22、用户组管理命令">22、用户组管理命令</h2><h3 id="22-1-增加用户组">22.1 增加用户组</h3><p><mark>groupadd 组名</mark></p><p>例如：</p><p><mark>groupadd dba</mark></p><h3 id="22-2-删除用户组">22.2 删除用户组</h3><p><mark>groupdel 组名</mark></p><p>例如：</p><p><mark>groupdel dba</mark></p><h3 id="22-3-查看创建了哪些组">22.3 查看创建了哪些组</h3><p><mark>cat /etc/group</mark></p><h2 id="23、用户管理命令">23、用户管理命令</h2><h3 id="23-1-增加用户">23.1 增加用户</h3><p><mark>useradd -n 用户名 -g 组名 -d 用户的主目录</mark></p><p>例如增加一个用户，用户名为jay，属于dba组，用户的主目录是/home/jay</p><p><mark>useradd -n jay -g dba -d /home/jay</mark></p><h3 id="23-2-删除用户">23.2 删除用户</h3><p><mark>userdel 用户名</mark></p><p>例如删除wucz用户。</p><p><mark>userdel jay</mark></p><h3 id="23-3-passwd设置用户密码">23.3 passwd设置用户密码</h3><p><mark>passwd [用户名]</mark></p><p>修改用户的密码，按提示两次输入新密码，如果两次输入的密码相同就修改成功。</p><p>普通用户只能修改自己的密码，只输入passwd就可以了，不能指定用户名。</p><p>系统管理员可以修改任何用户的密码，passwd后需要指定用户名。</p><p>例如设置用户jay的密码</p><p><mark>passwd jay</mark></p><h3 id="23-4-id查看用户是否存在">23.4 id查看用户是否存在</h3><p>例如查看用户jay是否存在</p><p><mark>id jay</mark></p><h3 id="23-5-查看创建了哪些用户">23.5 查看创建了哪些用户</h3><p><mark>cat /etc/passwd</mark></p><h3 id="23-6-切换用户">23.6 切换用户</h3><p>在命令提示符下输入： <mark>su</mark>，然后按提示输入root的密码后将切换到root用户。</p><p>从root用户切换到其它普通用户不需要输入密码，从普通用户切换到任何用户都需要输入密码。</p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9a63506.png" alt="图片18.png"></p><h2 id="24、修改目录和文件的主人和组">24、修改目录和文件的主人和组</h2><p><strong>chown 改变所有者</strong></p><p><mark>chown [-R] 用户名:组名 目录或文件名列表</mark></p><p>chown将目录或文件的拥有者修改为参数指定的用户名和组，目录或文件名列表用空格分隔。</p><p>-R 选项表示递归处理各级子目录。</p><p>示例：</p><p>1）将main.cpp的所有者改为jay</p><p><mark>chown jay main.cpp</mark></p><p>2）把/oracle/home和/oracle/base及其子目录的主人改为oracle，组改为dba。</p><p><mark>chown -R oracle:dba /oracle/home /oracle/base</mark></p><p><strong>chgrp 改变所属组</strong></p><p><mark>基本语法 chgrp [最终用户组] [文件或目录] （功能描述：改变文件或者目录的所属组）</mark></p><p>示例：</p><p>1）将main.cpp的组改为root</p><p><mark>chgrp root main.cpp</mark></p><h2 id="25、-磁盘查看和分区类">25、 磁盘查看和分区类</h2><h3 id="25-1-df查看磁盘空间使用情况">25.1 df查看磁盘空间使用情况</h3><p><mark>df  [选项] [挂载点</mark></p><p>选项：</p><p>-a 显示所有的文件系统信息，包括特殊文件系统，如 /proc、/sysfs</p><p>-h 使用习惯单位显示容量，如KB，MB或GB等</p><p>-T 显示文件系统类型</p><p>-m 以MB为单位显示容量</p><p>-k 以KB为单位显示容量。默认就是以KB为单位</p><p>示例：</p><p>查看磁盘使用情况:</p><p><mark>df -h</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9a87532.png" alt="图片19.png"></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9aad16b.png" alt="图片20.png"></p><h3 id="25-2-du查看文件和目录占用的磁盘空间">25.2 du查看文件和目录占用的磁盘空间</h3><p><mark>du [选项] [目录或文件名]</mark></p><p>选项：</p><p>-a 显示每个子文件的磁盘占用量。默认只统计 子目录的磁盘占用量</p><p>-h 使用习惯单位显示磁盘占用量，如KB，MB  或GB等</p><p>-s 统计总占用量，而不列出子目录和子文件的 占用量</p><p>示例：</p><p>查看当前用户主目录占用的磁盘空间大小:</p><p><mark>du -sh</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9ac8cf6.png" alt="图片21.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法快速入门</title>
      <link href="/2022/06/01/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/06/01/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- #                    Markdown语法快速入门 --><h2 id="1-代码块：">1.代码块：</h2><p>三个飘号组成：```+语言</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//代码块语法：</span><br><span class="line"><span class="code">```+语言</span></span><br><span class="line"><span class="code">```</span>java</span><br><span class="line"><span class="code">```shell</span></span><br></pre></td></tr></table></figure><h2 id="2-标题">2.标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题    </span></span><br><span class="line"><span class="section">###### 六级标题   </span></span><br><span class="line">CTRL+shift+1能看到大纲</span><br></pre></td></tr></table></figure><h2 id="3-字体">3.字体</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//加粗</span><br><span class="line"><span class="strong">**加粗的语言**</span></span><br><span class="line">//代码高亮显示</span><br><span class="line">==具体高亮的内容==</span><br><span class="line">//删除线</span><br><span class="line">~~被删除的文字~~</span><br><span class="line">//斜体</span><br><span class="line"><span class="emphasis">*斜体的内容*</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//加粗</p><p><strong>加粗的语言</strong></p><p>//代码高亮显示</p><p><mark>具体高亮的内容</mark></p><p>//删除线</p><p><s>被删除的文字</s></p><p>//斜体</p><p><em>斜体的内容</em></p><h2 id="4-引用">4.引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\\引用语法</span><br><span class="line">&gt;作者:billysturate</span><br><span class="line">&gt;&gt;作者:billysturate</span><br><span class="line">&gt;&gt;&gt;作者:billysturate</span><br><span class="line">&gt;&gt;&gt;&gt;作者:billysturate </span><br></pre></td></tr></table></figure><blockquote><p>作者:billysturate</p><blockquote><p>作者:billysturate</p><blockquote><p>作者:billysturate</p><blockquote><p>作者:billysturate</p></blockquote></blockquote></blockquote></blockquote><h2 id="5-分割线">5.分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">//分割线</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line">//分割线2</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><hr><hr><h2 id="6-图片插入">6.图片插入</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在线图片/本地图片</span><br><span class="line">![<span class="string">我的照片</span>](<span class="link">图片的路径</span>)</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2022/12/30/63aebaf125b6f.jpg" alt="jay.jpg"></p><h2 id="7-超链接">7.超链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//超链接语法</span><br><span class="line">[<span class="string">我的GitHub</span>](<span class="link">https://github.com/</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/">我的GitHub</a></p><h2 id="8-列表语法">8.列表语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//无需列表</span><br><span class="line"><span class="bullet">+</span> 目录1</span><br><span class="line"><span class="bullet">+</span> 目录2</span><br><span class="line"><span class="bullet">+</span> 目录3  </span><br><span class="line">  </span><br><span class="line">//有序列表</span><br><span class="line"><span class="bullet">1.</span> 序号1</span><br><span class="line"><span class="bullet">2.</span> 序号2</span><br><span class="line"><span class="bullet">3.</span> 序号3</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>目录1</p></li><li class="lvl-2"><p>目录2</p></li><li class="lvl-2"><p>目录3</p></li></ul><ol><li class="lvl-3"><p>序号1</p></li><li class="lvl-3"><p>序号2</p></li><li class="lvl-3"><p>序号3</p></li></ol><h2 id="9-表格">9.表格</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl+/显示源码</span><br><span class="line">ctrl+shift+1 显示目录 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/01/hello-world/"/>
      <url>/2022/06/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
