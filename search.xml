<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试用</title>
      <link href="/posts/5c689518.html"/>
      <url>/posts/5c689518.html</url>
      
        <content type="html"><![CDATA[<div style ="position: relative ; width :100%; height: 0; padding-bottom:75%;"><iframe src ="//https://www.jsvry.com/p/WoXD212z9m?scene_id=87152" scrolling ="no" border="0" frameborder="no" framespacing ="0" allowfullscreen ="true" style =" position: absolute; width :100%; height :100%; left:0; top:0;" ></iframe></div > I ]]></content>
      
      
      <categories>
          
          <category> VScode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode去掉拷贝来的代码前的行号</title>
      <link href="/posts/5c68951c.html"/>
      <url>/posts/5c68951c.html</url>
      
        <content type="html"><![CDATA[<div style ="position: relative ; width :100%; height: 0; padding-bottom:75%;"><iframe src ="//player.bilibili.com/player.html?aid=338331208&bvid=BV1NR4y1u7x8&cid=489425665&page=1" scrolling ="no" border="0" frameborder="no" framespacing ="0" allowfullscreen ="true" style =" position: absolute; width :100%; height :100%; left:0; top:0;" ></iframe></div > I <p>当我们从某些地方复制代码过来的时候，代码前面常常会显示行号，就像下面这样,真的很烦人呢</p><p><img src="https://img-blog.csdnimg.cn/eb894ace94374e1e87e68378f6d0c67e.png#pic_center" alt=""></p><blockquote><p>下面我来介绍一种方法，废话不多说</p></blockquote><p>在VSCode中用快捷键<code>Alt+Shift</code>的同时，选中前面的行号(光标最好先移动到要删除的第一行的上面一行)开始往下选中，这样会更好操作一些，效果就像下面这样：</p><p><img src="https://img-blog.csdnimg.cn/185918b4881a466494ebe6b1a4d892b9.png#pic_center" alt=""></p><p>然后直接按删除键</p><p><img src="https://img-blog.csdnimg.cn/9c4961327dcf463a848ea3a6782ceb0e.png#pic_center" alt=""></p><p>这样就大功告成啦，是不是很简单呢</p>]]></content>
      
      
      <categories>
          
          <category> VScode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HTML基础】基础认知 + HTML标签</title>
      <link href="/posts/f5f81e3d.html"/>
      <url>/posts/f5f81e3d.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTML基础结构标签">1.HTML基础结构标签</h2><p>每个网页都会有一个基础的结构标签（骨架标签：4组），页面内容也是在这些基础标签上书写的。</p><blockquote><p>HTML 页面也称为 HTML 文档。</p></blockquote><p>【HTML 基础结构】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>标签名</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;html&gt;</code> <code>&lt;/html&gt;</code></td><td>根标签</td><td>页面中最大的标签（最基础的标签）</td></tr><tr><td><code>&lt;head&gt;</code> <code>&lt;/head&gt;</code></td><td>头部标签</td><td>在 head 标签中我们必须要设置 title 标签</td></tr><tr><td><code>&lt;title&gt;</code> <code>&lt;/title&gt;</code></td><td>标题标签</td><td>页面自己的网页标题</td></tr><tr><td><code>&lt;body&gt;</code> <code>&lt;/body&gt;</code></td><td>主体标签</td><td>包含文档的所有内容</td></tr></tbody></table><blockquote><p>在VsCode中按快捷键<code>!</code>号即可快速生成基础结构,如下图所示</p></blockquote><p><img src="https://img-blog.csdnimg.cn/e881437e5a4348d1848c6a6a6b7ef9c4.png#pic_center" alt=""></p><h2 id="2-HTML中的注释">2.HTML中的注释</h2><p>如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的文字，就需要使用注释标签。</p><p>HTML 中的注释以：<code>&lt;!--</code> 开头，以 <code>--&gt;</code> 结束。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释语句 --&gt;</span></span><br></pre></td></tr></table></figure><p>一句话：注释标签里面的内容是给程序员看的，这个代码是不执行不显示到页面中的。</p><blockquote><p>注释是为了更好地解释代码功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的。</p><p>VsCode中的快捷键是Ctrl+/</p></blockquote><h2 id="3-HTML常用标签">3.HTML常用标签</h2><h3 id="3-1-标题标签和段落标签">3.1 标题标签和段落标签</h3><p><strong>标题标签</strong>:</p><p>为了使网页更具有语义化，我们经常会在页面中用到标题标签。</p><p>HTML 提供了 6 个等级的网页标题，即：<code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code>。</p><blockquote><p>VsCode中快捷键为h1+Tab</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单词 head 的缩写，意为：头部、标题。</p></blockquote><p><strong>段落标签</strong>:</p><p>在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示，在 HTML 标签中，<code>&lt;p&gt;</code> 标签用于定义段落，它可以将整个网页分为若干个段落。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个段落标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单词 paragraph 的缩写，意为：段落。</p></blockquote><h3 id="3-2-换行标签和分割线标签">3.2 换行标签和分割线标签</h3><p><strong>换行标签</strong>:</p><p>在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。</p><p>如果希望某段文本强制换行显示，就需要使用换行标签  <code>&lt;br&gt;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单词 break 的缩写，意为：打断、换行。</p></blockquote><p><strong>分割线标签</strong>:<br>分割线标签：<code>&lt;hr&gt;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 某些时候需要对内容块进行分割时会用到分割线标签 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-文本格式化标签">3.3 文本格式化标签</h3><p>在网页中，有时需要为文字设置粗体、斜体或下划线等效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的方式显示。</p><p>**标签语义：**突出重要性，比普通文字更重要。</p><table><thead><tr><th>语义</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>加粗</td><td><code>&lt;strong&gt;</code> <code>&lt;/strong&gt;</code> 或 <code>&lt;b&gt;</code> <code>&lt;/b&gt;</code></td><td>介于可读性、搜索引擎优化及屏幕阅读器适配推荐使用前者</td></tr><tr><td>倾斜</td><td><code>&lt;em&gt;</code> <code>&lt;/em&gt;</code> 或 <code>&lt;i&gt;</code> <code>&lt;/i&gt;</code></td><td>介于可读性、搜索引擎优化及屏幕阅读器适配推荐使用前者</td></tr><tr><td>删除线</td><td><code>&lt;del&gt;</code> <code>&lt;/del&gt;</code> 或 <code>&lt;s&gt;</code> <code>&lt;/s&gt;</code></td><td>介于可读性、搜索引擎优化及屏幕阅读器适配推荐使用前者</td></tr><tr><td>下划线</td><td><code>&lt;ins&gt;</code> <code>&lt;/ins&gt;</code> 或 <code>&lt;u&gt;</code> <code>&lt;/u&gt;</code></td><td>介于可读性、搜索引擎优化及屏幕阅读器适配推荐使用前者</td></tr></tbody></table><h3 id="3-4-图像标签">3.4 图像标签</h3><p>在 HTML 标签中，<code>&lt;img&gt;</code> 标签用于定义 HTML 页面中的图像。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单词 image 的缩写，意为图像。</p></blockquote><p><code>src</code> 是 <code>&lt;img&gt;</code> 标签的必须属性，它用于指定图像文件的路径和文件名。</p><p><code>URL</code> 是 <code>统一资源定位符</code>（通俗理解：地址、网址）。</p><p>所谓属性：简单理解就是属于这个图像标签的特性。</p><p><strong>图像标签的其他属性：</strong></p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td><code>src</code></td><td>图片路径</td><td>必须属性</td></tr><tr><td><code>alt</code></td><td>文本</td><td>替换文本，图像显示失败时显示（为了提高 SEO 及适配屏幕阅读器，建议都把 alt 写上）</td></tr><tr><td><code>title</code></td><td>文本</td><td>提示文本，鼠标放到图片上，显示的提示文字</td></tr><tr><td><code>width</code></td><td>像素</td><td>设置图像的宽度（了解，后面通过 CSS 设置）</td></tr><tr><td><code>height</code></td><td>像素</td><td>设置图像的高度（了解，后面通过 CSS 设置）</td></tr><tr><td><code>border</code></td><td>像素</td><td>设置图像的边框粗细（了解，后面通过 CSS 设置）</td></tr></tbody></table><blockquote><p>设置图像的宽度与高度时：一般设置其中之一便可，另外一个会自动按比例适配</p></blockquote><h3 id="3-5-音频标签">3.5 音频标签</h3><ul class="lvl-0"><li class="lvl-2"><p>场景：在页面中插入音频</p></li><li class="lvl-2"><p>代码：<code>&lt;audio src=&quot;./music.mp3&quot; controls&gt;&lt;/audio&gt;</code></p></li><li class="lvl-2"><p>常见属性:</p><ul class="lvl-2"><li class="lvl-4">src音频的路径</li><li class="lvl-4">controls      显示播放的控件</li><li class="lvl-4">autoplay      自动播放(部分浏览器不支持)</li><li class="lvl-4">loop              循环播放</li></ul></li><li class="lvl-2"><p>注意点：</p><ul class="lvl-2"><li class="lvl-4">音频标签目前支持三种格式：Mp3,Wav,Ogg</li></ul></li></ul><h3 id="3-6-视频标签">3.6 视频标签</h3><ul class="lvl-0"><li class="lvl-2"><p>场景：在页面中插入视频</p></li><li class="lvl-2"><p>代码：<code>&lt;video src=&quot;./video.mp4&quot; controls&gt;&lt;/video&gt;</code></p></li><li class="lvl-2"><p>常见属性:</p><ul class="lvl-2"><li class="lvl-4">src音频的路径</li><li class="lvl-4">controls      显示播放的控件</li><li class="lvl-4">autoplay      自动播放(谷歌浏览器需配合muted实现静音播放)</li><li class="lvl-4">loop              循环播放</li></ul></li><li class="lvl-2"><p>注意点：</p><ul class="lvl-2"><li class="lvl-4">音频标签目前支持三种格式：Mp4,WebM,Ogg</li></ul></li></ul><h3 id="3-7-超链接标签">3.7 超链接标签</h3><p>在 HTML 标签中，<code>&lt;a&gt;</code> 标签用于定义超链接，作用是从一个页面链接到另一个页面。</p><p><strong>（1）链接的语法格式</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;跳转目标&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span>文本、图像或其他内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单词 <strong>anchor</strong> 的缩写，意为：锚。</p></blockquote><p><strong>两个属性的作用如下：</strong></p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>href</code></td><td>用于指定链接目标的 url 地址，（必须属性）当标签应用 href 属性时，它就具有了超链接的功能</td></tr><tr><td><code>target</code></td><td>用于指定链接页面的打开方式，其中 <code>_self</code> 在当前页面打开的方式（为默认值），<code>_blank</code> 在新窗口中打开的方式</td></tr></tbody></table><h2 id="4-列表标签">4.列表标签</h2><p>列表最大的特点就是：整齐、整洁、有序、它作为布局会更加自由和方便。</p><p>在实际开发中凡是遇到排列整齐的简洁内容，都可以使用列表来进行布局。</p><p>合理的使用列表布局可以有效提高 SEO。</p><p>根据使用情景不同，列表可以分为三大类：<code>无序列表</code>、<code>有序列表</code> 和 <code>自定义列表</code>。</p><table><thead><tr><th>标签名</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;ul&gt;</code> <code>&lt;/ul&gt;</code></td><td>无序标签</td><td>里面<strong>只包含 li</strong>，没有顺序，使用较多，li 里面可以包含任何标签</td></tr><tr><td><code>&lt;ol&gt;</code> <code>&lt;/ol&gt;</code></td><td>有序标签</td><td>里面<strong>只包含 li</strong>，有顺序，使用相对较少，li 里面可以包含任何标签</td></tr><tr><td><code>&lt;dl&gt;</code> <code>&lt;/dl&gt;</code></td><td>自定义标签</td><td>里面<strong>只能包含 dt 和 dd</strong>，dt 和 dd 里面可以放任何标签，dd 一般作为对 dt 的细分描述</td></tr></tbody></table><h3 id="4-1-无序列表">4.1 无序列表</h3><p><code>&lt;ul&gt;</code> 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 <code>&lt;li&gt;</code> 标签定义（开发中经常使用）。</p><p><strong>无序列表的基本语法格式如下：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>火龙果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>无序列表的各个列表项之间没有顺序级别之分，是并列的</p></li><li class="lvl-2"><p><code>&lt;ul&gt;</code> <code>&lt;/ul&gt;</code> 中只能嵌套 <code>&lt;li&gt;</code> <code>&lt;/li&gt;</code>，直接在 <code>&lt;ul&gt;</code> <code>&lt;/ul&gt;</code> 标签中输入其他标签或者文字的做法是不被允许的，列表中的任何内容都应该放在 <code>li</code> 中</p></li><li class="lvl-2"><p><code>&lt;li&gt;</code> 与 <code>&lt;/li&gt;</code> 之间相当于一个容器，可以容纳所有的元素</p></li><li class="lvl-2"><p>无序列表会带有自己的样式属性（比如圆点），但在实际开发中，我们会使用 CSS 来设置</p></li></ul><p>效果演示:</p><p><img src="https://img-blog.csdnimg.cn/74fc2a70b9d14f248cc7c21742784951.png#pic_center" alt=""></p><h3 id="4-2-有序列表">4.2 有序列表</h3><p>有序列表即为有序排列顺序的列表，其各个列表项会按照一定的顺序排列定义（开发中不太常用）。</p><p>在 HTML 标签中，<code>&lt;ol&gt;</code> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <code>&lt;li&gt;</code> 标签来定义列表项。</p><p><strong>有序列表的基本语法格式如下：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>100<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>80<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>70<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;ol&gt;</code> <code>&lt;/ol&gt;</code> 中只能嵌套 <code>&lt;li&gt;</code> <code>&lt;/li&gt;</code>，直接在 <code>&lt;ol&gt;</code> <code>&lt;/ol&gt;</code> 标签中输入其他标签或者文字的做法是不被允许的</p></li><li class="lvl-2"><p><code>&lt;li&gt;</code> 与 <code>&lt;/li&gt;</code> 之间相当于一个容器，可以容纳所有的元素</p></li><li class="lvl-2"><p>有序列表会带有自己样式属性（比如序号），但在实际使用时，我们会使用 CSS 来设置</p></li></ul><p>效果演示:</p><p><img src="https://img-blog.csdnimg.cn/2478d0821d2d4eafb4edd7dc36d3f7e9.png#pic_center" alt=""></p><h3 id="4-3-自定义列表">4.3 自定义列表</h3><p><strong>自定义列表的使用场景：</strong></p><p>自定义列表常用于对术语或名词进行解释、描述和展开，定义列表的列表项前没有任何项目符号（开发中常用）。</p><p>在 HTML 标签中，<code>&lt;dl&gt;</code> 标签用于定义描述列表（或定义列表），该标签会与 <code>&lt;dt&gt;</code>（定义项目/名字）和 <code>&lt;dd&gt;</code>（描述每一个项目/名字）一起使用。</p><p>其基本语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>帮助中心<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>账户管理<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>用户指南<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;dl&gt;</code> <code>&lt;/dl&gt;</code> 里面只包含 <code>&lt;dt&gt;</code>、<code>&lt;dd&gt;</code></p></li><li class="lvl-2"><p><code>&lt;dt&gt;</code> 和 <code>&lt;dd&gt;</code> 个数没有限制，经常是一个 <code>&lt;dt&gt;</code> 对应多个 <code>&lt;dd&gt;</code></p></li><li class="lvl-2"><p><code>dd</code>前会默认显示缩进效果</p></li></ul><p><img src="https://img-blog.csdnimg.cn/a7398317a0e94b34a35bdd58d4242a0b.png#pic_center" alt=""></p><h2 id="5-表格标签">5.表格标签</h2><h3 id="5-1-表格的基本语法">5.1 表格的基本语法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;table&gt;</code> <code>&lt;/table&gt;</code> 是用于定义表格的标签</p></li><li class="lvl-2"><p><code>&lt;tr&gt;</code> <code>&lt;/tr&gt;</code> 用于定义表格中的行，必须嵌套在 <code>&lt;table&gt;</code> <code>&lt;/table&gt;</code> 标签中</p></li><li class="lvl-2"><p><code>&lt;td&gt;</code> <code>&lt;/td&gt;</code> 用于定义表格中的单元格，必须嵌套在 <code>&lt;tr&gt;</code> <code>&lt;/tr&gt;</code> 标签中</p></li><li class="lvl-2"><p>字母 td 指表格数据（table data），即：数据单元格的内容</p></li><li class="lvl-2"><p>单元格 td 里面可以放任何的元素</p></li></ul><h3 id="5-2-表头单元格和表格标题">5.2 表头单元格和表格标题</h3><p>一般表头单元格位于表格的第一行或第一列，作用是：突出重要性，表头单元格里面的文本内容<strong>默认加粗居中</strong>显示。</p><p><code>&lt;th&gt;</code> 标签表示 HTML 表格的表头部分（table head 的缩写）。</p><p><code>&lt;caption&gt;</code>标签表示表格整体大标题，默认在表格整体顶部剧中位置设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 表格 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生成绩单<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">th</span>&gt;</span>评语<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>小哥哥<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>小姐姐<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>总结<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码展示：</p><p><img src="https://img-blog.csdnimg.cn/63b0f5c81b0d4b019bc1480dafee4ac1.png#pic_center" alt=""></p><h3 id="5-3-表格属性">5.3 表格属性</h3><p>**注意：**表格标签的属性在实际开发中并不常用，而是通过后面的 CSS 来设置，这里了解即可。</p><p>以下属性都写在 table 开始标签内，多个属性之间用空格隔开。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">属性值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>align</code></td><td style="text-align:left"><code>left</code>、<code>center</code>、<code>right</code></td><td style="text-align:left">规定表格相对周围元素的对齐方式（默认 left），注意指的是整个表格的对齐方式（表格是在父盒子中默认往左靠，还是居中或是往右靠），而不是指单元格内容的对齐方式（单元格内容对齐可以通过：<code>style=&quot;text-align: center;&quot;</code> 设置）（了解）</td></tr><tr><td style="text-align:left"><code>border</code></td><td style="text-align:left"><code>1</code> 或 <code>&quot;&quot;</code></td><td style="text-align:left">规定表格单元是否拥有边框，默认为 “”，表示没有边框（了解）</td></tr><tr><td style="text-align:left"><code>cellpadding</code></td><td style="text-align:left">像素值</td><td style="text-align:left">规定单元边沿与其内容之间的空白，默认 1 像素（了解）</td></tr><tr><td style="text-align:left"><code>cellspacing</code></td><td style="text-align:left">像素值</td><td style="text-align:left">规定单元格之间的空白，默认 2 像素（了解）</td></tr><tr><td style="text-align:left"><code>width</code></td><td style="text-align:left">像素值 或 百分比</td><td style="text-align:left">规定表格的宽度（了解）</td></tr><tr><td style="text-align:left"><code>height</code></td><td style="text-align:left">像素值 或 百分比</td><td style="text-align:left">规定表格的高度（了解）</td></tr></tbody></table><h3 id="5-4-表格的结构标签">5.4 表格的结构标签</h3><p>场景：让表格的内容结构分组，突出表格的不同部分(头部，主体，底部)，使语义更加清晰</p><p>结构标签:</p><table><thead><tr><th><strong>标签名</strong></th><th>名称</th></tr></thead><tbody><tr><td>thead</td><td>表格头部</td></tr><tr><td>tbody</td><td>表格主题</td></tr><tr><td>tfoot</td><td>表格底部</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生成绩单<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>评语<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>小哥哥<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>小姐姐<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>总结<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4274f0a208c24134b7688e7dd042ba94.png#pic_center" alt=""></p><h3 id="5-5-合并单元格">5.5 合并单元格</h3><p>特殊情况下，可以把多个单元格合并为一个单元格，这里会最简单的合并单元格即可。</p><p><strong>合并单元格的方式：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>跨行合并（上下合并）：<code>rowspan=&quot;合并单元格的个数&quot;</code></p></li><li class="lvl-2"><p>跨列合并（左右合并）：<code>colspan=&quot;合并单元格的个数&quot;</code></p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>优秀学生信息表格<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年纪<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>班级<span class="tag">&lt;/<span class="name">th</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>高三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>110<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>三年二班<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>赵四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>120<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>三年二班<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>评语<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>你们都很优秀<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7b3979e98b24465d823acc4b28bf8392.png#pic_center" alt=""></p><h2 id="6-表单标签">6.表单标签</h2><h3 id="6-1-input系列标签">6.1 input系列标签</h3><p>在英文单词中，input 是输入的意思，而在表单元素中 <code>&lt;input&gt;</code> 标签用于收集用户信息，如：登录页，注册页。</p><p>在 <code>&lt;input&gt;</code> 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本、字段、复选框、掩码后的文本控件、单选按钮、按钮等）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;input /&gt;</code> 标签为单标签</p></li><li class="lvl-2"><p>type 属性设置不同的属性值用来指定不同的控件类型</p></li></ul><p><strong>type 属性的属性值及其描述如下：</strong></p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>button</code></td><td>定义可点击按钮，默认无功能（多数情况下，用于通过 JavaScript 启动脚本）</td></tr><tr><td><code>checkbox</code></td><td>定义复选框，即：多选框，在一组多选中，要求它们必须拥有相同的 name</td></tr><tr><td><code>file</code></td><td>定义输入字段和 “浏览” 按钮，供文件上传，只能单文件，加上multiple属性值，可以实现多文件</td></tr><tr><td><code>hidden</code></td><td>定义隐藏的输入字段</td></tr><tr><td><code>image</code></td><td>定义图像形式的提交按钮</td></tr><tr><td><code>password</code></td><td>定义密码字段，该字段中的字符被掩码</td></tr><tr><td><code>radio</code></td><td>定义单选按钮，在一组单选按钮中，要求它们必须拥有相同的 name</td></tr><tr><td><code>reset</code></td><td>定义重置按钮，重置按钮会清除表单中的所有数据</td></tr><tr><td><code>submit</code></td><td>定义提交按钮，提交按钮会把表单数据发送到服务器</td></tr><tr><td><code>text</code></td><td>定义单行的输入字段，用户可在其中输入文本，默认宽度为 20 个字符</td></tr></tbody></table><p><strong>除 type 属性外，<code>&lt;input&gt;</code> 标签还有很多其他属性，其常用属性如下：</strong></p><table><thead><tr><th>属性名</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>name</code></td><td>由用户自定义</td><td>定义 input 元素的名称</td></tr><tr><td><code>value</code></td><td>由用户自定义</td><td>规定 input 元素的值，也就是提交到服务器的值</td></tr><tr><td><code>checked</code></td><td>checked</td><td>规定此 input 元素首次加载时应当被选中</td></tr><tr><td><code>maxlength</code></td><td>正整数</td><td>规定输入字段中的字符的最大长度</td></tr><tr><td><code>placeholder</code></td><td>由用户自定义</td><td>占位符，提示用户输入内容的文本</td></tr><tr><td><code>multiple</code></td><td>file</td><td>常用于type值为file时，进行多文件选择</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入账号&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;normal button&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/62e47b505070481ab5bcbeb9898ca0d1.png#pic_center" alt=""></p><p><strong>&lt;1&gt;、有些表单元素刚打开页面就须要默认显示几个文字怎么做？</strong></p><p>答：可以给这些表单元素设置 <code>value属性=&quot;值&quot;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名：<span class="tag">&lt;<span class="name">iuput</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;请输入用户名&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>&lt;2&gt;、页面中的表单元素很多，如何区别不同的表单元素？</strong></p><p>答：name 属性：当前 input 表单的名字，后台可以通过这个 name 属性找到这个表单，页面中的表单很多，name 的主要作用就是用于区别不同的表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;请输入用户名&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>name 属性后面的值是自定义的</p></li><li class="lvl-2"><p>radio（或者 checkbox）如果是一组，我们必须给他们命名相同的名字</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span>女</span><br></pre></td></tr></table></figure><p><strong>&lt;3&gt;、如果页面一打开就让某个单选按钮或者复选框是选中状态？</strong></p><p>答：checked 属性：表示默认选中状态，用于单选按钮和复选按钮。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">性 别：</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> &gt;</span>女</span><br></pre></td></tr></table></figure><h3 id="6-2-label标签">6.2 label标签</h3><blockquote><p>VsCode快捷键：alt+shift+↑/↓ 复制当前行在下方插入</p></blockquote><p><code>&lt;label&gt;</code> 标签为 input 元素定义标注（标签）。</p><p><code>&lt;label&gt;</code> 标签用于绑定一个表单元素，当点击 <code>&lt;label&gt;</code> 标签内的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，用来增加用户体验。</p><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一种写法：</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">第二种写法：</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>核心：</strong> <code>&lt;label&gt;</code> 标签的 for 属性应当与相关元素的 id 属性相同。</p><h3 id="6-3-button按钮标签">6.3 button按钮标签</h3><p>场景：在网页中显示用户点击的按钮</p><p>type属性值(同input的按钮系列)</p><table><thead><tr><th>type属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>reset</code></td><td>定义重置按钮，重置按钮会清除表单中的所有数据</td></tr><tr><td><code>submit</code></td><td>定义提交按钮，提交按钮会把表单数据发送到服务器</td></tr><tr><td><code>button</code></td><td>普通按钮，默认无功能</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>普通按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/26fd6f4c6325499d9f76ce5a513f94f0.png#pic_center" alt=""></p><h3 id="6-4-select下拉单标签">6.4 select下拉单标签</h3><p>**使用场景：**在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用 <code>&lt;select&gt;</code> 标签控件定义下拉列表。</p><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;select&gt;</code> 中至少包含一对 <code>&lt;option&gt;</code></p></li><li class="lvl-2"><p>在 <code>&lt;option&gt;</code> 中定义 <code>selected=&quot;selected&quot;</code> 时，当前项即为默认选中项</p></li></ul><p>每个 <code>&lt;option&gt;</code> 元素都应该有一个 value 属性，其中包含选择该选项时要提交给服务器的数据值。如果不包含 value 属性，则 value 默认为元素内包含的文本。可以在 <code>&lt;option&gt;</code> 元素上包含 selected 属性，以使其在页面首次加载时默认选中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">selected</span>&gt;</span>南京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>东京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>西京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6cb73924e0ec4ce78bdad78b2948e14b.png#pic_center" alt=""></p><h3 id="6-5-textarea文本域标签">6.5 textarea文本域标签</h3><p>**使用场景：**当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 <code>&lt;textarea&gt;</code> 标签</p><p>在表单元素中，<code>&lt;textarea&gt;</code> 标签是用于定义多行文本输入的控件。</p><p>使用多行文本输入控件，可以输入更多的文字，该控件常用于留言板、评论。</p><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;3&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line">文本内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通过 <code>&lt;textarea&gt;</code> 标签可以轻松地创建多行文本输入框</p></li><li class="lvl-2"><p><code>cols=&quot;每行中的字符数&quot;</code>，<code>rows=&quot;显示的行数&quot;</code>，我们在实际开发中不会使用，都是用 CSS 来改变大小</p></li><li class="lvl-2"><p>如果要禁止拉伸文本框大小，则：<code>style=&quot;resize: none&quot; </code></p></li></ul><p><img src="https://img-blog.csdnimg.cn/71fc1ddbc017474fbfb4a4c31c8fe4ad.png#pic_center" alt=""></p><h3 id="6-6-表单域标签">6.6 表单域标签</h3><p><strong>表单域是一个包含表单元素的区域。</strong></p><p>在 HTML 标签中，<code>&lt;form&gt;</code> 标签用于定义表单域，以实现用户信息的收集和传递。</p><p><code>&lt;form&gt;</code> 会把它范围内的表单元素信息提交给服务器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单域名称&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 各种表单元素控件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>常用属性：</strong></p><table><thead><tr><th>属性名</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td><code>action</code></td><td><code>url</code> 地址</td><td>用于指定接收并处理表单数据的服务器程序的 url 地址</td></tr><tr><td><code>method</code></td><td><code>get</code> / <code>post</code></td><td>用于设置表单数据的提交方式，其取值为 get 或 post</td></tr><tr><td><code>name</code></td><td>名称</td><td>用于指定表单的名称，以区分同一个页面中的多个表单域</td></tr></tbody></table><p>注意：对于 HTML 基础的学习来说，暂时不用考虑提交数据，只需写上 form 标签即可，后面学习服务端编程阶段会重新讲解。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;normal button&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**注意：**如果不加form,那么提交或者重置的时候没有效果，因为不知道重置哪些内容</p><h2 id="7-字符实体">7.字符实体</h2><p>在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。</p><table><thead><tr><th style="text-align:left">特殊字符</th><th style="text-align:left">描述</th><th style="text-align:left">字符的代码</th></tr></thead><tbody><tr><td style="text-align:left"><code> </code></td><td style="text-align:left">空格符</td><td style="text-align:left"><code>&amp;nbsp;</code></td></tr><tr><td style="text-align:left"><code>&lt;</code></td><td style="text-align:left">小于号</td><td style="text-align:left"><code>&amp;lt;</code></td></tr><tr><td style="text-align:left"><code>&gt;</code></td><td style="text-align:left">大于号</td><td style="text-align:left"><code>&amp;gt;</code></td></tr><tr><td style="text-align:left"><code>&amp;</code></td><td style="text-align:left">和号</td><td style="text-align:left"><code>&amp;amp;</code></td></tr><tr><td style="text-align:left"><code>±</code></td><td style="text-align:left">正负号</td><td style="text-align:left"><code>&amp;plusmn;</code></td></tr><tr><td style="text-align:left"><code>×</code></td><td style="text-align:left">乘号</td><td style="text-align:left"><code>&amp;times;</code></td></tr><tr><td style="text-align:left"><code>÷</code></td><td style="text-align:left">除号</td><td style="text-align:left"><code>&amp;divide;</code></td></tr><tr><td style="text-align:left"><code>²</code></td><td style="text-align:left">上标</td><td style="text-align:left"><code>&amp;sup2;</code></td></tr></tbody></table><h2 id="8-综合案例">8.综合案例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>青春不常在，抓紧谈恋爱<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        昵称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入昵称&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        性别：</span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">checked</span>&gt;</span> 男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span> 女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        所在城市：</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">selected</span>&gt;</span>南京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>东京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        喜欢的类型：</span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span> 可爱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>&gt;</span> 萝莉<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span> 御姐<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        个人介绍：</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;60&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我承诺<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>年满18岁，单身<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>抱着严肃的态度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>真诚寻找另一半<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span> 我同意所有条款</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7ec9e538f34d4dceb40f2ef4afe0f59a.png#pic_center" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之线程同步</title>
      <link href="/posts/75206e58.html"/>
      <url>/posts/75206e58.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程同步的概念">1.线程同步的概念</h2><p>同步即协同步调，按预定的先后次序运行。</p><p><strong>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</strong></p><p>假设有 4 个线程 A、B、C、D，当前一个线程 A 对内存中的共享资源进行访问的时候，其他线程 B, C, D 都不可以对这块内存进行操作，直到线程 A 对这块内存访问完毕为止，B，C，D 中的一个才能访问这块内存，剩余的两个需要继续阻塞等待，以此类推，直至所有的线程都对这块内存操作完毕。 线程对内存的这种访问方式就称之为线程同步，通过对概念的介绍，我们可以了解到<mark>所谓的同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行的</mark>。如果不按照这种规则，就会产生数据混乱。</p><h2 id="2-数据混乱原因">2.数据混乱原因</h2><ol><li class="lvl-3"><p>资源共享（独享资源则不会）</p></li><li class="lvl-3"><p>调度随机（意味着数据访问会出现竞争）</p></li><li class="lvl-3"><p>线程间缺乏必要的同步机制。</p></li></ol><p>以上 3 点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p><h2 id="3-互斥量mutex">3.互斥量mutex</h2><p>Linux 中提供一把互斥锁<code>mutex</code>（也称之为互斥量）。 <mark>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作</mark>，操作结束解锁。 资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。但应注意：<mark>同一时刻，只能有一个线程持有该锁。</mark> 当 A 线程对某个全局变量加锁访问，B 在访问前尝试加锁，拿不到锁，B 阻塞。C 线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。 所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。因此，即使有了<code>mutex</code>，如果有线程不按规则来访问数据，依然会造成数据混乱。</p><p><img src="https://img-blog.csdnimg.cn/78e4d0d7474047bcbfb55e7c4116cd8a.png#pic_center" alt=""></p><p><strong>主要应用的函数</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>pthread_mutex_init </code>函数</p></li><li class="lvl-2"><p><code>pthread_mutex_destroy</code> 函数</p></li><li class="lvl-2"><p><code>pthread_mutex_lock </code>函数</p></li><li class="lvl-2"><p><code>pthread_mutex_trylock </code>函数</p></li><li class="lvl-2"><p><code>pthread_mutex_unlock </code>函数</p></li></ul><blockquote><p>以上 5 个函数的返回值都是：成功返回 0， 失败返回错误号。 <code>pthread_mutex_t </code>类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。下面具体介绍这些函数：</p></blockquote><p>在 Linux 中互斥锁的类型为 <code>pthread_mutex_t</code>，创建一个这种类型的变量就得到了一把互斥锁：</p><p><code>pthread_mutex_t  mutex;</code></p><p>变量mutex 只有两种取值 1、0</p><h3 id="3-1-初始化和销毁函数">3.1 初始化和销毁函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放互斥锁资源            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数:</p><ul class="lvl-2"><li class="lvl-4">mutex: 传出参数，互斥锁变量的地址，调用时应传 &amp;mutex</li><li class="lvl-4">restrict 关键字：是一个关键字, 用来修饰指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。 不能通过除本指针以外的其他变量或指针修改</li><li class="lvl-4">attr: 互斥锁的属性，一般使用默认属性即可，这个参数指定为 NULL</li></ul></li></ul><blockquote><ol><li class="lvl-3"><p>静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了 static 关键字修饰），可以直接使用宏进行初始化。</p><p><code>pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</code></p></li><li class="lvl-3"><p>动态初始化：局部变量应采用动态初始化。</p><p><code>pthread_mutex_init(&amp;mutex, NULL)</code></p></li></ol></blockquote><h3 id="3-1-pthread-mutex-lock-函数">3.1 pthread_mutex_lock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>这个函数被调用，首先会判断参数 mutex 互斥锁中的状态是不是锁定状态:</p><ul class="lvl-0"><li class="lvl-2"><p>没被锁定，是打开的，这个线程可以加锁成功，这个这个锁中会记录是哪个线程加锁成功了</p></li><li class="lvl-2"><p>如果被锁定了，其他线程加锁就失败了，这些线程都会阻塞在这把锁上</p></li><li class="lvl-2"><p>当这把锁被解开之后，这些阻塞在锁上的线程就解除阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的线程继续阻塞</p></li></ul><h3 id="3-2-pthread-mutex-trylock-函数">3.2 pthread_mutex_trylock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数对互斥锁变量加锁还是有两种情况:</p><ul class="lvl-0"><li class="lvl-2"><p>如果这把锁没有被锁定是打开的，线程加锁成功</p></li><li class="lvl-2"><p>如果锁变量被锁住了，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号</p></li></ul><h3 id="3-3-pthread-mutex-unlock-函数">3.3 pthread_mutex_unlock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对互斥锁解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>不是所有的线程都可以对互斥锁解锁，哪个线程加的锁，哪个线程才能解锁成功。</p><h3 id="3-4-互斥锁使用">3.4 互斥锁使用</h3><blockquote><p>案例：两个线程交替数数（每个线程数 50 个数，交替数到 100）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一把互斥锁</span></span><br><span class="line"><span class="comment">// 全局变量, 多个线程共享</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcA_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果线程A加锁成功, 不阻塞</span></span><br><span class="line">        <span class="comment">// 如果B加锁成功, 线程A阻塞</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcB_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// a加锁成功, b线程访问这把锁的时候是锁定的</span></span><br><span class="line">        <span class="comment">// 线程B先阻塞, a线程解锁之后阻塞解除</span></span><br><span class="line">        <span class="comment">// 线程B加锁成功了</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="comment">// 线程销毁之后, 再去释放互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>互斥锁使用技巧:</strong></p><p>注意事项：</p><p>​    尽量保证锁的粒度， 越小越好。（访问共享数据前，加锁。访问结束立即解锁。）</p><p>​    互斥锁，本质是结构体。 我们可以看成整数。 初值为 1。（pthread_mutex_init() 函数调用成功。）</p><p>​    加锁： --操作， 小于0，阻塞线程。</p><p>​    解锁： ++操作， 唤醒阻塞在锁上的线程。</p><p>​    try锁：尝试加锁，成功–。失败，返回直接返回错误号</p><h2 id="4-死锁">4. 死锁</h2><p>当多个线程访问共享资源，需要加锁，如果锁使用不当，就会造成死锁这种现象。如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。</p><p>造成死锁的场景有如下几种：</p><ol><li class="lvl-3"><p>线程试图对同一个互斥量 A 加锁两次。</p></li><li class="lvl-3"><p>线程 1 拥有 A 锁，请求获得 B 锁；线程 2 拥有 B 锁，请求获得 A 锁</p></li><li class="lvl-3"><p>加锁之后忘记解锁</p></li></ol><p><img src="https://img-blog.csdnimg.cn/92fd75b62d8a49ba8d9d145d29573ae7.png#pic_center" alt=""></p><h2 id="5-读写锁">5.读写锁</h2><p>与互斥量类似，但读写锁允许更高的并行性。其特性为：<mark>写独占，读共享。</mark></p><p><strong>读写锁的状态</strong>:</p><p>特别强调：<mark>读写锁只有一把</mark>，但其具备两种状态：</p><ol><li class="lvl-3"><p>读模式下加锁状态 (读锁)</p></li><li class="lvl-3"><p>写模式下加锁状态 (写锁)</p></li></ol><p><strong>读写锁的特性</strong></p><ol><li class="lvl-3"><p>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</p></li><li class="lvl-3"><p>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</p></li><li class="lvl-3"><p>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。<mark>读锁、写锁并行阻塞，写锁优先级高</mark></p></li></ol><p>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是<code>以共享模式锁住的</code>；当它以写模式锁住时，它是<code>以独 占模式锁住的</code>。写独占、读共享。读写锁非常适合于对数据结构读的次数远大于写的情况。</p><p><strong>主要应用的函数</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>pthread_rwlock_init</code> 函数</p></li><li class="lvl-2"><p><code>pthread_rwlock_destroy</code> 函数</p></li><li class="lvl-2"><p><code>pthread_rwlock_rdlock</code> 函数</p></li><li class="lvl-2"><p><code>pthread_rwlock_wrlock</code> 函数</p></li><li class="lvl-2"><p><code>pthread_rwlock_tryrdlock</code> 函数</p></li><li class="lvl-2"><p><code>pthread_rwlock_trywrlock </code>函数</p></li><li class="lvl-2"><p><code>pthread_rwlock_unlock</code> 函数</p></li></ul><blockquote><p>以上 7 个函数的返回值都是：成功返回 0， 失败直接返回错误号。下面具体介绍这些函数</p></blockquote><p>读写锁是一把锁，锁的类型为 <code>pthread_rwlock_t</code>，有了类型之后就可以创建一把互斥锁了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br></pre></td></tr></table></figure><h3 id="5-1-初始化和销毁函数">5.1 初始化和销毁函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放读写锁占用的系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数:</p><ul class="lvl-2"><li class="lvl-4"><code>rwlock</code>: 读写锁的地址，传出参数</li><li class="lvl-4"><code>attr</code>: 读写锁属性，一般使用默认属性，指定为 NULL</li></ul></li></ul><h3 id="5-2-pthread-rwlock-rdlock-函数">5.2 pthread_rwlock_rdlock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加读锁, 锁定的是读操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数的线程会被阻塞。</p><h3 id="5-3-pthread-rwlock-tryrdlock-函数">5.3 pthread_rwlock_tryrdlock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加读锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应的线程不会被阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</p><h3 id="5-4-pthread-rwlock-wrlock-函数">5.4 pthread_rwlock_wrlock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加写锁, 锁定的是写操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数的线程会被阻塞。</p><h3 id="5-5-pthread-rwlock-trywrlock-函数">5.5 pthread_rwlock_trywrlock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加写锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</p><h3 id="5-6-pthread-rwlock-unlock-函数">5.6 pthread_rwlock_unlock()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁, 不管锁定了读还是写都可用解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h3 id="5-7-读写锁的使用">5.7 读写锁的使用</h3><blockquote><p>8 个线程操作同一个全局变量，3 个线程不定时写同一全局资源，5 个线程不定时读同一全局资源</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义读写锁</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写的线程的处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writeNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur ++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++写操作完毕, number : %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">// 添加sleep目的是要看到多个线程交替工作</span></span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程的处理函数</span></span><br><span class="line"><span class="comment">// 多个线程可以如果处理动作相同, 可以使用相同的处理函数</span></span><br><span class="line"><span class="comment">// 每个线程中的栈资源是独享</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">readNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--全局变量number = %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化读写锁</span></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3个写线程, 5个读的线程</span></span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">3</span>];</span><br><span class="line">    <span class="type">pthread_t</span> rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;wtid[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;rtid[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(wtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(rtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-条件变量">6.条件变量</h2><p>条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</p><p><strong>主要应用的函数</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>pthread_cond_init</code> 函数</p></li><li class="lvl-2"><p><code>pthread_cond_destroy </code>函数</p></li><li class="lvl-2"><p><code>pthread_cond_wait </code>函数</p></li><li class="lvl-2"><p><code>pthread_cond_timedwait</code> 函数</p></li><li class="lvl-2"><p><code>pthread_cond_signal</code> 函数</p></li><li class="lvl-2"><p><code>pthread_cond_broadcast</code> 函数</p></li></ul><blockquote><p>以上 6 个函数的返回值都是：成功返回 0， 失败直接返回错误号。下面具体介绍这些函数</p></blockquote><p>条件变量类型对应的类型为 <code>pthread_cond_t</code>，这样就可以定义一个条件变量类型的变量了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br></pre></td></tr></table></figure><p>被条件变量阻塞的线程的线程信息会被记录到这个变量中，以便在解除阻塞的时候使用。</p><h3 id="6-1-初始化和销毁函数">6.1 初始化和销毁函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 销毁释放资源        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数:</p><ul class="lvl-2"><li class="lvl-4">cond: 条件变量的地址</li><li class="lvl-4">attr: 条件变量属性，一般使用默认属性，指定为 NULL</li></ul></li></ul><blockquote><ol><li class="lvl-3"><p>静态初始化：可以直接使用宏进行初始化。<code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code></p></li><li class="lvl-3"><p>动态初始化：局部变量应采用动态初始化。<code>pthread_mutex_init(&amp;cond, NULL)</code></p></li></ol></blockquote><h3 id="6-2-pthread-cond-wait-函数">6.2 pthread_cond_wait()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><p>函数作用：</p><ol><li class="lvl-3"><p>阻塞等待条件变量 cond（参 1）满足</p></li><li class="lvl-3"><p>释放已掌握的互斥锁（解锁互斥量）相当于 <code>pthread_mutex_unlock(&amp;mutex)</code>; 1.2.两步为一个原子操作。</p></li><li class="lvl-3"><p>当被唤醒，<code>pthread_cond_wait</code> 函数返回时，解除阻塞并重新申请获取互斥锁 <code>pthread_mutex_lock(&amp;mutex)</code>;</p></li></ol><p><img src="https://img-blog.csdnimg.cn/1f5c8f75c5e24a2c90d2c10f143260ac.png#pic_center" alt=""></p><h3 id="6-3-pthread-cond-timedwait-函数">6.3 pthread_cond_timedwait()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds 秒*/</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds 纳秒 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure><p>这个函数的前两个参数和 <code>pthread_cond_wait</code> 函数是一样的，第三个参数表示线程阻塞的时长，但是需要额外注意一点：<code>struct timespec</code> 这个结构体中记录的时间是从1971.1.1到某个时间点的时间，总长度使用秒/纳秒表示。因此赋值方式相对要麻烦一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如：time(<span class="literal">NULL</span>)返回的就是绝对时间。而 alarm(<span class="number">1</span>)是相对时间，相对当前时间定时 <span class="number">1</span> 秒钟。 </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span> =</span> &#123;<span class="number">1</span>, <span class="number">0</span>&#125;; </span><br><span class="line">pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 只能定时到 <span class="number">1970</span> 年 <span class="number">1</span> 月 <span class="number">1</span> 日 <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> 秒(早已经过去)</span><br><span class="line">正确用法： </span><br><span class="line">  <span class="type">time_t</span> cur = time(<span class="literal">NULL</span>); 获取当前时间。 </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span> 定义 timespec 结构体变量t </span><br><span class="line">  t.tv_sec = cur+<span class="number">1</span>; 定时 <span class="number">1</span> 秒</span><br><span class="line">pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 传参</span><br></pre></td></tr></table></figure><h3 id="6-4-唤醒函数">6.4 唤醒函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><p>调用上面两个函数中的任意一个，都可以唤醒被 <code>pthread_cond_wait</code> 或者 <code>pthread_cond_timedwait</code> 阻塞的线程，区别就在于 <code>pthread_cond_signal</code> 是唤醒至少一个被阻塞的线程（总个数不定），<code>pthread_cond_broadcast</code> 是唤醒所有被阻塞的线程。</p><h3 id="6-5-生产者消费者条件变量模型">6.5 生产者消费者条件变量模型</h3><p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定 有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p><p><img src="https://img-blog.csdnimg.cn/28a56993e7b047538a7b7672ea0b9c10.png#pic_center" alt=""></p><blockquote><p>小案例：使用条件变量实现生产者和消费者模型，生产者有 5 个，往链表头部添加节点，消费者也有 5 个，删除链表头部的节点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义条件变量, 控制消费者线程</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产了任务, 通知消费者消费</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 一直消费, 删除链表中的一个节点</span></span><br><span class="line"><span class="comment">//        if(head == NULL)   // 这样写有bug</span></span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 任务队列, 也就是链表中已经没有节点可以消费了</span></span><br><span class="line">            <span class="comment">// 消费者线程需要阻塞</span></span><br><span class="line">            <span class="comment">// 线程加互斥锁成功, 但是线程阻塞在这行代码上, 锁还没解开</span></span><br><span class="line">            <span class="comment">// 其他线程在访问这把锁的时候也会阻塞, 生产者也会阻塞 ==&gt; 死锁</span></span><br><span class="line">            <span class="comment">// 这函数会自动将线程拥有的锁解开</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">            <span class="comment">// 当消费者线程解除阻塞之后, 会自动将这把锁锁上</span></span><br><span class="line">            <span class="comment">// 这时候当前这个线程又重新拥有了这把互斥锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);        </span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-条件变量的优点：">6.6 条件变量的优点：</h3><p>相较于<code>mutex</code> 而言，条件变量可以减少竞争。 如直接使用<code>mutex</code>，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p><h2 id="7-信号量">7.信号量</h2><p>进化版的互斥锁（1 --&gt; N） 由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。 信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p><p><strong>主要应用函数</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>sem_init</code> 函数</p></li><li class="lvl-2"><p><code>sem_destroy</code> 函数</p></li><li class="lvl-2"><p><code>sem_wait</code> 函数</p></li><li class="lvl-2"><p><code>sem_trywait</code> 函数</p></li><li class="lvl-2"><p><code>sem_timedwait</code> 函数</p></li><li class="lvl-2"><p><code>sem_post</code> 函数</p></li></ul><p>以上 6 个函数的返回值都是：成功返回 0， 失败返回-1，同时设置 errno。(注意，它们没有 pthread 前缀)</p><p><code>信号量（信号灯）</code>与互斥锁和条件变量的主要不同在于” 灯” 的概念，灯亮则意味着资源可用，灯灭则意味着不可用。信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</p><p>信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为<code>sem_t</code>对应的头文件为 <code>&lt;semaphore.h&gt;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br></pre></td></tr></table></figure><h3 id="7-1-初始化和销毁函数">7.1 初始化和销毁函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化信号量/信号灯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">// 资源释放, 线程销毁之后调用这个函数即可</span></span><br><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数:</p><ul class="lvl-2"><li class="lvl-4"><code>sem</code>：信号量变量地址</li><li class="lvl-4"><code>pshared</code>：<ul class="lvl-4"><li class="lvl-6">0：线程同步</li><li class="lvl-6">非 0：进程同步</li></ul></li><li class="lvl-4"><code>value</code>：初始化当前信号量拥有的资源数（&gt;=0），如果资源数为 0，线程就会被阻塞了。</li></ul></li></ul><h3 id="7-2-sem-wait-函数">7.2 sem_wait()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，因此线程也就被阻塞了。</p><h3 id="7-3-sem-trywait-函数">7.3 sem_trywait()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>当线程调用这个函数，并且 <code>sem</code> 中的资源数 &gt;0，线程不会阻塞，线程会占用 <code>sem</code> 中的一个资源，因此资源数 - 1，直到<code>sem</code>中的资源数减为 0 时，资源被耗尽，但是线程不会被阻塞，直接返回错误号，因此可以在程序中添加判断分支，用于处理获取资源失败之后的情况。</p><h3 id="7-4-sem-timedwait-函数">7.4 sem_timedwait()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用该函数线程获取sem中的一个资源，当资源数为0时，线程阻塞，在阻塞abs_timeout对应的时长之后，解除阻塞。</span></span><br><span class="line"><span class="comment">// abs_timeout: 阻塞的时间长度, 单位是s, 是从1970.1.1开始计算的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure><p>该函数的参数 <code>abs_timeout</code> 和<code> pthread_cond_timedwait</code> 的最后一个参数是一样的，使用方法不再过多赘述。当线程调用这个函数，并且 <code>sem</code> 中的资源数 &gt;0，线程不会阻塞，线程会占用 <code>sem</code> 中的一个资源，因此资源数 - 1，直到 <code>sem</code> 中的资源数减为 0 时，资源被耗尽，线程被阻塞，当阻塞指定的时长之后，线程解除阻塞。</p><h3 id="7-5-sem-post-函数">7.5 sem_post()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用该函数给sem中的资源数+1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>调用该函数会将 <code>sem</code> 中的资源数 +1，如果有线程在调用<code> sem_wait</code>、<code>sem_trywait</code>、<code>sem_timedwait</code> 时因为 <code>sem</code> 中的资源数为 0 被阻塞了，这时这些线程会解除阻塞，获取到资源之后继续向下运行。</p><h3 id="7-6-生产者消费者信号量模型">7.6 生产者消费者信号量模型</h3><blockquote><p>小案例：使用信号量实现生产者和消费者模型，生产者有 5 个，往链表头部添加节点，消费者也有 5 个，删除链表头部的节点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统编程 </tag>
            
            <tag> 线程同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之守护进程、线程</title>
      <link href="/posts/88cb41b.html"/>
      <url>/posts/88cb41b.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-守护进程">1.守护进程</h2><p>守护进程（Daemon Process），也就是通常说的Daemon(精灵)进程，是 Linux 中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理 某些发生的事件。一般采用以 d 结尾的名字。</p><p>Linux 后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp 服务器；nfs 服务器等。</p><p>创建守护进程，最关键的一步是调用 <code>setsid</code> 函数创建一个新的 Session，并成为 Session Leader。</p><h3 id="1-1-进程组">1.1 进程组</h3><p>多个进程的集合就是进程组，也称之为作业。BSD 于 1980 年前后向 Unix 中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程组。在<code>waitpid</code>函数和 <code>kill</code> 函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。</p><p>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组 ID == 第一个进程 ID(组长进程)。 所以，组长进程标识：其进程组 ID == 其进程 ID</p><p>可以使用 <code>kill -SIGKILL -进程组 ID(负的)</code>来将整个进程组内的进程全部杀死。组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</p><p>进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。</p><p>一个进程可以为自己或子进程设置进程组 ID</p><p>下面介绍几个常用的进程组函数：</p><blockquote><p>得到当前进程所在的进程组的组 ID</p></blockquote><p><code>pid_t getpgrp(void);</code></p><blockquote><p>获取指定的进程所在的进程组的组 ID，参数 pid 就是指定的进程</p></blockquote><p><code>pid_t getpgid(pid_t pid);</code></p><blockquote><p>将某个进程移动到其他进程组中或者创建新的进程组</p></blockquote><p><code>int setpgid(pid_t pid, pid_t pgid);</code></p><p><strong>函数参数:</strong></p><p><code>pid: </code>某个进程的进程 ID</p><p><code>pgid:</code> 某个进程组的组 ID</p><p>如果 pgid 对应的进程组存在，pid 对应的进程会移动到这个组中，pid != pgid</p><p>如果 pgid 对应的进程组不存在，会创建一个新的进程组，因此要求 pid == pgid, 当前进程就是组长了</p><p><strong>函数返回值：</strong></p><p>函数调用成功返回 0，失败返回 - 1</p><h3 id="1-2-会话">1.2 会话</h3><p>会话 (session) 是由一个或多个进程组组成的，一个会话可以对应一个控制终端，也可以没有。一个普通的进程可以调用 <code>setsid() </code>函数使自己成为新 session 的领头进程(会长)，并且这个 session 领头进程还会被放入到一个新的进程组中。先来看一下 setsid() 函数的原型:</p><h3 id="1-3-setsid-函数">1.3 setsid()函数</h3><p>创建一个会话，并以自己的 ID 设置进程组 ID，同时也是新会话的 ID。</p><p><strong>函数原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数返回值</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>成功：返回调用进程的会话 ID</p></li><li class="lvl-2"><p>失败：-1，设置 errno</p></li></ul><h3 id="1-4-getsid-函数">1.4 getsid()函数</h3><p>获取进程所属的会话 ID</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数返回值</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>成功：返回调用进程的会话 ID</p></li><li class="lvl-2"><p>失败：-1，设置 errno</p></li></ul><p><mark>pid 为 0 表示察看当前进程 session ID</mark></p><blockquote><p>使用这两个函数的注意事项:</p><p>1.调用这个函数的进程不能是组长进程，如果是,该函数调用失败，如何保证这个函数能调用成功呢？</p><ul class="lvl-1"><li class="lvl-2"><p>先 fork () 创建子进程，终止父进程，让子进程调用这个函数</p></li></ul><p>2.如果调用这个函数的进程不是进程组长，会话创建成功</p><ul class="lvl-1"><li class="lvl-2"><p>这个进程会变成当前会话中的第一个进程，同时也会变成新的进程组的组长</p></li><li class="lvl-2"><p>该函数调用成功之后，当前进程就脱离了控制终端，因此不会阻塞终端</p></li></ul></blockquote><h3 id="1-5-创建守护进程">1.5 创建守护进程</h3><ol><li class="lvl-3"><p>创建子进程，父进程退出</p></li><li class="lvl-3"><p>在子进程中创建新会话 <code>setsid()函数</code> 使子进程完全独立出来，脱离控制</p></li><li class="lvl-3"><p>改变当前目录位置 <code>chdir()函数</code> 防止占用可卸载的文件系统, 也可以换成其它路径</p></li><li class="lvl-3"><p>重设文件权限掩码 <code>umask()</code>函数 防止继承的文件创建屏蔽字拒绝某些权限,增加守护进程灵活性</p></li><li class="lvl-3"><p>通常根据需要，关闭/重定向 文件描述符</p></li><li class="lvl-3"><p>开始执行守护进程业务逻辑，通常是while()循环</p></li></ol><p><strong>小案例</strong></p><blockquote><p>写一个守护进程，每隔 2s 获取一次系统时间，并将得到的时间写入到磁盘文件中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeFile</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 得到系统时间</span></span><br><span class="line">    <span class="type">time_t</span> seconds = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 时间转换, 总秒数 -&gt; 可以识别的时间字符串</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">loc</span> =</span> localtime(&amp;seconds);</span><br><span class="line">    <span class="comment">// sprintf();</span></span><br><span class="line">    <span class="type">char</span>* curtime = asctime(loc); <span class="comment">// 自带换行</span></span><br><span class="line">    <span class="comment">// 打开一个文件, 如果文件不存在, 就创建, 文件需要有追加属性</span></span><br><span class="line">    <span class="comment">// ./对应的是哪个目录? /home/robin</span></span><br><span class="line">    <span class="comment">// 0664 &amp; ~022</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./time+++++++.log&quot;</span>, O_WRONLY|O_CREAT|O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd, curtime, <span class="built_in">strlen</span>(curtime));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  perror(str);  </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 1. 创建子进程, 杀死父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程终止</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// kill(getpid(), 9); raise(9); abort();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 子进程, 将其变成会话, 脱离当前终端</span></span><br><span class="line">    pid = setsid();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      sys_err(<span class="string">&quot;setsid error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 修改进程的工作目录, 修改到一个不能被修改和删除的目录中 /home/robin</span></span><br><span class="line">    ret = chdir(<span class="string">&quot;/home/robin&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      sys_err(<span class="string">&quot;chdir error\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 设置掩码, 在进程中创建文件的时候这个掩码就起作用了</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 重定向和终端关联的文件描述符 -&gt; /dev/null</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    dup2(fd, STDIN_FILENO);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 委托内核捕捉并处理将来发生的信号-SIGALRM(14)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = writeFile;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 设置定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-线程">2.线程</h2><h3 id="2-1-什么是线程">2.1 什么是线程?</h3><p>线程是轻量级的进程（LWP：light weight process），在 Linux 环境下线程的本质仍是进程。在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。操作系统会以进程为单位，分配系统资源，可以这样理解，<mark>进程是资源分配的最小单位，线程是操作系统调度执行的最小单位</mark>。</p><p>进程：独立地址空间，拥有 PCB</p><p>线程：有独立的 PCB，但没有独立的地址空间(共享)</p><p>区别：在于是否共享地址空间。 独居(进程)；合租(线程)。</p><p><img src="https://img-blog.csdnimg.cn/2c7ecc24d9c04aed91526d59c2f436d1.png#pic_center" alt=""></p><h3 id="2-2-Linux-内核线程实现原理-了解即可">2.2 Linux 内核线程实现原理(了解即可)</h3><p>类 Unix 系统中，早期是没有“线程”概念的，80 年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p><ol><li class="lvl-3"><p>轻量级进程(light-weight process)，也有 PCB，创建线程使用的底层函数和进程一样，都是 clone</p></li><li class="lvl-3"><p>从内核里看进程和线程是一样的，都有各自不同的 PCB，但是 PCB 中指向内存资源的三级页表是相同的</p></li><li class="lvl-3"><p>进程可以蜕变成线程</p></li><li class="lvl-3"><p>线程可看做寄存器和栈的集合</p></li><li class="lvl-3"><p>在 linux 下，线程最是小的执行单位；进程是最小的分配资源单位查看 LWP 号：<code>ps –Lf pid</code> 查看指定线程的 lwp 号(线程号)。</p></li></ol><p>三级映射：进程 PCB --&gt; 页目录(可看成数组，首地址位于 PCB 中) --&gt; 页表 --&gt; 物理页面 --&gt; 内存单元对于进程来说，相同的地址(同一个虚拟地址)在不同的进程中，反复使用而不冲突。原因是他们虽虚拟地址一样，但，页目录、页表、物理页面各不相同。相同的虚拟地址，映射到不同的物理页面内存单元，最终访问不同的物理页面。但！线程不同！两个线程具有各自独立的 PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个 PCB 共享一个地址空间。 实际上，无论是创建进程的 fork，还是创建线程的 pthread_create，底层实现都是调用同一个内核函数 clone。 如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。 因此：<mark>Linux 内核是不区分进程和线程的</mark>。只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p><p><img src="https://img-blog.csdnimg.cn/432c1e93d9994c2b85b6a4193b0082d9.png#pic_center" alt=""></p><h3 id="2-4-线程共享资源和非共享资源">2.4 线程共享资源和非共享资源</h3><p><strong>共享资源</strong></p><p>1.文件描述符表</p><p>2.每种信号的处理方式</p><p>3.当前工作目录</p><p>4.用户 ID 和组 ID</p><p>5.内存地址空间 (.text/.data/.bss/heap/共享库)</p><p><strong>非共享资源</strong></p><p>1.线程 id</p><p>2.处理器现场和栈指针(内核栈)</p><p>3.独立的栈空间(用户空间栈)</p><p>4.errno 变量</p><p>5.信号屏蔽字</p><p>6.调度优先级</p><p><strong>线程优缺点</strong></p><p>优点： 1. 提高程序并发性 2. 开销小 3. 数据通信、共享数据方便</p><p>缺点： 1. 库函数，不稳定 2. 调试、编写困难、gdb 不支持 3. 对信号支持不好</p><p>优点相对突出，缺点均不是硬伤。Linux 下由于实现方法导致进程、线程差别不是很大。</p><h2 id="3-创建线程">3.创建线程</h2><h3 id="3-1-线程函数">3.1 线程函数</h3><p>每一个线程都有一个唯一的线程 ID，ID 类型为 <code>pthread_t</code>，这个 ID 是一个无符号长整形数(%lu)，如果想要得到当前线程的线程 ID，可以调用如下函数：</p><p><code>pthread_t pthread_self(void);// 返回当前线程的线程ID</code></p><p>在一个进程中调用线程创建函数，就可得到一个子线程，和进程不同，需要给每一个创建出的线程指定一个处理函数，否则这个线程无法工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数:</p><ul class="lvl-2"><li class="lvl-4">thread: 传出参数，是无符号长整形数，线程创建成功，会将线程 ID 写入到这个指针指向的内存中</li><li class="lvl-4">attr: 线程的属性，一般情况下使用默认属性即可，写 NULL</li><li class="lvl-4">start_routine: 函数指针，创建出的子线程的处理动作，也就是该函数在子线程中执行。</li><li class="lvl-4">arg: 作为实参传递到 start_routine 指针指向的函数内部</li></ul></li><li class="lvl-2"><p>返回值：线程创建成功返回 0，创建失败直接返回对应的错误号，不会设置errono，所以用<code>perror()</code>是行不通的，这点要注意，应直接用<code>strerror()</code></p></li></ul><p><strong>小案例</strong></p><blockquote><p>循环创建多个子线程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = *((<span class="type">int</span> *)arg);<span class="comment">//接收从主线程传递过来的地址，因此后面的i读取的都是主线程中的i</span></span><br><span class="line">sleep(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am %dth thread:pid = %d, tid = %lu\n&quot;</span>, i+<span class="number">1</span>, getpid(), pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, (<span class="type">void</span> *)&amp;i);<span class="comment">//将主线程的i的地址传递进去，会出错</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span> ,<span class="string">&quot;create error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">sleep(i);<span class="comment">//主线程执行完之后，就销毁了整个进程的地址空间，子线程就会无法打印，所以应该让主线程睡一会，等待子线程的执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am main pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/d25699f6eb9143d39b60c01421ee64e7.png#pic_center" alt=""></p><p>可以看到，不符合我们的预期想法，错误原因在于，子线程将主线程中i的地址传递了进去，因此子线程运行时会去读取主线程里的i值，而主线程里的i是动态变化的，不固定。所以，应该传递值而不是地址。</p><p>修改的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = (<span class="type">long</span>)arg;<span class="comment">//注意这里要强转成long类型，因为64位linux系统，指针占8个字节，int占4个字节，如果强转成int会造成精度的丢失</span></span><br><span class="line">sleep(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am %dth thread:pid = %d, tid = %lu\n&quot;</span>, i+<span class="number">1</span>, getpid(), pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, (<span class="type">void</span> *)i);<span class="comment">//按值进行传递</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span> ,<span class="string">&quot;create error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">sleep(i);<span class="comment">//主线程执行完之后，就销毁了整个进程的地址空间，子线程就会无法打印，所以应该让主线程睡一会，等待子线程的执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am main pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/4225514e3dd3404e86320a840b55fcc1.png#pic_center" alt=""></p><p><strong>注意</strong></p><p>编译时，要指定参数<code>-lpthread</code><a href="http://xn--libpthread-c42qx27fysin8ewtn.so">指定动态库libpthread.so</a></p><h3 id="3-2-线程间全局变量共享">3.2 线程间全局变量共享</h3><blockquote><p>直接看个代码，在子线程里更改全局变量，看主线程里的该变量有啥变化：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/229bc3a046ca4e9aa7784942f6d85001.png#pic_center" alt=""></p><p>编译运行，结果如下</p><p><img src="https://img-blog.csdnimg.cn/017f140f5e7f472284e9965e106e5d78.png#pic_center" alt=""></p><p>可以看到，子线程里更改全局变量后，主线程里也跟着发生变化。</p><h2 id="3-线程退出">3.线程退出</h2><p>在编写多线程程序的时候，如果想要让线程退出，但是不会导致虚拟地址空间的释放（针对于主线程），我们就可以调用线程库中的线程退出函数，只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数：线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为 NULL</p></li></ul><p><strong>注意区别三者</strong></p><ul class="lvl-0"><li class="lvl-2"><p>exit();  退出当前进程。</p></li><li class="lvl-2"><p>return: 返回到调用者那里去。</p></li><li class="lvl-2"><p>pthread_exit(): 退出当前线程。</p></li></ul><blockquote><p>下面是线程退出的示例代码，可以在任意线程的需要的位置调用该函数：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);<span class="comment">// 直接退出子线程</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用退出函数退出, 地址空间不会被释放</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下:</p><p><img src="https://img-blog.csdnimg.cn/629237f76abb4fc787aa8db7ffa83f5e.png#pic_center" alt=""></p><h2 id="4-线程回收">4.线程回收</h2><h3 id="4-1线程回收函数">4.1线程回收函数</h3><p>线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做 <code>pthread_join()</code>，这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p><p>另外通过线程回收函数还可以获取到子线程退出时传递出来的数据，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这是一个阻塞函数, 子线程在运行这个函数就阻塞</span></span><br><span class="line"><span class="comment">// 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数:</p><ul class="lvl-2"><li class="lvl-4">thread: 要被回收的子线程的线程 ID</li><li class="lvl-4">retval: 二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了 pthread_exit () 传递出的数据，如果不需要这个参数，可以指定为 NULL</li></ul></li><li class="lvl-2"><p>返回值：线程回收成功返回 0，回收失败返回错误号。</p></li></ul><h3 id="4-2-回收子线程数据">4.2 回收子线程数据</h3><p>在子线程退出的时候可以使用 pthread_exit() 的参数将数据传出，在回收这个子线程的时候可以通过 phread_join() 的第二个参数来接收子线程传递出的数据。接收数据有很多种处理方式，下面来举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span> <span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">working</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 使用全局变量</span></span><br><span class="line">p.age = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">p.id = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">pthread_exit(&amp;p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"><span class="comment">// 1. 创建一个子线程</span></span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line"><span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line"><span class="type">void</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line"><span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">pthread_join(tid, &amp;ptr);</span><br><span class="line"><span class="comment">// 打印信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> *<span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion *)ptr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/c83fd72f42924e67b59ade17e67dae43.png#pic_center" alt=""></p><h2 id="5-线程分离">5.线程分离</h2><p>在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用<code> pthread_join()</code> 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。</p><p>在线程库函数中为我们提供了线程分离函数<code> pthread_detach()</code>，调用这个函数之后<code>指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了</code>。线程分离之后在主线程中使用 <code>pthread_join()</code> 就回收不到子线程资源了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p><strong>小案例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子线程和主线程分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程自己退出即可</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-线程取消">6.线程取消</h2><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//杀死一个线程。需要到达取消点（保存点）,即进行一次系统调用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数：</p><ul class="lvl-2"><li class="lvl-4"><code>thread:</code> 待杀死的线程id</li></ul></li><li class="lvl-2"><p>返回值：</p><ul class="lvl-2"><li class="lvl-4">成功：0</li><li class="lvl-4">失败：直接返回错误号errno</li></ul></li></ul><p>如果，子线程没有到达取消点(即系统调用)， 那么 <code>pthread_cancel</code> 无效。   我们可以在程序中，手动添加一个取消点。使用 <code>pthread_testcancel()</code>; 成功被 <code>pthread_cancel() </code>杀死的线程，返回 -1.使用<code>pthead_join</code> 回收。</p><p><strong>小案例</strong></p><blockquote><p>主线程调用pthread_cancel杀死子线程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread: pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());  </span><br><span class="line">        sleep(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;  </span><br><span class="line">    <span class="type">pthread_t</span> tid;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);  </span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error:%s\n&quot;</span>, strerror(ret));  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());  </span><br><span class="line">  </span><br><span class="line">    sleep(<span class="number">5</span>);  </span><br><span class="line">  </span><br><span class="line">    ret = pthread_cancel(tid);          <span class="comment">// 终止线程  </span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_cancel error:%s\n&quot;</span>, strerror(ret));  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>编译运行，结果如下</p><p><img src="https://img-blog.csdnimg.cn/3d93b29b9d074154ac2fd90705bc726c.png#pic_center" alt=""></p><p><strong>终止线程方式</strong>：</p><p>总结：终止某个线程而不终止整个进程，有三种方法：</p><ol><li class="lvl-3"><p>从线程主函数 <code>return</code>。这种方法对主控线程不适用，从main 函数 return 相当于调用 exit。</p></li><li class="lvl-3"><p>一个线程可以调用 <code>pthread_cancel</code> 终止同一进程中的另一个线程。</p></li><li class="lvl-3"><p>线程可以调用 <code>pthread_exit </code>终止自己。</p></li></ol><h2 id="7-控制原语对比">7.控制原语对比</h2><p><img src="https://img-blog.csdnimg.cn/ccbdcb3511a64de895cd6edc527ce4ce.png#pic_center" alt=""></p><h2 id="8-线程属性">8.线程属性</h2><h3 id="8-1-基本概念">8.1 基本概念</h3><p>linux 下线程的属性是可以根据实际项目需要，进行设置。之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> detachstate; <span class="comment">//线程的分离状态</span></span><br><span class="line">    <span class="type">int</span> schedpolicy; <span class="comment">//线程的调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>　<span class="title">sched</span> <span class="title">schedparam</span>;</span><span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="type">int</span> inheritsched; <span class="comment">//线程的继承性</span></span><br><span class="line">    <span class="type">int</span> scope; <span class="comment">//线程的作用域</span></span><br><span class="line">    <span class="type">size_t</span> guardsize; <span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="type">int</span> stackaddr_set; <span class="comment">//线程栈的设置</span></span><br><span class="line">    <span class="type">void</span>* stackaddr; <span class="comment">//线程栈的启始位置</span></span><br><span class="line">    <span class="type">size_t</span> stacksize; <span class="comment">//线程栈大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure><p>主要结构体成员：</p><ol><li class="lvl-3"><p>线程分离状态</p></li><li class="lvl-3"><p>线程栈大小（默认平均分配）</p></li><li class="lvl-3"><p>线程栈警戒缓冲区大小（位于栈末尾）</p></li></ol><p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为 <code>pthread_attr_init</code>，这个函数必须在 <code>pthread_create </code>函数之前调用。之后须用 <code>pthread_attr_destroy</code> 函数来释放资源。</p><p>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、 分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</p><h3 id="8-1线程属性设置分离线程">8.1线程属性设置分离线程</h3><p>1 .<code>pthread_attr_t attr</code>   创建一个线程属性结构体变量</p><p>2 .<code>pthread_attr_init(&amp;attr); </code> 初始化线程属性</p><p>3 .<code>pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</code>   设置线程属性为 分离态</p><p>4 .<code>pthread_create(&amp;tid, &amp;attr, tfn, NULL);</code> 借助修改后的 设置线程属性 创建为分离态的新线程</p><p>5 .<code>pthread_attr_destroy(&amp;attr); </code> 销毁线程属性</p><p><strong>小案例</strong></p><blockquote><p>调整线程状态，使线程创建出来就是分离态，代码如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread: pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">pthread_t</span> tid;  </span><br><span class="line"></span><br><span class="line"><span class="type">pthread_attr_t</span> attr;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = pthread_attr_init(&amp;attr);  </span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;attr_init error:%s\n&quot;</span>, strerror(ret));  </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">ret = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);      <span class="comment">// 设置线程属性为 分离属性  </span></span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;attr_setdetachstate error:%s\n&quot;</span>, strerror(ret));  </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">ret = pthread_create(&amp;tid, &amp;attr, tfn, <span class="literal">NULL</span>);  </span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line">perror(<span class="string">&quot;pthread_create error&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">ret = pthread_attr_destroy(&amp;attr);  </span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;attr_destroy error:%s\n&quot;</span>, strerror(ret));  </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">ret = pthread_join(tid, <span class="literal">NULL</span>);  </span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;  </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error:%s\n&quot;</span>, strerror(ret));  </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main: pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());  </span><br><span class="line"></span><br><span class="line">pthread_exit((<span class="type">void</span> *)<span class="number">0</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译运行，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/5f6ca946b7134cc485cc88b0d46c705e.png#pic_center" alt=""></p><p>如图，<code>pthread_join</code>报错，说明线程已经自动回收，设置分离成功。</p><h2 id="9-线程使用注意事项">9.线程使用注意事项</h2><ol><li class="lvl-3"><p>主线程退出其他线程不退出，主线程应调用 <code>pthread_exit</code></p></li><li class="lvl-3"><p>避免僵尸线程</p><p><code>pthread_join </code></p><p><code>pthread_detach </code></p><p><code>pthread_create</code> 指定分离属性</p><p>被 join 线程可能在 join 函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;</p></li><li class="lvl-3"><p><code>malloc</code> 和<code>mmap </code>申请的内存可以被其他线程释放</p></li><li class="lvl-3"><p>应避免在多线程模型中调用 <code>fork</code> 除非，马上 <code>exec</code>，子进程中只有调用 <code>fork</code> 的线程存在，其他线程在子进程中均 <code>pthread_exit</code></p></li><li class="lvl-3"><p>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统编程 </tag>
            
            <tag> 守护进程 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之信号</title>
      <link href="/posts/8ab680c7.html"/>
      <url>/posts/8ab680c7.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-信号的概念">1.信号的概念</h2><p>信号在我们的生活中随处可见， 如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪… 他们都有<strong>共性</strong>：1. <code>简单</code> 2. <code>不能携带大量信息</code> 3.</p><p><code>满足某个特设条件才发送</code>。</p><p>信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</p><p>Unix 早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T 都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1 对可靠信号例程进行了标准化。</p><h2 id="2-信号的机制">2.信号的机制</h2><p>A 给 B 发送信号，B 收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行， 去处理信号，处理完毕再继续执行。与硬件中断类</p><p>似——<code>异步模式</code>。但信号是<code>软件层面上实现的中断</code>，早期常被称 为<code>“软中断”</code>。</p><p><strong>信号的特质：</strong> 由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。</p><p><mark>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</mark></p><h2 id="3-与信号相关的事件和状态">3.与信号相关的事件和状态</h2><p><strong>产生信号:</strong></p><ol><li class="lvl-3"><p>按键产生，如：<code>Ctrl+c</code>、<code>Ctrl+z</code>、<code>Ctrl+\ </code></p></li><li class="lvl-3"><p>系统调用产生，如：<code>kill</code>、<code>raise</code>、<code>abort </code></p></li><li class="lvl-3"><p>软件条件产生，如：定时器 <code>alarm </code></p></li><li class="lvl-3"><p>硬件异常产生，如：非法访问内存(段错误)、除 0(浮点数例外)、内存对齐出错(总线错误)</p></li><li class="lvl-3"><p>命令产生，如：<code>kill</code> 命令</p></li></ol><p><strong>递达：</strong> 递送并且到达进程。</p><p><strong>未决：</strong> 产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。</p><p><strong>信号的处理方式:</strong></p><ol><li class="lvl-3"><p>执行默认动作</p></li><li class="lvl-3"><p>忽略(丢弃)</p></li><li class="lvl-3"><p>捕捉(调用户处理函数)</p></li></ol><h2 id="4-信号屏蔽字和未决信号集">4.信号屏蔽字和未决信号集</h2><p>Linux 内核的进程控制块 <code>PCB</code> 是一个结构体，<code>task_struct,</code> 除了包含进程 id，状态，工作目录，用户 id，组 id， 文件描述符表，还包含了信号相关的信息，主要指<code>阻塞信号集</code>和<code>未决信号集</code>。</p><p><strong>阻塞信号集(信号屏蔽字)：</strong></p><p>本质：位图。用来记录信号的屏蔽状态。一旦被屏蔽的信号，在解除屏蔽前，一直处于未决态。</p><p><strong>未决信号集:</strong></p><ol><li class="lvl-3"><p>本质：位图。</p></li><li class="lvl-3"><p>信号产生,未决信号集中描述该信号的位立刻翻转为 1，表信号处于未决状态。当信号被处理对应位翻转回为 0。这一时刻往往非常短暂。</p></li><li class="lvl-3"><p>信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</p></li></ol><blockquote><p>阻塞信号集和未决信号集在内核中的结构是相同的，它们都是一个整形数组 (被封装过的), 一共 128 字节 （int [32] == 1024 bit），1024 个标志位，其中前 31 个标志位，每一个都对应一个 Linux 中的标准信号，通过标志位的值来标记当前信号在信号集中的状态。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/6adf7f79ed39494cb0ff6b6ef4bc9456.png#pic_center" alt=""></p><h2 id="5-信号四要素和常规信号一览">5.信号四要素和常规信号一览</h2><h3 id="5-1-信号的编号">5.1 信号的编号</h3><p>可以使用 <code>kill –l</code> 命令查看当前系统可使用的信号有哪些。</p><p><img src="https://img-blog.csdnimg.cn/5cca8b1728c64a4f875916ec278a2026.png#pic_center" alt=""></p><p>不存在编号为 0 的信号。其中 1-31 号信号称之为<code>常规信号（也叫普通信号或标准信号）</code>，34-64 称之为<code>实时信号</code>，驱动编程与硬件相关。名字上区别不大。而前 32 个名字各不相同。</p><h3 id="5-2-信号-4-要素">5.2 信号 4 要素</h3><p>与变量三要素类似的，每个信号也有其必备 4 要素，分别是：</p><ol><li class="lvl-3"><p>编号 2. 名称 3. 事件 4. 默认处理动作</p></li></ol><p><strong>注意：</strong> 信号使用之前，应先确定其4要素，而后再用！！！</p><p>可通过<code>man 7 signal </code>查看帮助文档获取。</p><p><img src="https://img-blog.csdnimg.cn/ef182349353d43d0b8ad8f2b3d672275.png#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/ce60102d722149d9b4fb73f10f2f1e94.png#pic_center" alt=""></p><p>默认动作：</p><ul class="lvl-0"><li class="lvl-2"><p>Term：终止进程</p></li><li class="lvl-2"><p>Ign： 忽略信号 (默认即时对该种信号忽略操作)</p></li><li class="lvl-2"><p>Core：终止进程，生成 Core 文件。(查验进程死亡原因， 用于 gdb 调试)</p></li><li class="lvl-2"><p>Stop：停止（暂停）进程</p></li><li class="lvl-2"><p>Cont：继续运行进程</p></li></ul><p>这里特别强调了 <mark>9) SIGKILL</mark> 和 <mark>19) SIGSTOP</mark>信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</p><p><strong>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！！</strong></p><h3 id="5-3-Linux-常规信号一览表">5.3 Linux 常规信号一览表</h3><ol><li class="lvl-3"><p>SIGHUP: 当用户退出 shell 时，由该 shell 启动的所有进程将收到这个信号，默认动作为终止进程</p></li><li class="lvl-3"><p>SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。</p></li><li class="lvl-3"><p>SIGQUIT：当用户按下&lt;ctrl+\&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。</p></li><li class="lvl-3"><p>SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生 core 文件</p></li><li class="lvl-3"><p>SIGTRAP：该信号由断点指令或其他 trap 指令产生。默认动作为终止里程 并产生 core 文件。</p></li><li class="lvl-3"><p>SIGABRT: 调用 abort 函数时产生该信号。默认动作为终止进程并产生 core 文件。</p></li><li class="lvl-3"><p>SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生 core 文件。</p></li><li class="lvl-3"><p>SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等所有的算法错误。默认动作为终止进程并产生 core 文件。</p></li><li class="lvl-3"><p>SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。</p></li><li class="lvl-4"><p>SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生 core 文件。</p></li><li class="lvl-4"><p>SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGPIPE：Broken pipe 向一个没有读端的管道写数据。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGALRM: 定时器超时，超时的时间 由系统调用 alarm 设置。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGTERM：程序结束信号，与 SIGKILL 不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行 shell 命令 Kill 时，缺省产生这个信号。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGSTKFLT：Linux 早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGCHLD：子进程状态发生变化时，父进程会收到这个信号。默认动作为忽略这个信号。</p></li><li class="lvl-4"><p>SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。</p></li><li class="lvl-4"><p>SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。</p></li><li class="lvl-4"><p>SIGTSTP：停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号。默认动作为暂停进程。</p></li><li class="lvl-4"><p>SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。</p></li><li class="lvl-4"><p>SIGTTOU: 该信号类似于 SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。</p></li><li class="lvl-4"><p>SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。</p></li><li class="lvl-4"><p>SIGXCPU：进程执行时间超过了分配给该进程的 CPU 时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGVTALRM：虚拟时钟超时时产生该信号。类似于 SIGALRM，但是该信号只计算该进程占用 CPU 的使用时间。默认动作为终止进程。</p></li><li class="lvl-4"><p>SGIPROF：类似于 SIGVTALRM，它不公包括该进程占用 CPU时间还包括执行系统调用时间。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。</p></li><li class="lvl-4"><p>SIGIO：此信号向进程指示发出了一个异步 IO 事件。默认动作为忽略。</p></li><li class="lvl-4"><p>SIGPWR：关机。默认动作为终止进程。</p></li><li class="lvl-4"><p>SIGSYS：无效的系统调用。默认动作为终止进程并产生 core 文件。</p></li><li class="lvl-4"><p>SIGRTMIN ～ (64) SIGRTMAX：LINUX 的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。</p></li></ol><h2 id="6-信号的产生">6.信号的产生</h2><h3 id="6-1-终端按键产生信号">6.1 终端按键产生信号</h3><p><code>Ctrl + c</code> → 2) <code>SIGINT</code>（终止/中断） “INT” ----Interrupt</p><p><code>Ctrl + z</code>→ 20) <code>SIGTSTP</code>（暂停/停止） “T” ----Terminal 终端。</p><p><code>Ctrl + \</code>→ 3) <code>SIGQUIT</code>（退出）</p><h3 id="6-2-硬件异常产生信号">6.2 硬件异常产生信号</h3><p>除 0 操作 → 8) <code>SIGFPE</code> (浮点数例外)</p><p>非法访问内存 → 11) <code>SIGSEGV</code> (段错误)</p><p>总线错误 → 7) <code>SIGBUS</code></p><h3 id="6-4-kill-函数-命令产生信号">6.4 kill 函数/命令产生信号</h3><p><strong>函数原型:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 给某一个进程发送一个信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数：</strong></p><p>​pid: &gt; 0：发送信号给指定进程</p><p>​= 0：发送信号给跟调用kill函数的那个进程处于同一进程组的进程。</p><p>​&lt; -1：取绝对值，发送信号给该绝对值所对应的进程组的所有组员。</p><p>​= -1：发送信号给，有权限发送的所有进程。</p><p>​signum：待发送的信号</p><p><strong>函数返回值：</strong></p><p>​成功： 0</p><p>​失败： -1 errno</p><p><strong>小案例</strong></p><blockquote><p>子进程发送信号kill父进程：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/55ab221a96504e2da8b8147e4179ebeb.png#pic_center" alt=""></p><p>​</p><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/b10af39467f14c88be9c81bb79c6a8e3.png#pic_center" alt=""></p><blockquote><p>kill -9 -groupname  杀一个进程组</p></blockquote><h2 id="7-定时器">7.定时器</h2><h3 id="7-1-alarm-函数">7.1 alarm()函数</h3><p>设置定时器(闹钟)。在指定 seconds 后，内核会给当前进程发送 <code>14）SIGALRM 信号</code>。进程收到该信号，默认动作终止。<mark>每个进程都有且只有唯一个定时器。</mark></p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数：</strong></p><p>倒计时 seconds 秒，倒计时完成发送一个信号 <code>SIGALRM</code> , 当前进程会收到这个信号，这个信号默认的处理动作是中断当前进程</p><p><strong>函数返回值：</strong></p><p>大于 0 表示倒计时还剩多少秒，返回值为 0 表示倒计时完成，信号被发出</p><p><strong>小案例:</strong></p><blockquote><p>使用这个定时器函数，检测一下当前计算机 1s 钟之内能数多少个数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 设置一个定时器, 定时1s</span></span><br><span class="line">    alarm(<span class="number">1</span>);<span class="comment">// 1s之后会发出一个信号, 这个信号将中断当前进程</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 time 命令查看程序执行的时间。 程序运行的瓶颈在于 IO，优化程序，首选优化 IO。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接通过终端输出</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">time ./a.out</span></span><br><span class="line">real    0m1.013s# 实际数数用的总时间</span><br><span class="line">user    0m0.060s# 用户区代码使用的时间</span><br><span class="line">sys     0m0.324s# 内核区使用的时间</span><br><span class="line"></span><br><span class="line">real = user + sys + 消耗的时间(频率的从用户区到内核区进程切换)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不直接写终端, 将数据重定向到磁盘文件中</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">time ./a.out &gt; a.txt</span></span><br><span class="line">Alarm clock</span><br><span class="line"></span><br><span class="line">real    0m1.002s    # 用户实际数数的时间变长了</span><br><span class="line">user    0m0.740s</span><br><span class="line">sys     0m0.236s</span><br></pre></td></tr></table></figure><p><mark>实际执行时间 = 系统时间 + 用户时间 + 等待时间</mark></p><h3 id="7-2-setitimer-函数">7.2 setitimer()函数</h3><p>设置定时器(闹钟)。 可代替 <code>alarm</code> 函数。精度微秒 us，可以实现周期定时。</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以实现周期性定时, 每个一段固定的时间, 发出一个特定的定时器信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, </span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>which</code>：指定定时方式</p><p>① 自然定时：<code>ITIMER_REAL</code> → 14）SIGLARM 计算自然时间</p><p>② 虚拟空间计时(用户空间)：<code>ITIMER_VIRTUAL</code> → 26）SIGVTALRM 只计算进程占用 cpu 的时间</p><p>③ 运行时计时(用户+内核)：<code>ITIMER_PROF </code>→ 27）SIGPROF 计算占用 cpu 及执行系统调用的时间</p></li><li class="lvl-2"><p><code>new_value: </code>给定时器设置定时秒数，传入参数</p></li><li class="lvl-2"><p><code>old_value:</code> 上一次给定时器设置的定时信息，传出参数，如果不需要这个信息，指定为 NULL</p></li></ul><p><strong>函数返回值：</strong></p><p>​成功： 0</p><p>​失败： -1 errno</p><p><strong>类型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line"><span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;it_interval;---&gt; 用于设定两个定时任务之间的间隔时间</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span>      tv_sec;         </span><br><span class="line"><span class="type">suseconds_t</span> tv_usec;        </span><br><span class="line">&#125;it_value;  ---&gt; 第一次定时秒数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以理解为有2个定时器</p><ul class="lvl-0"><li class="lvl-2"><p>一个用于第一个闹钟什么时候触发打印</p></li><li class="lvl-2"><p>一个用于之后间隔多少时间再次触发闹钟。</p></li></ul><p><strong>小案例</strong></p><blockquote><p>使用setitimer定时，向屏幕打印信息：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/530127108e5f459b88e4f2661c9c54da.png#pic_center" alt=""></p><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/44bc3eaa9b39435b8ffcf24c1da9e529.png#pic_center" alt=""></p><p>第一次信息打印是两秒间隔，之后都是5秒间隔打印一次</p><h2 id="8-信号集操作函数">8.信号集操作函数</h2><p>内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字 mask 可以影响未决信号集。而我们可以在应 用程序中自定义 set 来改变mask。已达到屏蔽指定</p><p>信号的目的。因为用户是不能直接操作内核中的阻塞信号集和未决信号集的，必须要调用系统函数，关于阻塞信号集可以通过系统函数进行读写操作，未决信号集</p><p>只能对其进行读操作。</p><p><img src="https://img-blog.csdnimg.cn/496e997a408c479ab33f9665a5b16102.png#pic_center" alt=""></p><h3 id="8-1-信号集设定">8.1 信号集设定</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 如果在程序中读写 sigset_t 类型的变量</span></span><br><span class="line"><span class="comment">// 阻塞信号集和未决信号集都存储在 sigset_t 类型的变量中, 这个变量对应一块内存</span></span><br><span class="line"><span class="comment">// 阻塞信号集和未决信号集, 对应的内存中有1024bit = 128字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将set集合中所有的标志位设置为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;成功：<span class="number">0</span>；失败：<span class="number">-1</span></span><br><span class="line"><span class="comment">// 将set集合中所有的标志位设置为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;成功：<span class="number">0</span>；失败：<span class="number">-1</span></span><br><span class="line"><span class="comment">// 将set集合中某一个信号(signum)对应的标志位设置为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;成功：<span class="number">0</span>；失败：<span class="number">-1</span></span><br><span class="line"><span class="comment">// 将set集合中某一个信号(signum)对应的标志位设置为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;成功：<span class="number">0</span>；失败：<span class="number">-1</span></span><br><span class="line"><span class="comment">// 判断某个信号在集合中对应的标志位到底是0还是1, 如果是0返回0, 如果是1返回1(相当于判断某个信号是否在集合中)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;返回值：在集合：<span class="number">1</span>；不在：<span class="number">0</span>； 出错：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><code>sigset_t</code> 类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</p><h3 id="8-2-sigprocmask-函数">8.2 sigprocmask()函数</h3><p>用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB 中) 严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 使用这个函数修改内核中的阻塞信号集</span></span><br><span class="line"><span class="comment">// sigset_t 被封装之后得到的数据类型, 原型:int[32], 里边一共有1024个标志位, 每一个信号对应一个标志位</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数:</strong><br><code>how:</code></p><ul class="lvl-0"><li class="lvl-2"><p><code>SIG_BLOCK:</code> 当 how设置为此值，set 表示需要屏蔽的信号。相当于 mask = mask|set</p></li><li class="lvl-2"><p><code>SIG_UNBLOCK:</code> 当 how设置为此，set 表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~set</p></li><li class="lvl-2"><p><code>SIG_SETMASK: </code>使用参数 set 集合中的数据覆盖内核的阻塞信号集数据</p></li></ul><p><code>set:</code></p><p>传入参数，是一个位图，set 中哪位置 1，就表示当前进程屏蔽哪个信号。</p><p><code>oldset:</code></p><p>传出参数，保存旧的信号屏蔽集，如果不需要可以指定为 NULL</p><p><strong>函数返回值：</strong></p><p>函数调用成功返回 0，调用失败返回 - 1</p><h3 id="8-4-sigpending-函数">8.4 sigpending() 函数</h3><p>读取当前进程的未决信号集</p><p><code>int sigpending(sigset_t *set);</code>  set 传出参数。 返回值：成功：0；失败：-1，设置 errno</p><p><strong>小案例</strong></p><blockquote><p>需求:<br>在阻塞信号集中设置某些信号阻塞, 通过一些操作产生这些信号, 然后读未决信号集, 最后再解除这些信号的阻塞假设阻塞这些信号:</p><ul class="lvl-1"><li class="lvl-2">2号信号: SIGINT: ctrl+c</li><li class="lvl-2">3号信号: SIGQUIT: ctrl+\</li><li class="lvl-2">9号信号: SIGKILL: 通过shell命令给进程发送这个信号 kill -9 PID</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    <span class="comment">// 设置阻塞的信号</span></span><br><span class="line">    sigaddset(&amp;myset, SIGINT);  <span class="comment">// 2</span></span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT); <span class="comment">// 3</span></span><br><span class="line">    sigaddset(&amp;myset, SIGKILL); <span class="comment">// 9 测试不能被阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将初始化的信号集中的数据设置给内核</span></span><br><span class="line">    <span class="type">sigset_t</span> old;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, &amp;old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 让进程一直运行, 在当前进程中产生对应的信号</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 读内核的未决信号集</span></span><br><span class="line">        <span class="type">sigset_t</span> curset;</span><br><span class="line">        sigpending(&amp;curset);</span><br><span class="line">        <span class="comment">// 遍历这个信号集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret = sigismember(&amp;curset, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 解除阻塞, 重新设置阻塞信号集</span></span><br><span class="line">            <span class="comment">//sigprocmask(SIG_UNBLOCK, &amp;myset, NULL);</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;old, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/ae723be5aa8a4726aba321385881098a.png#pic_center" alt=""></p><p><mark>通过测试最终得到结论：程序中对 9 号信号的阻塞是无效的，因为它无法被阻塞。</mark></p><h2 id="9-信号捕捉">9.信号捕捉</h2><p>Linux 中的每个信号产生之后都会有对应的默认处理行为，如果想要忽略这个信号或者修改某些信号的默认行为就需要在程序中捕捉该信号。程序中进行信号捕捉可以看做是一个注册的动作，提前告诉应用程序信号产生之后做什么样的处理，当进程中对应的信号产生了，这个处理动作也就被调用了。</p><h3 id="9-1-signal-函数">9.1 signal()函数</h3><p>使用<code> signal()</code> 函数可以捕捉进程中产生的信号，并且修改捕捉到的函数的行为，这个信号的自定义处理动作是一个回调函数，内核通过 <code>signal()</code> 得到这个回调函数的地址，在信号产生之后该函数会被内核调用。</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 在程序中什么时候产生信号, 程序猿是不知道的, 因此不能在信号产生之后再去处理</span></span><br><span class="line"><span class="comment">// 在信号产生之前, 提供一个注册函数, 用来捕捉信号</span></span><br><span class="line"><span class="comment">//  - 假设在将来这个信号产生了, 就委托内核进行捕捉, 这个信号的默认动作就不能被执行</span></span><br><span class="line"><span class="comment">//  - 执行什么样的处理动作 ==&gt; 在signal函数中指定的处理动作</span></span><br><span class="line"><span class="comment">//  - 如果这个信号不产生, 回调函数永远不会被调用</span></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;   </span><br></pre></td></tr></table></figure><p><strong>函数参数:</strong></p><p><code>signum:</code> 需要捕捉的信号</p><p><code>handler:</code> 信号捕捉到之后的处理动作，这是一个函数指针，函数原型<code>typedef void (*sighandler_t)(int);</code></p><p><mark>这个回调函数是需要程序猿写的，但是程序猿不调用，由内核调用，内核调用回调函数的时候，会给它传递一个实参，这个实参的值就是捕捉的那个信号值。</mark></p><p><strong>小案例</strong></p><blockquote><p>下面的测试程序中使用 signal () 函数来捕捉定时器产生的信号 SIGALRM：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">doing</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前捕捉到的信号是: %d\n&quot;</span>, arg);</span><br><span class="line">    <span class="comment">// 打印当前的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册要捕捉哪一个信号, 执行什么样的处理动作</span></span><br><span class="line">    signal(SIGALRM, doing);</span><br><span class="line">    <span class="comment">// 1. 调用定时器函数设置定时器函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">newact</span>;</span></span><br><span class="line">    <span class="comment">// 3s之后发出第一个定时器信号, 之后每隔1s发出一个定时器信号</span></span><br><span class="line">    newact.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    newact.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    newact.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">    newact.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个函数也不是阻塞函数, 函数调用成功, 倒计时开始</span></span><br><span class="line">    <span class="comment">// 倒计时过程中程序是继续运行的</span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;newact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写一个业务处理, 阻止当前进程自己结束, 让当前进程被发出的信号杀死</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下:</p><p><img src="https://img-blog.csdnimg.cn/b6371a8887794bd6b1734ee65ec86bd4.png#pic_center" alt=""></p><h3 id="9-2-sigaction-函数">9.2 sigaction()函数</h3><p><code>sigaction ()</code> 函数和 <code>signal ()</code> 函数的功能是一样的，用于捕捉进程中产生的信号，并将用户自定义的信号行为函数（回调函数）注册给内核，内核在信号产生之后调用这个处理动作。<code>sigaction ()</code> 可以看做是 <code>signal ()</code> 函数是加强版，函数参数更多更复杂，函数功能也更强一些。</p><p><strong>函数原型:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数:</strong></p><p><code>signum:</code> 要捕捉的信号</p><p><code>act:</code> 捕捉到信号之后的处理动作</p><p><code>oldact:</code> 上一次调用该函数进行信号捕捉设置的信号处理动作，该参数一般指定为 NULL</p><p><strong>函数返回值：</strong></p><p>函数调用成功返回 0，失败返回 - 1</p><p>该函数的参数是一个结构体类型，结构体原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);    <span class="comment">// 指向一个函数(回调函数)</span></span><br><span class="line"><span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line"><span class="type">sigset_t</span>   sa_mask;             <span class="comment">// 初始化为空即可, 处理函数执行期间不屏蔽任何信号</span></span><br><span class="line"><span class="type">int</span>        sa_flags;        <span class="comment">// 0</span></span><br><span class="line"><span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);  <span class="comment">//不用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sa_restorer</code>：该元素是过时的，不应该使用，POSIX.1 标准将不指定该元素。(弃用)</p><p><code>sa_sigaction</code>：当 <code>sa_flags</code> 被指定为 <code>SA_SIGINFO</code>标志时，使用该信号处理程序。(很少使用)</p><p><mark>重点掌握：</mark></p><p>① <code>sa_handler</code>：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为 <code>SIG_IGN</code>表忽略 或 <code>SIG_DFL</code> 表执行默认动作</p><p>② <code>sa_mask</code>: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</p><p>③ <code>sa_flags</code>：通常设置为 0，表使用默认属性。</p><p><strong>小案例</strong>：</p><blockquote><p>通过 sigaction () 捕捉阻塞信号集中解除阻塞的信号</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前捕捉的信号: %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    <span class="comment">// 设置阻塞的信号</span></span><br><span class="line">    sigaddset(&amp;myset, SIGINT);  <span class="comment">// 2</span></span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT); <span class="comment">// 3</span></span><br><span class="line">    sigaddset(&amp;myset, SIGKILL); <span class="comment">// 9 测试不能被阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当阻塞的信号被解除阻塞, 该信号就可以被捕捉到了</span></span><br><span class="line">    <span class="comment">// 如果信号被捕捉到之后, 马上就被处理掉了 --&gt; 递达状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = callback;</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 和sigint的处理动作相同</span></span><br><span class="line">    sigaction(SIGQUIT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGKILL, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将初始化的信号集中的数据设置给内核</span></span><br><span class="line">    <span class="type">sigset_t</span> old;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, &amp;old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 让进程一直运行, 在当前进程中产生对应的信号</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 读内核的未决信号集</span></span><br><span class="line">        <span class="type">sigset_t</span> curset;</span><br><span class="line">        sigpending(&amp;curset);</span><br><span class="line">        <span class="comment">// 遍历这个信号集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret = sigismember(&amp;curset, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 解除阻塞, 重新设置阻塞信号集</span></span><br><span class="line">            <span class="comment">//sigprocmask(SIG_UNBLOCK, &amp;myset, NULL);</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;old, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/e34f30b1f71f4040966f80b5dc068b4e.png#pic_center" alt=""></p><h3 id="9-3-信号捕捉的特性">9.3 信号捕捉的特性</h3><p>信号捕捉特性：</p><ol><li class="lvl-3"><p>捕捉函数执行期间，信号屏蔽字 由 mask --&gt; sa_mask , 捕捉函数执行结束。 恢复回mask</p></li><li class="lvl-3"><p>捕捉函数执行期间，本信号自动被屏蔽(sa_flgs = 0).其他信号不屏蔽，如需屏蔽则调用sigsetadd函数修改</p></li><li class="lvl-3"><p>捕捉函数执行期间，被屏蔽信号多次发送，解除屏蔽后只处理一次！</p></li></ol><h2 id="10-内核实现信号捕捉简析">10.内核实现信号捕捉简析</h2><p><img src="https://img-blog.csdnimg.cn/966b608837434932af7ff37393b4bfe4.png#pic_center" alt=""></p><h2 id="11-SIGCHLD-信号">11.SIGCHLD 信号</h2><h3 id="11-1-SIGCHLD-的产生条件">11.1 SIGCHLD 的产生条件</h3><ul class="lvl-0"><li class="lvl-2"><p>子进程终止时</p></li><li class="lvl-2"><p>子进程接收到SIGSTOP</p></li><li class="lvl-2"><p>子进程处于停止态，接收到SIGCONT后唤醒时</p></li></ul><h3 id="11-2-借助-SIGCHLD-信号回收子进程">11.2 借助 SIGCHLD 信号回收子进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收子进程处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">recycle</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号是: %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 子进程的资源回收, 非阻塞</span></span><br><span class="line">    <span class="comment">// SIGCHLD信号17号信号, 1-31号信号不支持排队</span></span><br><span class="line">    <span class="comment">// 如果这些信号同时产生多个, 最终处理的时候只处理一次</span></span><br><span class="line">    <span class="comment">// 假设多个子进程同时退出, 父进程同时收到了多个sigchld信号</span></span><br><span class="line">    <span class="comment">// 父进程只会处理一次这个信号, 因此当前函数被调用了一次, waitpid被调用一次</span></span><br><span class="line">    <span class="comment">// 相当于只回收了一个子进程, 但是是同时死了多个子进程, 因此就出现了僵尸进程</span></span><br><span class="line">    <span class="comment">// 解决方案: 循环回收即可</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是阻塞回收, 就回不到另外一个处理逻辑上去了</span></span><br><span class="line">        <span class="type">pid_t</span> pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child died, pid = %d\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有死亡的子进程, 直接退出当前循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;所有子进程都回收完毕了, 拜拜...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置sigchld信号阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    sigaddset(&amp;myset, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环创建多个子进程 - 20</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 注册信号捕捉, 捕捉sigchld</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags  =<span class="number">0</span>;</span><br><span class="line">        act.sa_handler = recycle;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        <span class="comment">// 注册信号捕捉, 委托内核处理将来产生的信号</span></span><br><span class="line">        <span class="comment">// 当信号产生之后, 当前进程优先处理信号, 之前的处理动作会暂停</span></span><br><span class="line">        <span class="comment">// 信号处理完毕之后, 回到原来的暂停的位置继续运行</span></span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解除sigcld信号的阻塞</span></span><br><span class="line">        <span class="comment">// 信号被阻塞之后,就捕捉不到了, 解除阻塞之后才能捕捉到这个信号</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程执行其他业务逻辑就可以了</span></span><br><span class="line">        <span class="comment">// 默认父进程执行这个while循环, 但是信号产生了, 这个执行逻辑或强迫暂停</span></span><br><span class="line">        <span class="comment">// 父进程去处理信号的处理函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SIGCHLD 信号注意问题</strong></p><ol><li class="lvl-3"><p>子进程继承父进程的信号屏蔽字和信号处理动作，但子进程没有继承未决信号集 spending。</p></li><li class="lvl-4"><p>注意注册信号捕捉函数的位置。</p></li><li class="lvl-4"><p>应该在 fork 之前，阻塞 SIGCHLD 信号。注册完捕捉函数后解除阻塞。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统编程 </tag>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之进程间通信(IPC)</title>
      <link href="/posts/666d535d.html"/>
      <url>/posts/666d535d.html</url>
      
        <content type="html"><![CDATA[<div style ="position: relative ; width :100%; height: 0; padding-bottom:75%;"><iframe src ="//player.bilibili.com/player.html?aid=74876136&bvid=BV1KE411q7ee&cid=128069720&page=1" scrolling ="no" border="0" frameborder="no" framespacing ="0" allowfullscreen ="true" style =" position: absolute; width :100%; height :100%; left:0; top:0;" ></iframe></div > I <h2 id="1-IPC-方法">1.IPC 方法</h2><p>Linux 环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另 一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区， 进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为<code>进程间通信</code>（IPC，InterProcess Communication）。</p><p><img src="https://img-blog.csdnimg.cn/a3316833835a44c5b1c03c42af5cb4d7.png#pic_center" alt=""></p><p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套 接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：</p><p>① 管道 (使用最简单)</p><p>② 信号 (开销最小)</p><p>③ 共享映射区 (无血缘关系)</p><p>④ 本地套接字 (最稳定)</p><p>下面重点介绍管道，其余方式后续会再讲。</p><h2 id="2-匿名管道">2.匿名管道</h2><h3 id="2-1-什么是匿名管道">2.1 什么是匿名管道</h3><p>匿名管道是管道的一种，既然是匿名也就是说这个管道没有名字，但其本质是不变的，就是位于内核中的一块内存，匿名管道拥有上面介绍的管道的所有特性，额外的我们需要知道，匿名管道只能实现有血缘关系的进程间通信，什么叫<code>有血缘的进程关系</code>呢，比如：<code>父子进程</code>，<code>兄弟进程</code>，<code>爷孙进程</code>，<code>叔侄进程</code>。最后说一下创建匿名管道的函数<code>pipe()</code>，函数如下：</p><h3 id="2-2-pipe-函数">2.2 pipe() 函数</h3><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个匿名的管道, 得到两个可用的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数</strong>：</p><p>传出参数，需要传递一个整形数组的地址，数组大小为 2，也就是说最终会传出两个元素</p><ul class="lvl-0"><li class="lvl-2"><p>pipefd[0]: 对应管道读端的文件描述符，通过它可以将数据从管道中读出</p></li><li class="lvl-2"><p>pipefd[1]: 对应管道写端的文件描述符，通过它可以将数据写入到管道中</p></li></ul><p>向管道文件读写数据其实是在读写内核缓冲区。</p><p><strong>函数返回值</strong></p><p>成功返回 0，失败返回 -1</p><h3 id="2-3-管道特性">2.3 管道特性</h3><ol><li class="lvl-3"><p>其本质是一个伪文件(实为内核缓冲区,不占用磁盘大小)</p></li><li class="lvl-3"><p>有两个文件描述符引用，一个表示读端，一个表示写端。</p></li><li class="lvl-3"><p>规定数据从管道的写端流入管道，从读端流出。</p><p>管道的原理: 管道实为内核使用<code>环形队列机制</code>，借助<code>内核缓冲区(4k)实现</code>。</p><p>管道的局限性：</p><p>① 数据不能进程自己写，自己读。</p><p>② 管道中数据不可反复读取。一旦读走，管道中不再存在。</p><p>③ 采用<code>半双工通信方式</code>，数据只能在单方向上流动。</p><p>④ 只能在有公共祖先的进程间使用管道。</p><p>常见的通信方式有，<code>单工通信</code>、<code>半双工通信</code>、<code>全双工通信</code>。</p></li></ol><p>管道在内核中，不能直接对其进行操作，我们通过什么方式去读写管道呢？其实管道操作就是文件 IO 操作，内核中管道的两端分别对应两个文件描述符，通过写端的文件描述符把数据写入到管道中，通过读端的文件描述符将数据从管道中读出来。读写管道的函数就是 Linux 中的文件 IO 函数     <mark>点击查看</mark>-&gt; <a href="https://blog.csdn.net/qq_59084325/article/details/126471807?spm=1001.2014.3001.5501">read()/write()函数详解</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读管道</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">// 写管道的函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-4-父子进程间通信">2.4 父子进程间通信</h3><p><strong>父子进程通信原理</strong></p><p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？ 通常可以采用如下步骤：</p><p><img src="https://img-blog.csdnimg.cn/f040b683531c4b489caf6532dc8d7bf6.png#pic_center" alt=""></p><ol><li class="lvl-3"><p>父进程调用 <code>pipe </code>函数创建管道，得到两个文件描述符 fd[0]、fd[1]指向管道的读端和写端。</p></li><li class="lvl-3"><p>父进程调用 <code>fork</code> 创建子进程，那么子进程也有两个文件描述符指向同一管道。</p></li><li class="lvl-3"><p>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p></li></ol><p><strong>小练习</strong></p><blockquote><p>父进程往管道里写，子进程从管道读，然后打印读取的内容</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *str = <span class="string">&quot;hello pipe\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读段</span></span><br><span class="line">  <span class="comment">// sleep(3);  //防止终端提示和输出混杂在一起</span></span><br><span class="line">write(fd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd[<span class="number">1</span>]); <span class="comment">// 子进程关闭写段</span></span><br><span class="line">ret = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child read ret = %d\n&quot;</span>, ret);</span><br><span class="line">write(STDOUT_FILENO, buf, ret);</span><br><span class="line"></span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/510faf6738a7410cb1a142eb6aca135f.png#pic_center" alt=""></p><h3 id="2-5-管道读写行为">2.5 管道读写行为</h3><p><strong>读管道：</strong></p><p>1 .管道有数据，read返回实际读到的字节数。</p><p>2 .管道无数据：</p><ul class="lvl-0"><li class="lvl-2"><p>没有写端，read返回0 （类似读到文件尾）</p></li><li class="lvl-2"><p>有写端，read阻塞等待。</p></li></ul><p><strong>写管道：</strong></p><p>1 .没有读端， 异常终止。 （SIGPIPE导致的）</p><p>2 .有读端：</p><ul class="lvl-0"><li class="lvl-2"><p>管道已满， 阻塞等待</p></li><li class="lvl-2"><p>管道未满， 返回写出的字节个数。</p></li></ul><p><strong>小案例</strong></p><blockquote><p>1.使用管道实现父子进程间通信，完成：ls | wc –l。假定父进程实现 wc，子进程实现 ls</p></blockquote><p><mark>分析</mark>:</p><p>ls命令正常会将结果集写到stdout，但现在会写入管道写端</p><p>wc -l命令正常应该从stdin读取数据，但此时会从管道的读端读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">ret = pipe(fd); <span class="comment">// 父进程先创建一个管道,持有管道的读端和写端</span></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sys_err(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid = fork(); <span class="comment">// 子进程同样持有管道的读和写端</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123; <span class="comment">// 父进程 读, 关闭写端</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">dup2(fd[<span class="number">0</span>], STDIN_FILENO);<span class="comment">// 重定向 stdin 到 管道的 读端</span></span><br><span class="line">execlp(<span class="string">&quot;wc&quot;</span>, <span class="string">&quot;wc&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 执行 wc -l 程序</span></span><br><span class="line">sys_err(<span class="string">&quot;exclp wc error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">dup2(fd[<span class="number">1</span>], STDOUT_FILENO); <span class="comment">// 重定向 stdout 到 管道写端</span></span><br><span class="line">execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);<span class="comment">// 子进程执行 ls 命令</span></span><br><span class="line">sys_err(<span class="string">&quot;exclp ls error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/0614df6815f24409a664530cf3de34c9.png#pic_center" alt=""></p><p>直接执行命令，如下：</p><p><img src="https://img-blog.csdnimg.cn/c0f9f32049b74ce9b5e955a0fd58fb33.png#pic_center" alt=""></p><blockquote><p>2.使用管道实现兄弟进程间通信。 兄：ls 弟： wc -l 父：等待回收子进程。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> ret, i;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sys_err(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123; <span class="comment">// 表达式2 出口,仅限父进程使用</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 子进程,出口</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">&#123;  <span class="comment">// 父进程 . 不参与管道使用.</span></span><br><span class="line">close(fd[<span class="number">0</span>]); <span class="comment">// 关闭管道的 读端/写端.</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">wait(<span class="literal">NULL</span>); <span class="comment">// 回收子进程</span></span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">&#123; <span class="comment">// xiong</span></span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">dup2(fd[<span class="number">1</span>], STDOUT_FILENO); <span class="comment">// 重定向stdout</span></span><br><span class="line">execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">sys_err(<span class="string">&quot;exclp ls error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">&#123; <span class="comment">//弟弟</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">dup2(fd[<span class="number">0</span>], STDIN_FILENO); <span class="comment">// 重定向 stdin</span></span><br><span class="line">execlp(<span class="string">&quot;wc&quot;</span>, <span class="string">&quot;wc&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">sys_err(<span class="string">&quot;exclp wc error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-管道缓冲区大小">2.6 管道缓冲区大小</h3><p>可以使用 <code>ulimit –a</code> 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。(默认4096)</p><p><img src="https://img-blog.csdnimg.cn/b4906b45a28840e1b08c32213bbf4983.png#pic_center" alt=""><br>也可以使用 <code>fpathconf()</code> 函数，借助参数 选项来查看。使用该宏应引入头文件<code>&lt;unistd.h&gt;</code><br><code>long fpathconf(int fd, int name);</code> 成功：返回管道的大小 失败：-1，设置 <code>errno</code></p><h3 id="2-7-管道的优劣">2.7 管道的优劣</h3><p><strong>优点：</strong></p><p>简单，相比信号，套接字实现进程间通信，简单很多。</p><p><strong>缺点：</strong></p><ul class="lvl-0"><li class="lvl-3"><p>只能单向通信，双向通信需建立两个管道。</p></li><li class="lvl-2"><p>只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用 fifo 有名管道解决。</p></li></ul><h2 id="3-有名管道">3.有名管道</h2><p>有名管道拥有管道的所有特性，之所以称之为有名是因为管道在磁盘上有实体文件，文件类型为 <code>p</code> ，<code>有名管道文件大小永远为 0，因为有名管道也是将数据存储到内存的缓冲区中，打开这个磁盘上的管道文件就可以得到操作有名管道的文件描述符，通过文件描述符读写管道存储在内核中的数据。</code></p><h3 id="3-1-mkfifio-函数">3.1 mkfifio()函数</h3><p>有名管道也可以称为 fifo (first in first out)，使用有名管道既可以进行有血缘关系的进程间通信，也可以进行没有血缘关系的进程间通信。创建有名管道的方式有两种，一种是通过命令，一种是通过函数。</p><p><strong>通过命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> 有名管道的名字</span></span><br></pre></td></tr></table></figure><p><strong>通过函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">// int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><p><code>pathname: </code>要创建的有名管道的名字</p><p><code>mode:</code> 文件的操作权限，和 open () 的第三个参数一个作用，最终权限: (mode &amp; ~umask)</p><p><strong>返回值</strong>:</p><p>创建成功返回 0，失败返回 -1</p><p>一旦使用<code>mkfifo</code> 创建了一个 <code>FIFO</code>，就可以使用 <code>open</code> 打开它，常见的文件 <code>I/O函数</code>都可用于 <code>fifo</code>。如：<code>close</code>、<code>read</code>、 <code>write</code>、<code>unlink </code>等。</p><h3 id="3-2-fifo-实现非血缘关系进程间通信">3.2 fifo()实现非血缘关系进程间通信</h3><p>下面这个例子，一个写fifo，一个读fifo，操作起来就像文件一样的：</p><p><img src="https://img-blog.csdnimg.cn/16a397c7d0a04c6083a8d8466a6f9f9f.png#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/1cb929d808ce404b888ff9b799d4de8d.png#pic_center" alt=""></p><p>编译执行，如图：</p><p><img src="https://img-blog.csdnimg.cn/77efc3cf7e924c2aa542f293391eb017.png#pic_center" alt=""></p><h2 id="4-文件用于进程间通信">4.文件用于进程间通信</h2><p>文件实现进程间通信：</p><p>​打开的文件是内核中的一块缓冲区。多个无血缘关系的进程，可以同时访问该文件。</p><p><img src="https://img-blog.csdnimg.cn/b4c3ee9203744c78b10200cf27982070.png#pic_center" alt=""></p><p>文件通信有没有血缘关系都行，</p><ul class="lvl-0"><li class="lvl-2"><p>只是有血缘关系的进程对于同一个文件，使用的同一个文件描述符，</p></li><li class="lvl-2"><p>没有血缘关系的进程，对同一个文件使用的文件描述符可能不同。</p></li><li class="lvl-2"><p>这些都不是问题，打开的是同一个文件就行。</p></li><li class="lvl-2"><p>用文件通信没有阻塞等管道的特性，可能会遇到问题</p></li></ul><h2 id="5-内存映射-mmap">5.内存映射 (mmap)</h2><h3 id="5-1-存储映射-I-O">5.1 存储映射 I/O</h3><p>存储映射<code>I/O (Memory-mapped I/O)</code>使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用<code>read</code>和<code>write</code> 函数的情况下，使用地址（指针）完成 <code>I/O 操作</code>。 使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过<code>mmap 函数</code>来实现。</p><p><img src="https://img-blog.csdnimg.cn/4863df153e784ba7ae3c9ebb2a1e669e.png#pic_center" alt=""></p><h3 id="5-2-mmap-munmap-函数">5.2 mmap() /munmap()函数</h3><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建内存映射区</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数:</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>addr:</code> 从动态库加载区的什么位置开始创建内存映射区，一般指定为 <code>NULL</code>, 委托内核分配</p></li><li class="lvl-2"><p><code>length</code>: 创建的内存映射区的大小（单位：字节），实际上这个大小是按照 <code>4k </code>的整数倍去分配的</p></li><li class="lvl-2"><p><code>prot</code>: 对内存映射区的操作权限</p><ul class="lvl-2"><li class="lvl-4"><code>PROT_READ:</code> 读内存映射区</li><li class="lvl-4"><code>PROT_WRITE: </code>写内存映射区</li><li class="lvl-4">如果要对映射区有读写权限: <code>PROT_READ | PROT_WRITE</code></li></ul></li><li class="lvl-2"><p><code>flags:</code></p><ul class="lvl-2"><li class="lvl-4"><code>MAP_SHARED</code>: 多个进程可以共享数据，进行映射区数据同步</li><li class="lvl-4"><code>MAP_PRIVATE</code>: 映射区数据是私有的，不能同步给其他进程</li></ul></li><li class="lvl-2"><p><code>fd</code>: 文件描述符，对应一个打开的磁盘文件，内存映射区通过这个文件描述符和磁盘文件建立关联</p></li><li class="lvl-2"><p><code>offset</code>: 磁盘文件的偏移量，文件从偏移到的位置开始进行数据映射，使用这个参数需要注意两个问题：</p><ul class="lvl-2"><li class="lvl-4">偏移量必须是 4k 的整数倍，写 0 代表不偏移</li><li class="lvl-4">这个参数必须是大于 0 的</li></ul></li></ul><p><strong>函数返回值</strong></p><ul class="lvl-0"><li class="lvl-2"><p>成功：返回一个内存映射区的起始地址</p></li><li class="lvl-2"><p>失败: <code>MAP_FAILED (that is, (void *) -1)</code></p></li></ul><blockquote><p>mmap () 函数的参数相对较多，在使用该函数创建用于进程间通信的内存映射区的时候，各<strong>参数的指定</strong>都有一些注意事项，具体如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 第一个参数 addr 指定为 <span class="literal">NULL</span> 即可</span><br><span class="line"><span class="number">2.</span> 第二个参数 length 必须要 &gt; <span class="number">0</span></span><br><span class="line"><span class="number">3.</span> 第三个参数 prot，进程间通信需要对内存映射区有读写权限，因此需要指定为：PROT_READ | PROT_WRITE</span><br><span class="line"><span class="number">4.</span> 第四个参数 flags，如果要进行进程间通信, 需要指定 MAP_SHARED</span><br><span class="line"><span class="number">5.</span> 第五个参数 fd，打开的文件必须大于<span class="number">0</span>，进程间通信需要文件操作权限和映射区操作权限相同</span><br><span class="line">     - 内存映射区创建成功之后, 关闭这个文件描述符不会影响进程间通信</span><br><span class="line"><span class="number">6.</span> 第六个参数 offset，不偏移指定为<span class="number">0</span>，如果偏移必须是<span class="number">4</span>k的整数倍</span><br></pre></td></tr></table></figure><p>内存映射区使用完之后也需要释放，释放函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数:</strong></p><ul class="lvl-0"><li class="lvl-2"><p>addr: mmap () 的返回值，创建的内存映射区的起始地址</p></li><li class="lvl-2"><p>length: 和 mmap () 第二个参数相同即可</p></li></ul><p><strong>函数返回值</strong></p><ul class="lvl-0"><li class="lvl-2"><p>函数调用成功返回 0，失败返回 -1</p></li></ul><blockquote><p>总结：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建映射区的过程中，隐含着一次对映射文件的读操作。</span><br><span class="line"><span class="number">2.</span> 当MAP_SHARED 时，要求：映射区的权限应 &lt;= 文件打开的权限(出于对映射区的保护)。而 MAP_PRIVATE 则无所谓，因为mmap 中的权限是对内存的限制。</span><br><span class="line"><span class="number">3.</span> 映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。</span><br><span class="line"><span class="number">4.</span> 特别注意，当映射文件大小为 <span class="number">0</span> 时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！ mmap 使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。如，<span class="number">400</span> 字节大小的文件， 在建立映射区时 offset <span class="number">4096</span> 字节，则会报出总线错。</span><br><span class="line"><span class="number">5.</span> munmap传入的地址一定是mmap 的返回地址。坚决杜绝指针++操作。</span><br><span class="line"><span class="number">6.</span> 如果文件偏移量必须为<span class="number">4096</span>的整数倍（MMU 映射的最小单位 <span class="number">4</span>k ）</span><br><span class="line"><span class="number">7.</span> mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</span><br><span class="line"><span class="number">8.</span> 映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。</span><br><span class="line"><span class="number">9.</span> 映射区访问权限为 “私有”MAP_PRIVATE, 只需要open文件时，有读权限，用于创建映射区即可。</span><br><span class="line"><span class="number">10.</span> 映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。</span><br><span class="line"><span class="number">11.</span> 映射区访问权限为 “私有”MAP_PRIVATE, 只需要open文件时，有读权限，用于创建映射区即可。</span><br></pre></td></tr></table></figure><p><strong>小案例:使用mmap建立映射区</strong></p><p>下面这个示例代码，使用mmap创建一个映射区（共享内存），并往映射区里写入内容：</p><p><img src="https://img-blog.csdnimg.cn/a16179d09a804f129c44750452356add.png#pic_center" alt=""></p><p>编译运行，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/b4643d53cebd435b8cc968d6850b599d.png#pic_center" alt=""></p><h3 id="5-3-父子进程间mmap通信">5.3 父子进程间mmap通信</h3><p>父子等有血缘关系的进程之间也可以通过<code>mmap</code> 建立的映射区来完成数据通信。但相应的要在创建映射区的时 候指定对应的标志位参数 <code>flags</code>：</p><ul class="lvl-0"><li class="lvl-2"><p><code>MAP_PRIVATE</code>:(私有映射) 父子进程各自独占映射区；</p></li><li class="lvl-2"><p><code>MAP_SHARED</code>: (共享映射) 父子进程共享映射区；</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 先创建内存映射区, 得到一个起始地址, 假设使用ptr指针保存这个地址</span></span><br><span class="line"><span class="comment">    2. 通过fork() 创建子进程 -&gt; 子进程中也就有一个内存映射区, 子进程中也有一个ptr指针指向这个地址</span></span><br><span class="line"><span class="comment">    3. 父进程往自己的内存映射区写数据, 数据同步到了磁盘文件中, 磁盘文件数据又同步到子进程的映射区中</span></span><br><span class="line"><span class="comment">       子进程从自己的映射区往外读数据, 这个数据就是父进程写的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 2. 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, <span class="number">4000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                     MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程, 写数据</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;我是你爹, 你是我儿子吗???&quot;</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ptr, pt, <span class="built_in">strlen</span>(pt)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 读数据</span></span><br><span class="line">        usleep(<span class="number">1</span>);<span class="comment">// 内存映射区不阻塞, 为了让子进程读出数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从映射区读出的数据: %s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(ptr, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-无血缘关系进程间mmap通信">5.4 无血缘关系进程间mmap通信</h3><p>实质上<code>mmap</code> 是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核 空间多进程共享，因此无血缘关系的进程间也可使用<code>mmap</code> 来完成通信。只要设置相应的标志位参数 <code>flags </code>即可。若想实现共享，当然应该使用<code>MAP_SHARED </code>了。 值得注意的是：<code>MAP_ANON </code>和 <code>/dev/zero </code>都不能应用于非血缘关系进程间通信。只能用于亲子进程间。</p><p><strong>A代码(进行写操作)：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 2. 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, <span class="number">4000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                     MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;==================我是你爹, 你是我儿子吗???****************&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, pt, <span class="built_in">strlen</span>(pt)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(ptr, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B代码(进行读操作)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 2. 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, <span class="number">4000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                     MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读内存映射区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从映射区读出的数据: %s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(ptr, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-匿名映射">5.5 匿名映射</h3><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要 open 一个 temp 文件，创建好了再 unlink、close 掉，比较麻烦。可以直接使用匿名映射来代替。其实 Linux 系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数 flags 来指定。</p><p>使用<code>MAP_ANONYMOUS</code> (或<code>MAP_ANON</code>)， 如:<code>int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code></p><p>需注意的是，<code>MAP_ANONYMOUS 和 MAP_ANON 这两个宏是 Linux 操作系统特有的宏</code>。<code>在类 Unix 系统中如无该宏定义</code>，可使用如下两步来完成匿名映射区的建立。</p><p>① <code>fd = open(&quot;/dev/zero&quot;, O_RDWR);</code></p><p>② <code>p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0);</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统编程 </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之虚拟地址空间和文件描述符</title>
      <link href="/posts/b93c9a9c.html"/>
      <url>/posts/b93c9a9c.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://subingwen.cn/linux/file-descriptor/">原文链接</a></p><h2 id="1-虚拟地址空间">1.虚拟地址空间</h2><blockquote><p>虚拟地址空间是一个非常抽象的概念，先根据字面意思进行解释：</p><ul class="lvl-1"><li class="lvl-2">它可以用来加载程序数据（数据可能被加载到物理内存上，空间不够就加载到虚拟内存中）</li><li class="lvl-2">它对应着一段连续的内存地址，起始位置为 0。</li><li class="lvl-2">之所以说虚拟是因为这个起始的 0 地址是被虚拟出来的， 不是物理内存的 0 地址。</li></ul></blockquote><p>虚拟地址空间的大小也由操作系统决定，<code>32位的操作系统虚拟地址空间的大小为</code> 2<sup>32</sup> 字节，也就是 <code>4G</code>，64 位的操作系统虚拟地址空间大小为 264 字节，这是一个非常大的数，感兴趣可以自己计算一下。<code>当我们运行磁盘上一个可执行程序, 就会得到一个进程，内核会给每一个运行的进程创建一块属于自己的虚拟地址空间，并将应用程序数据装载到虚拟地址空间对应的地址上</code>。</p><p>进程在运行过程中，程序内部所有的指令都是通过 CPU 处理完成的，CPU 只进行数据运算并不具备数据存储的能力，其处理的数据都加载自物理内存，那么进程中的数据是如何进出入到物理内存中的呢？其实是通过 CPU 中的内存管理单元 MMU（Memory Management Unit）从进程的虚拟地址空间中映射过去的。</p><p><img src="https://subingwen.cn/linux/file-descriptor/image-20210130092825532.png" alt=""></p><h3 id="1-1-存在的意义">1.1 存在的意义</h3><p>通过上边的介绍大家会感觉到一头雾水， 为什么操作系统不直接将数据加载到物理内存中而是将数据加载到虚拟地址空间中，在通过 CPU 的 MMU 映射到物理内存中呢？</p><p>先来看一下如果直接将数据加载到物理内存会发生什么事情：</p><p><img src="https://subingwen.cn/linux/file-descriptor/image-20210130093119238.png" alt=""></p><blockquote><p>假设计算机的物理内存大小为 1G, 进程 A 需要 100M 内存因此直接在物理内存上从 0 地址开始分配 100M, 进程 B 启动需要 250M 内存，因此继续在物理内存上为其分配 250M 内存，并且进程 A 和进程 B 占用的内存是连续的。之后再启动其他进程继续按照这种方法进行物理内存的分配。。。</p><p>使用这种方式分配内存会有如下几个问题：</p></blockquote><p>1.<code>每个进程的地址不隔离，有安全风险。</code></p><p>由于程序都是直接访问物理内存，所以恶意程序可以通过内存寻址随意修改别的进程对应的内存数据，以达到破坏的目的。虽然有些时候是非恶意的，但是有些存在 bug 的程序可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。</p><p>2.<code>内存效率低。</code></p><p>如果直接使用物理内存的话，一个进程对应的内存块就是作为一个整体操作的，如果出现物理内存不够用的时候，我们一般的办法是将不常用的进程拷贝到磁盘的交换分区（虚拟内存）中，以便腾出内存，因此就需要将整个进程一起拷走，如果数据量大，在内存和磁盘之间拷贝时间就会很长，效率低下。</p><p>3.<code>进程中数据的地址不确定，每次都会发生变化。</code></p><p>由于物理内存的使用情况一直在动态的变化，我们无法确定内存现在使用到哪里了，如果直接将程序数据加载到物理内存，内存中每次存储数据的起始地址都是不一样的，这样数据的加载都需要使用相对地址，加载效率低（静态库是使用绝对地址加载的）。</p><blockquote><p>有了虚拟地址空间之后就可以完美的解决上边提到的所有问题了，<code>虚拟地址空间就是一个中间层，相当于在程序和物理内存之间设置了一个屏障，将二者隔离开来。程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上</code>。这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p></blockquote><h3 id="1-2-分区">1.2 分区</h3><p>从操作系统层级上看，虚拟地址空间主要分为两个部分<code>内核区</code>和<code>用户区</code>。</p><ul class="lvl-0"><li class="lvl-2"><p>内核区：</p><ul class="lvl-2"><li class="lvl-4">内核空间为内核保留，<code>不允许应用程序读写该区域的内容或直接调用内核代码定义的函数</code>。</li><li class="lvl-4">内核总是驻留在内存中，是操作系统的一部分。</li><li class="lvl-4">系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）。</li></ul></li><li class="lvl-2"><p>用户区：存储用户程序运行中用到的各种数据。</p></li></ul><p>我们先来看一下进程对应的虚拟地址空间的各个分区，再来详细介绍用户区的组成（以 32 位系统的虚拟地址空间为例）。</p><p><img src="https://subingwen.cn/linux/file-descriptor/image-20210130093015907.png" alt=""></p><p>每个进程的虚拟地址空间都是从 0 地址开始的，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，程序是无法直接访问物理内存的。虚拟地址空间中用户区地址范围是 0~3G，里边分为多个区块：</p><ul class="lvl-0"><li class="lvl-2"><p><code>保留区</code>: 位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针（NULL）指向的就是这块内存地址。</p></li><li class="lvl-2"><p><code>.text段</code>: 代码段也称正文段或文本段，通常用于存放程序的执行代码 (即 CPU 执行的机器指令)，代码段一般情况下是只读的，这是对执行代码的一种保护机制。</p></li><li class="lvl-2"><p><code>.data段</code>: 数据段通常用于存放程序中已初始化且初值不为 0 的全局变量和静态变量。数据段属于静态内存分配 (静态存储区)，可读可写。</p></li><li class="lvl-2"><p><code>.bss段</code>: 未初始化以及初始为 0 的全局变量和静态变量，操作系统会将这些未初始化变量初始化为 0</p></li><li class="lvl-2"><p><code>堆(heap)</code>：用于存放进程运行时动态分配的内存。</p><ul class="lvl-2"><li class="lvl-4">堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。</li><li class="lvl-4">堆向高地址扩展 (即 “向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</li></ul></li><li class="lvl-2"><p><code>内存映射区(mmap)</code>：作为内存映射区加载磁盘文件，或者加载程序运作过程中需要调用的动态库。</p></li><li class="lvl-2"><p><code>栈(stack)</code>: 存储函数内部声明的非静态局部变量，函数参数，函数返回地址等信息，栈内存由编译器自动分配释放。栈和堆相反地址 “向下生长”，分配的内存是连续的。</p></li><li class="lvl-2"><p><code>命令行参数</code>：存储进程执行的时候传递给 main() 函数的参数，argc，argv []</p></li><li class="lvl-2"><p><code>环境变量</code>: 存储和进程相关的环境变量，比如：工作路径，进程所有者等信息</p></li></ul><h2 id="2-文件描述符">2.文件描述符</h2><h3 id="2-1-文件描述符">2.1 文件描述符</h3><p>在 Linux 操作系统中的一切都被抽象成了文件，那么一个打开的文件是如何与应用程序进行对应呢？解决方案是使用<code>文件描述符（file descriptor，简称fd），当在进程中打开一个现有文件或者创建一个新文件时，内核向该进程返回一个文件描述符，用于对应这个打开/新建的文件</code>。这些文件描述符都存储在内核为每个进程维护的一个文件描述符表中。</p><p>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p><blockquote><p>在 Linux 系统中一切皆文件，系统中一切都被抽象成了文件。对这些文件的读写都需要通过文件描述符来完成。标准 C 库的文件 IO 函数使用的文件指针 <code>FILE*</code> 在 Linux 中也需要通过文件描述符的辅助才能完成读写操作。<code>FILE</code> 其实是一个结构体，其内部有一个成员就是文件描述符（下面结构体的第 25 行）。</p></blockquote><p><strong>FILE 结构体在 Linux 头文件中的定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux c FILE结构体定义： /usr/include/libio.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> _fileno;<span class="comment">// 文件描述符</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"> </span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文件: /usr/include/stdio.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure><h3 id="2-2文件描述符表">2.2文件描述符表</h3><p>前面讲到启动一个进程就会得到一个对应的虚拟地址空间，这个虚拟地址空间分为两大部分，在内核区有专门用于进程管理的模块。Linux 的进程控制块 PCB（process control block）本质是一个叫做 <code>task_struct</code> 的结构体，里边包括管理进程所需的各种信息，其中有一个结构体叫做 <code>file</code> ，我们将它叫做文件描述符表，里边有一个整形索引表，用于存储文件描述符。</p><p>内核为每一个进程维护了一个文件描述符表，索引表中的值都是从 0 开始的，所以在不同的进程中你会看到相同的文件描述符，但是它们指向的不一定是同一个磁盘文件。</p><p><img src="https://subingwen.cn/linux/file-descriptor/image-20210130123339157.png" alt=""></p><blockquote><p>知识小科普：</p><p>Linux 中用户操作的每个终端都被视作一个设备文件，当前操作的终端文件可以使用 /dev/tty 表示。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><strong>打开的最大文件数</strong></p><p>每一个进程对应的文件描述符表能够存储的打开的文件数是有限制的，默认为 1024 个，这个默认值是可以修改的，支持打开的最大文件数据取决于操作系统的件配置。</p></li><li class="lvl-2"><p><strong>默认分配的文件描述符</strong></p><p>当一个进程被启动之后，内核 PCB 的文件描述符表中就已经分配了三个文件描述符，这三个文件描述符对应的都是当前启动这个进程的终端文件（Linux 中一切皆文件，终端就是一个设备文件，在 /dev 目录中）</p><ul class="lvl-2"><li class="lvl-4"><p><code>STDIN_FILENO</code>：标准输入，可以通过这个文件描述符将数据输入到终端文件中，宏值为 0。</p></li><li class="lvl-4"><p><code>STDOUT_FILENO</code>：标准输出，可以通过这个文件描述符将数据通过终端输出出来，宏值为 1。</p></li><li class="lvl-4"><p><code>STDERR_FILENO</code>：标准错误，可以通过这个文件描述符将错误信息通过终端输出出来，宏值为 2。这三个默认分配的文件描述符是可以通过 close() 函数关闭掉，但是关闭之后当前进程也就不能和当前终端进行输入或者输出的信息交互了。</p></li></ul></li><li class="lvl-2"><p><strong>给新打开的文件分配文件描述符</strong></p><ul class="lvl-2"><li class="lvl-4">因为进程启动之后，文件描述符表中的 <code>0</code>,<code>1</code>,<code>2</code> 就被分配出去了，因此从 <code>3</code> 开始分配</li><li class="lvl-4">在进程中每打开一个文件，就会给这个文件分配一个新的文件描述符，比如：<ul class="lvl-4"><li class="lvl-6">通过 <code>open()</code> 函数打开 <code>/hello.txt</code>，文件描述符 3 被分配给了这个文件，保持这个打开状态，再次通过 <code>open()</code> 函数打开 <code>/hello.txt</code>，文件描述符 4 被分配给了这个文件，也就是说一个进程中不同的文件描述符打开的磁盘文件可能是同一个。</li><li class="lvl-6">通过 <code>open()</code> 函数打开 <code>/hello.txt</code>，文件描述符 3 被分配给了这个文件，将打开的文件关闭，此时文件描述符 3 就被释放了。再次通过 <code>open()</code> 函数打开 <code>/hello.txt</code>，文件描述符 3 被分配给了这个文件，也就是说打开的新文件会关联文件描述符表中最小的没有被占用的文件描述符。</li></ul></li></ul></li></ul><blockquote><p>总结:</p><ul class="lvl-1"><li class="lvl-2">每个进程对应的文件描述符表默认支持打开的最大文件数为 1024，可以修改</li><li class="lvl-2">每个进程的文件描述符表中都已经默认分配了三个文件描述符，对应的都是当前终端文件（/dev/tty）</li><li class="lvl-2">每打开新的文件，内核会从进程的文件描述符表中找到一个空闲的没有别占用的文件描述符与其进行关联</li><li class="lvl-2">文件描述符表中不同的文件描述符可以对应同一个磁盘文件</li><li class="lvl-2">每个进程文件描述符表中的文件描述符值是唯一的，不会重复</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统编程 </tag>
            
            <tag> 虚拟地址空间 </tag>
            
            <tag> 文件描述符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之进程</title>
      <link href="/posts/94cc42f5.html"/>
      <url>/posts/94cc42f5.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-进程相关概念">1.进程相关概念</h2><h3 id="1-1-程序和进程">1.1 程序和进程</h3><p>程序：是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、 设备、锁…)，是一个静态的概念 。</p><p>进程：被执行之后的程序叫做进程，不占用磁盘空间，需要消耗系统的内存，CPU资源，每个运行的进程的都对应一个属于自己的虚拟地址空间，这是一个动态的概念。</p><p>程序 → 剧本(纸)</p><p>进程 → 戏(舞台、演员、灯光、道具…)</p><p>同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响)<br>如：同时开两个终端。各自都有一个 bash 但彼此 ID 不同。</p><h3 id="1-2-并行和并发">1.2 并行和并发</h3><p><strong>并发</strong></p><ul class="lvl-0"><li class="lvl-2"><p>并发的同时运行是一个假象， CPU 在某一个时间点只能为某一个个体来服务，因此不可能同时处理多任务，这是通过计算机CPU的时间片快速切换实现的。</p></li><li class="lvl-2"><p>并发是针对某一个硬件资源而言的，在某个时间段之内处理的任务的总量，量越大效率越高。</p></li></ul><p><strong>并行</strong></p><ul class="lvl-0"><li class="lvl-2"><p>并行的多进程同时运行是真实存在的，可以在同一时刻同时运行多个进程</p></li><li class="lvl-2"><p>并行需要依赖多个硬件资源，单个是无法实现的。</p></li></ul><h3 id="1-3-PCB进程控制块">1.3 PCB进程控制块</h3><blockquote><p>PCB - 进程控制块（Processing Control Block），Linux 内核的进程控制块本质上是一个叫做 task_struct 的结构体。在这个结构体中记录了进程运行相关的一些信息，下面介绍一些常用的信息：</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>进程 id：每一个进程都一个唯一的进程 ID，类型为 pid_t, 本质是一个整形数</p></li><li class="lvl-2"><p>进程的状态：进程有不同的状态，状态是一直在变化的，有就绪、运行、挂起、停止等状态。</p></li><li class="lvl-2"><p>进程对应的虚拟地址空间的信息。</p></li><li class="lvl-2"><p>描述控制终端的信息，进程在哪个终端启动默认就和哪个终端绑定。</p></li><li class="lvl-2"><p>当前工作目录：默认情况下，启动进程的目录就是当前的工作目录</p></li><li class="lvl-2"><p>umask 掩码：在创建新文件的时候，通过这个掩码屏蔽某些用于对文件的操作权限。</p></li><li class="lvl-2"><p>文件描述符表：每个被分配的文件描述符都对应一个已经打开的磁盘文件和信号相关的信息：在 Linux 中 调用函数 , 键盘快捷键 , 执行shell命令等操作都会产生信号。</p></li><li class="lvl-2"><p>阻塞信号集：记录当前进程中阻塞哪些已产生的信号，使其不能被处理</p></li><li class="lvl-2"><p>未决信号集：记录在当前进程中产生的哪些信号还没有被处理掉。</p></li><li class="lvl-2"><p>用户 id 和组 id：当前进程属于哪个用户，属于哪个用户组</p></li><li class="lvl-2"><p>会话（Session）和进程组：多个进程的集合叫进程组，多个进程组的集合叫会话。</p></li><li class="lvl-2"><p>进程可以使用的资源上限：可以使用 shell 命令 ulimit -a 查看详细信息。</p></li></ul><h3 id="1-4-单道程序设计和多道程序设计">1.4 单道程序设计和多道程序设计</h3><p><strong>单道程序设计</strong></p><p>所有进程一个一个排对执行。若 A 阻塞，B 只能等待，即使 CPU 处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p><p><strong>多道程序设计</strong></p><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。<strong>时钟中断</strong>即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出 cpu 资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。在多道程序设计模型中，多个进程轮流使用 CPU (分时复用 CPU资源)。而当下常见 CPU为纳秒级，1 秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</p><h3 id="1-5-进程状态">1.5 进程状态</h3><p><a href="https://subingwen.cn/linux/process/#1-4-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81">参考链接</a></p><p>进程一共有五种状态分别为：<code>创建态</code>，<code>就绪态</code>，<code>运行态</code>，<code>阻塞态(挂起态)</code>，<code>退出态(终止态)</code> 其中创建态和退出态维持的时间是非常短的，稍纵即逝。我们主要是需要将<code>就绪态</code> ,<code>运行态</code>, <code>挂起态</code>，三者之间的状态切换搞明白。</p><p><img src="https://img-blog.csdnimg.cn/da67e5d956884ffc8c7a4be647e8e6fe.png#pic_center" alt=""></p><p>就绪态：</p><ul class="lvl-0"><li class="lvl-2"><p>进程被创建出来了，有运行的资格但是还没有运行，需要抢 CPU 时间片</p></li><li class="lvl-2"><p>得到 CPU 时间片，进程开始运行，从就绪态转换为运行态。</p></li><li class="lvl-2"><p>进程的 CPU 时间片用完了，再次失去 CPU, 从运行态转换为就绪态。</p></li></ul><p>运行态：</p><ul class="lvl-0"><li class="lvl-2"><p>获取到 CPU 资源的进程，进程只有在这种状态下才能运行</p></li><li class="lvl-2"><p>运行态不会一直持续，进程的 CPU 时间片用完之后，再次失去 CPU，从运行态转换为就绪态</p></li><li class="lvl-2"><p>只要进程还没有退出，就会在就绪态和运行态之间不停的切换。</p></li></ul><p>阻塞态：</p><ul class="lvl-0"><li class="lvl-2"><p>进程被强制放弃 CPU，并且没有抢夺 CPU 时间片的资格</p></li><li class="lvl-2"><p>比如：在程序中调用了某些函数（比如: sleep ()），进程由运行态转换为阻塞态（挂起态）</p></li><li class="lvl-2"><p>当某些条件被满足了（比如：sleep()睡醒了），进程的阻塞状态也就被解除了，进程从阻塞态转换为就绪态。</p></li></ul><p>退出态：</p><ul class="lvl-0"><li class="lvl-2"><p>进程被销毁，占用的系统资源被释放了</p></li><li class="lvl-2"><p>任何状态的进程都可以直接转换为退出态。</p></li></ul><h3 id="1-6-环境变量">1.6 环境变量</h3><p><code>echo $PATH</code>  查看环境变量</p><p>path环境变量里记录了一系列的值，当运行一个可执行文件时，系统会去环境变量记录的位置里查找这个文件并执行。</p><p><code>echo $TERM</code> 查看终端</p><p><code>echo $LANG</code> 查看语言</p><p><code>env</code>     查看所有环境变量</p><p><strong>补充</strong></p><p><code>ps aux</code> 返回结果里，第二列是进程id号</p><h2 id="2-进程创建">2.进程创建</h2><h3 id="2-1-getpid-getppid-fork-函数原型">2.1 getpid()/getppid()/fork()函数原型</h3><p>Linux 中进程 ID 为 pid_t 类型，其本质是一个正整数，通过上边的 ps aux 命令可以查看每个进程的进程ID号。PID 为 1 的进程是 Linux 系统中创建的第一个进程。</p><p>获取当前进程的进程 ID（PID）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>获取当前进程的父进程 ID（PPID）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>创建一个新的进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-fork-函数返回值">2.2 fork()函数返回值</h3><p><code>fork ()</code> 调用成功之后，会返回两个值，父子进程的返回值是不同的。</p><p>父进程的虚拟地址空间中将该返回值标记为一个大于 0 的数（其实记录的是子进程的进程 ID）</p><p>子进程的虚拟地址空间中将该返回值标记 0</p><p>在程序中需要通过 fork () 的返回值来判断当前进程是子进程还是父进程。</p><h3 id="2-3-fork-函数创建子进程示例">2.3 fork()函数创建子进程示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在父进程中创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程fork()的返回值: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程执行的逻辑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程执行的逻辑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d, 我爹是: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// pid == -1</span></span><br><span class="line">    &#123;</span><br><span class="line">    perror(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建子进程失败了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不加判断, 父子进程都会执行这个循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，如下所示</p><p><img src="https://img-blog.csdnimg.cn/4960546b2a1144d58a2b6b04a9490122.png#pic_center" alt=""></p><p>代码理解：我们在父进程中成功创建了子进程，子进程就拥有父进程代码区的所有代码，那么子进程中的代码是在什么位置开始运行的呢？父进程肯定是从 main () 函数开始运行的，子进程是在父进程中调用 fork () 函数之后被创建，子进程就从 fork () 之后开始向下执行代码。上代码演示了父子进程中代码的执行流程，可以看到如果在程序中对 fork() 的返回值做了判断，就可以控制父子进程的行为，如果没有做任何判断这个代码块父子进程都可以执行。在编写多进程程序的时候，一定要将代码想象成多份进行分析，因为直观上看代码就一份，但实际上数据都是多份，并且多份数据中变量名都相同，但是他们的值却不一定相同。</p><h3 id="2-4-循环创建多个子进程">2.4 循环创建多个子进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程pid: %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/1726df02995e4f1984f69e995727f5f3.png#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/4f4aaaebd1454220962c9adc2a2cbbb4.png#pic_center" alt=""></p><p>可以看出，这和我们预想的不一样，为什么呢，明明我用for循环只想创建出5个进程，但是却fork创建了这么多的子进程，这是因为在循环中创建出的子进程还会创建出孙子进程，孙子进程会创建出重孙进程，所以才会创建出这么多的进程，下面给出解决方法，我们可以只让父进程创建子进程，如果是子进程不让其继续创建子进程，因此只需要在程序中添加关于父子进程的判断即可，如果fork()==0，说明是子进程，那么我们就直接让子进程break出for循环，下面给出改进过后的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i am parent\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i am %dth child\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/f9ebe2c4c83043c1b06f8e3f408d9f80.png#pic_center" alt=""></p><p>看到如上代码，可能有的人或许有疑惑，为什么要调用sleep()函数，因为如果我们不调用sleep()函数的话，最终在终端显示的时候会是乱序的，如下图所示</p><p><img src="https://img-blog.csdnimg.cn/b2f1760eb78040789acd3ab18b589c7a.png#pic_center" alt=""></p><p>这是要因为，对操作系统而言，这几个子进程几乎是同时出现的，它们和父进程一起争夺cpu，谁抢到，谁打印，所以出现顺序是随机的。还有就是终端提示符混在了输出里，这是因为，fork1 进程启动之后，共创建了 5 个子进程，其实 fork1 也是有父进程的就是当前的终端，终端只能检测到fork1进程的状态，fork1执行期间终端切换到后台，a.out 执行完毕之后终端切换回前台，当终端切换到前台之后，fork1的子进程还没有执行完毕，所以子进程输出的信息就显示到终端命令提示符的后边了，导致终端显示有问题。因此想要解决这个问题，调用sleep()函数即可完美解决。</p><h3 id="2-5-父子进程共享哪些内容">2.5 父子进程共享哪些内容</h3><p>刚fork之后：(注意时间点)</p><p><strong>父子进程相同部分：</strong></p><p>data段、text段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位置、信号处理方式</p><p><strong>父子进程不同部分：</strong></p><p>进程id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p><p><strong>解释：</strong></p><p>在主进程使用fork()函数后，会创建出子进程，因为每个进程都会有自己的虚拟内存空间，所以子进程也会有自己单独的虚拟内存空间，他和主进程的虚拟内存空间是完全独立的，只不过子进程的虚拟内存空间是基于父进程的虚拟内存空间拷贝出来的，拷贝完成后，他们两0-3G的用户区是相同的，但是由于每个进程都有自己的进程 ID，因此内核区存储的父子进程 ID 是不同的。虽然他们在代码区的代码相同，但是执行时可以通过fork()函数的返回值来区分主进程和子进程的执行逻辑，似乎，子进程复制了父进程 0-3G 用户空间内容，以及父进程的 PCB，但 pid 不同。真的每 fork 一个子进程都要将父进程的 0-3G 地址空间完全拷贝一份，然后在映射至物理内存吗？当然不是！父子进程间遵循<strong>读时共享写时复制的原则</strong>。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</p><p>有的人可能会想通过全局变量来让父子进程之间进行通信，但是这是行不通的，因为每个进程都有自己的地址空间，两个同名全局变量存储在不同的虚拟地址空间中，二者没有任何关联性。如果想让父子进程之间进行通信交流，可以使用：管道，共享内存，本地套接字，内存映射区，消息队列等方式。后面会介绍这些方法。</p><h3 id="2-6-父子进程gdb调试">2.6 父子进程gdb调试</h3><p>使用 gdb 调试的时候，gdb 只能跟踪一个进程。可以在 fork 函数调用之前，通过指令设置 gdb 调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。</p><ul class="lvl-0"><li class="lvl-2"><p>设置父进程调试路径：<code>set follow-fork-mode parent (默认)</code></p></li><li class="lvl-2"><p>设置子进程调试路径：<code>set follow-fork-mode child</code></p></li></ul><p>注意，一定要在fork函数调用之前设置才有效。</p><h2 id="3-exec函数族">3.exec函数族</h2><p>fork 创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种 exec 函数以执行另一个程序。当进程调用一种 exec 函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用 exec 并不创建新进程，所以调用 exec 前后该进程的 id 并未变。</p><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">          <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">            <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p>这些函数执行成功无返回值，失败返回 -1</p><p><code>exec族函数</code>中最常用的有两个<code>execl()</code>和<code> execlp()</code>，这两个函数是对其他 4 个函数做了进一步的封装，下面介绍一下。</p><h3 id="3-1-execlp-函数">3.1 execlp()函数</h3><p>加载一个进程，借助 PATH环境变量</p><p><strong>函数原型</strong></p><p><code>int execlp(const char *file, const char *arg, …)</code></p><p><strong>函数参数</strong></p><p>参数1：要加载的程序名字，该函数需要配合PATH环境变量来使用，当PATH所有目录搜素后没有参数1则返回出错。</p><p>参数2：ps aux 查看进程的时候，启动的进程的名字，可以随意指定，一般和要启动的可执行程序名相同。</p><p>参数3 : 要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。</p><p><strong>函数返回值</strong></p><p>执行成功，无返回，执行失败，返回-1</p><p>该函数通常用来调用系统程序。如ls、date、cp、cat命令。</p><p>execlp这里面的p，表示要借助环境变量来加载可执行文件</p><h3 id="3-2-execl-函数">3.2 execl()函数</h3><p>该函数可用于执行任意一个可执行程序，函数需要通过指定的文件路径才能找到这个可执行程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 变参函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数</strong><br>参数1：要启动的可执行程序的路径，推荐使用绝对路径。</p><p>参数2：ps aux 查看进程的时候，启动的进程的名字，可以随意指定，一般和要启动的可执行程序名相同。</p><p>参数3：要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。</p><p><strong>函数返回值</strong></p><p>执行成功，无返回，执行失败，返回-1</p><p><strong>函数原型</strong></p><h3 id="3-3-小练习">3.3 小练习</h3><p><strong>1.通过execlp让子进程去执行ls命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-h&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;exec error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent pid = %d&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/ead9266bfab74c349b6acf4b32a94415.png#pic_center" alt=""></p><p><strong>2.使用execl来让子程序调用自定义的程序。</strong></p><p>注意</p><ul class="lvl-0"><li class="lvl-2"><p>和execlp不同的是，第一个参数是路径，不是文件名。</p></li><li class="lvl-2"><p>这个路径用相对路径和绝对路径都行。</p></li></ul><p><mark>hello.c</mark></p><p><img src="https://img-blog.csdnimg.cn/eef5a1c451f2442aa1040cc2a8031f73.png#pic_center" alt=""></p><p><mark>exec.c</mark></p><p><img src="https://img-blog.csdnimg.cn/ea74d1fa220a4afeb3b990ef912d336e.png#pic_center" alt=""></p><p>编译运行，结果如下所示：</p><p><img src="https://img-blog.csdnimg.cn/9a6c767e8e104905b715e8836e9dd773.png#pic_center" alt=""></p><h3 id="3-4-exec函数族特性">3.4 exec函数族特性</h3><p><strong>写一个程序，使用execlp执行进程查看，并将结果输出到文件里。</strong></p><p><img src="https://img-blog.csdnimg.cn/7eb4c463365041a9a3293b2e0df1111a.png#pic_center" alt=""></p><p>编译运行，结果如下所示：</p><p><img src="https://img-blog.csdnimg.cn/61684c3e52af4191aa7cb28210f5365f.png#pic_center" alt=""></p><p>exec函数一旦调用成功，即执行新的程序，不返回。只有失败才返回，错误值-1。所以通常我们直接在exec函数调用后直接调用perror()，和exit()，无需if判断。</p><p>l(list)命令行参数列表</p><p>p(path)搜索file时使用path变量</p><p>v(vector)使用命令行参数数组</p><p>e(environment)使用环境变量数组，不适用进程原有的环境变量，</p><p>设置新加载程序运行的环境变量</p><p>事实上，只有execve是真正的系统调用，其他5个函数最终都调用execve，是库函数，所以execve在man手册第二节，其它函数在man手册第3节。这些函数之间的关系如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/2292db940a6340789fd3bf920206b8f9.png#pic_center" alt=""></p><h2 id="4-回收子进程">4.回收子进程</h2><h3 id="4-1孤儿进程和僵尸进程">4.1孤儿进程和僵尸进程</h3><p>孤儿进程：</p><ul class="lvl-0"><li class="lvl-2"><p>父进程先于子进终止，子进程沦为“孤儿进程”，会被 init 进程(1号进程)领养。</p></li></ul><p>下面这段代码可以得到一个僵尸进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);<span class="comment">// 强迫子进程睡眠1s, 这个期间, 父进程退出, 当前进程变成了孤儿进程，子进程被1号进程回收</span></span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>僵尸进程：</p><ul class="lvl-0"><li class="lvl-2"><p>子进程终止，父进程尚未对子进程进行回收，在此期间，子进程为“僵尸进程”。  kill 对其无效。这里要注意，每个进程结束后都必然会经历僵尸态，时间长短的差别而已。</p></li><li class="lvl-2"><p>子进程终止时，子进程残留资源PCB存放于内核中，PCB记录了进程结束原因，进程回收就是回收PCB。回收僵尸进程，得kill它的父进程，让孤儿院去回收它。</p></li></ul><p>下面这段代码可以得到一个僵尸进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="comment">// 一直运行不退出, 就会出现僵尸进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-wait-函数和waitpid-函数">4.2 wait()函数和waitpid()函数</h3><p>为了避免僵尸进程的产生，一般我们会在父进程中进行子进程的资源回收，回收方式有两种，一种是阻塞方式<code> wait()</code>，一种是非阻塞方式 <code>waitpid()</code>。</p><h4 id="4-2-1wait-函数">4.2.1wait()函数</h4><p>这是个阻塞函数，如果没有子进程退出，函数会一直阻塞等待，当检测到子进程退出了，该函数阻塞解除回收子进程资源。这个函数被调用一次，只能回收一个子进程的资源，如果有多个子进程需要资源回收，函数需要被调用多次。</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// man 2 wait</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数</strong></p><p>status：传出参数，回收进程的状态。</p><p><strong>函数返回值</strong></p><ul class="lvl-0"><li class="lvl-2"><p>成功：返回被回收的子进程的进程 ID</p></li><li class="lvl-2"><p>失败: -1</p><ul class="lvl-2"><li class="lvl-4">没有子进程资源可以回收了，函数的阻塞会自动解除，返回 - 1</li><li class="lvl-4">回收子进程资源的时候出现了异常</li></ul></li></ul><p><strong>函数作用</strong></p><ul class="lvl-0"><li class="lvl-2"><p>阻塞等待子进程退出</p></li><li class="lvl-2"><p>清理子进程残留在内核的 pcb 资源</p></li><li class="lvl-2"><p>通过传出参数，得到子进程结束状态</p></li></ul><h4 id="4-2-2-获取子进程退出值和异常终止信号">4.2.2 获取子进程退出值和异常终止信号</h4><ul class="lvl-0"><li class="lvl-2"><p>一个进程终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。</p></li><li class="lvl-2"><p>这个进程的父进程可以调用wait或者waitpid获取这些信息，然后彻底清除掉这个进程。</p></li><li class="lvl-2"><p>一个进程的退出状态可以在shell中用特殊变量$？查看，因为shell是它的父进程，当它终止时，shell调用wait或者waitpid得到它的退出状态，同时彻底清除掉这个进程。</p></li></ul><p><strong>获取子进程正常终止值：</strong></p><p>​WIFEXITED(status) --&gt; 为真 --&gt;调用 WEXITSTATUS(status) --&gt; 得到 子进程 退出值。</p><p><strong>获取导致子进程异常终止信号：</strong></p><p>​WIFSIGNALED(status) --&gt; 为真 --&gt;调用 WTERMSIG(status) --&gt; 得到 导致子进程异常终止的信号编号。</p><p><strong>小案例</strong>：</p><p>捕获程序异常终止的信号并打印：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">pid_t</span> pid, wpid;  </span><br><span class="line">    <span class="type">int</span> status;  </span><br><span class="line">  </span><br><span class="line">    pid = fork();  </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---child, my id= %d, going to sleep 10s\n&quot;</span>, getpid());  </span><br><span class="line">        sleep(<span class="number">10</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------child die--------------\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">73</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">//wpid = wait(NULL);          // 不关心子进程结束原因  </span></span><br><span class="line">        wpid = wait(&amp;status);       <span class="comment">// 如果子进程未终止,父进程阻塞在这个函数上  </span></span><br><span class="line">        <span class="keyword">if</span> (wpid == <span class="number">-1</span>) &#123;  </span><br><span class="line">            perror(<span class="string">&quot;wait error&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;        <span class="comment">//为真,说明子进程正常终止.   </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d\n&quot;</span>, WEXITSTATUS(status));  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;      <span class="comment">//为真,说明子进程是被信号终止.  </span></span><br><span class="line">  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child kill with signal %d\n&quot;</span>, WTERMSIG(status));  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------parent wait finish: %d\n&quot;</span>, wpid);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="4-2-3-waitpid-函数、">4.2.3 waitpid()函数、</h4><p>指定某一个进程进行回收。可以设置非阻塞。</p><p>waitpid(-1, &amp;status, 0) == wait(&amp;status);</p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// man 2 waitpid</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这个函数可以设置阻塞, 也可以设置为非阻塞</span></span><br><span class="line"><span class="comment">// 这个函数可以指定回收哪些子进程的资源</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数</strong></p><ul class="lvl-0"><li class="lvl-2"><p>pid：指定回收某一个子进程pid</p><ul class="lvl-2"><li class="lvl-4">大于0 回收指定 ID 的子进程</li><li class="lvl-4">-1 回收任意子进程（相当于wait）</li><li class="lvl-4">0 回收和当前调用waitpid 一个组的所有子进程</li><li class="lvl-4">小于 -1 回收指定进程组内的任意子进程</li></ul></li><li class="lvl-2"><p>status：（传出参数） 回收进程的状态,同wait()函数</p></li><li class="lvl-2"><p>options：控制函数是阻塞还是非阻塞</p><ul class="lvl-2"><li class="lvl-4">WNOHANG ：指定回收方式为，非阻塞</li><li class="lvl-4">0： 函数是行为是阻塞的 ==&gt; 和 wait 一样</li></ul></li></ul><p><strong>函数返回值</strong></p><ul class="lvl-0"><li class="lvl-2"><p>大于0 : 表成功回收的子进程 pid</p></li><li class="lvl-2"><p>等于0 : 函数是非阻塞的，并且子进程还在运行</p></li><li class="lvl-2"><p>-1: 失败。并设置errno</p></li></ul><p><strong>小案例</strong>：</p><p>回收指定子进程:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="type">pid_t</span> pid, wpid, tmpid;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;         </span><br><span class="line">        pid = fork();  </span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;       <span class="comment">// 循环期间, 子进程不 fork   </span></span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;  </span><br><span class="line">            tmpid = pid;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;--------pid = %d\n&quot;</span>, tmpid);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">5</span> == i) &#123;       <span class="comment">// 父进程, 从表达式2跳出  </span></span><br><span class="line">        sleep(<span class="number">5</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent , before waitpid, pid = %d\n&quot;</span>, tmpid);  </span><br><span class="line">  </span><br><span class="line">        wpid = waitpid(tmpid, <span class="literal">NULL</span>, WNOHANG);   <span class="comment">//指定一个进程回收, 不阻塞  </span></span><br><span class="line">        <span class="comment">//wpid = waitpid(tmpid, NULL, 0);         //指定一个进程回收, 阻塞回收  </span></span><br><span class="line">        <span class="keyword">if</span> (wpid == <span class="number">-1</span>) &#123;  </span><br><span class="line">            perror(<span class="string">&quot;waitpid error&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m parent, wait a child finish : %d \n&quot;</span>, wpid);  </span><br><span class="line">   </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 子进程, 从 break 跳出  </span></span><br><span class="line">         sleep(i);  </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %dth child, pid= %d\n&quot;</span>, i+<span class="number">1</span>, getpid());  </span><br><span class="line">     &#125;  </span><br><span class="line">   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="4-2-4-waitpid-回收多个子进程">4.2.4 waitpid()回收多个子进程</h4><p>一次wait/waitpid函数调用，只能回收一个子进程。下面来演示回收多个子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 回收子进程的资源</span></span><br><span class="line">            <span class="comment">// 子进程有多个, 需要循环回收子进程资源</span></span><br><span class="line">            <span class="comment">// 子进程退出了就回收, </span></span><br><span class="line">            <span class="comment">// 没退出就不回收, 返回0</span></span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);  <span class="comment">// 非阻塞</span></span><br><span class="line">            <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收了子进程资源, 子进程PID: %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="comment">// 判断进程是不是正常退出</span></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程退出时候的状态码: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程是被这个信号杀死的: %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程还没有退出, 不做任何处理...\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收失败, 或者是已经没有子进程了...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统编程 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之文件IO</title>
      <link href="/posts/651c43c5.html"/>
      <url>/posts/651c43c5.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-linux-man-1-2-3的作用">1.linux man 1 2 3的作用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、Standard commands （标准命令）</span><br><span class="line">2、System calls （系统调用）</span><br><span class="line">3、Library functions （库函数）</span><br><span class="line">4、Special devices （设备说明）</span><br><span class="line">5、File formats （文件格式）</span><br><span class="line">6、Games and toys （游戏和娱乐）</span><br><span class="line">7、Miscellaneous （杂项）</span><br><span class="line">8、Administrative Commands （管理员命令）</span><br><span class="line">9 其他（Linux特定的）， 用来存放内核例行程序的文档。</span><br></pre></td></tr></table></figure><p>说明：</p><p>系统调用     Linux内核提供的函数</p><p>库调用       c语言标准库函数和编译器特定库函数</p><p>例子：</p><p><code>man 1 cd</code></p><p><code>man 2 open</code></p><p><code>man 3 printf</code></p><p><strong>一个小案例</strong>:</p><p>C 标准函数和系统函数调用关系。一个 helloworld 如何打印到屏幕。</p><p><img src="https://img-blog.csdnimg.cn/bec6e0db7d184e3dae21532fba9f82be.png#pic_center" alt=""></p><h2 id="2-open函数">2.open函数</h2><h3 id="2-1函数原型">2.1函数原型</h3><p>manpage 第二卷(系统调用函数)，输入<mark>man 2 open</mark>指令</p><p>open函数如下，有两个版本的</p><p><img src="https://img-blog.csdnimg.cn/34cb8ac8d12b45eaaacfb49a30a1c59d.png#pic_center" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>open是一个系统函数, 只能在linux系统中使用, windows不支持</p></li><li class="lvl-2"><p>fopen 是标准c库函数, 一般都可以跨平台使用, 可以这样理解:</p><p>在linux中 fopen底层封装了Linux的系统API open</p><p>在window中, fopen底层封装的是 window 的 api</p></li></ul><h3 id="2-2函数参数">2.2函数参数</h3><ul class="lvl-0"><li class="lvl-2"><p><code>pathname</code>   文件路径</p></li><li class="lvl-2"><p><code>flags</code>     文件打开方式：只读，只写，读写，创建，添加等。 <code>O_RDONLY, O_WRONLY, O_RDWR，O_CREAT，O_APPEND，O_TRUNC，O_EXCL，O_NONBLOCK </code></p></li></ul><ul class="lvl-0"><li class="lvl-2"><p><code>mode参数</code>，用来指定文件的权限，数字设定法。文件权限 = mode &amp; ~umask。参数3使用的前提， 参2指定了 <code>O_CREAT</code>。 用来描述文件的访问权限。</p></li></ul><h3 id="2-3函数返回值">2.3函数返回值</h3><p>当open出错时，程序会自动设置errno，可以通过strerror(errno)来查看报错数字的含义</p><p>以打开不存在文件为例：</p><p><img src="https://img-blog.csdnimg.cn/cc3774bb155949aea31878d008bcca8d.png#pic_center" alt=""></p><p>执行该代码，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/f6e7d05af99d4f9a9b13776c9fad8841.png#pic_center" alt=""></p><h2 id="3-close-函数">3.close()函数</h2><h3 id="3-1函数原型">3.1函数原型</h3><p><code>int close(int fd)</code></p><h3 id="3-2函数参数">3.2函数参数</h3><ul class="lvl-0"><li class="lvl-2"><p>fd 表示改文件的文件描述符，open的返回值</p></li><li class="lvl-2"><p>返回值　成功为0 失败返回-1</p></li></ul><p>小案例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  fd;</span><br><span class="line">fd=open(<span class="string">&quot;tmp.txt&quot;</span>,O_RDONLY);</span><br><span class="line">close（fd）；</span><br></pre></td></tr></table></figure><h2 id="4-read-函数">4.read()函数</h2><h3 id="4-1函数原型">4.1函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><h3 id="4-2函数参数">4.2函数参数</h3><ul class="lvl-0"><li class="lvl-2"><p>fd: 文件描述符，open () 函数的返回值，通过这个参数定位打开的磁盘文件</p></li><li class="lvl-2"><p>buf: 是一个传出参数，指向一块有效的内存，用于存储从文件中读出的数据</p></li><li class="lvl-2"><p>count: buf 指针指向的内存的大小，指定可以存储的最大字节数</p></li></ul><h3 id="4-3函数返回值">4.3函数返回值</h3><ul class="lvl-0"><li class="lvl-2"><p>大于 0: 从文件中读出的字节数，读文件成功</p></li><li class="lvl-2"><p>等于 0: 代表文件读完了，读文件成功</p></li><li class="lvl-2"><p>-1: 读文件失败了,并设置 errno</p></li></ul><p><strong>如果返回-1： 并且 errno = EAGIN 或 EWOULDBLOCK, 说明不是read失败，而是read在以非阻塞方式读一个设备文件（网络文件），并且文件无数据。</strong></p><h2 id="5-write-函数">5.write()函数</h2><h3 id="5-1函数原型">5.1函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><h3 id="5-2函数参数">5.2函数参数</h3><ul class="lvl-0"><li class="lvl-2"><p>fd: 文件描述符，open () 函数的返回值，通过这个参数定位打开的磁盘文件</p></li><li class="lvl-2"><p>buf: 指向一块有效的内存地址，里边有要写入到磁盘文件中的数据</p></li><li class="lvl-2"><p>count: 要往磁盘文件中写入的字节数，一般情况下就是 buf 字符串的长度，strlen (buf)</p></li></ul><h3 id="5-3函数返回值">5.3函数返回值</h3><ul class="lvl-0"><li class="lvl-2"><p>大于 0: 成功写入到磁盘文件中的字节数</p></li><li class="lvl-2"><p>-1: 写文件失败了</p></li></ul><h2 id="6-小案例：用read-和write-函数实现copy功能">6.小案例：用read()和write()函数实现copy功能</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件的拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开存在的文件english.txt, 读这个文件</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-readfile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 打开不存在的文件, 将其创建出来, 将从english.txt读出的内容写入这个文件中</span></span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;copy.txt&quot;</span>, O_WRONLY|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-writefile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 循环读文件, 循环写文件</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( (len = read(fd1, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将读到的数据写入到另一个文件中</span></span><br><span class="line">        write(fd2, buf, len); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 关闭文件</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-系统调用和库函数比较—预读入缓输出">7.系统调用和库函数比较—预读入缓输出</h2><p>下面写两个文件拷贝函数，一个用read/write实现，一个用fputc/fgetc实现，比较他们两个之间的速度</p><p><mark>fputc/fgetc实现</mark></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp,*fp_out;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  fp = fopen(<span class="string">&quot;hello.c&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  fp_out = fopen(<span class="string">&quot;hello.cp&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(fp_out == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">while</span>((n = fgetc(fp)) != EOF)</span><br><span class="line">  &#123;</span><br><span class="line">    fputc(n, fp_out);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(fp);</span><br><span class="line">  fclose(fp_out);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>下面修改read那边的缓冲区，一次拷贝一个字符。</mark></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件的拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd1 = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-readfile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> fd2 = open(argv[<span class="number">2</span>], O_WRONLY|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-writefile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 循环读文件, 循环写文件</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( (len = read(fd1, buf, <span class="number">1</span>)) &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将读到的数据写入到另一个文件中</span></span><br><span class="line">        write(fd2, buf, len); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 关闭文件</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/cc4017b457f84fc0ac031c6606d07f3a.png#pic_center" alt=""></p><p>我猜很多人会觉得，read/write函数会比fputc/fgetc这些c语言标准库函数更快，因为read/write函数是系统调用函数，更接近linux内核。</p><p>其实不然，实际上fputc/fgetc会更快，为什么呢?下面我来分析一下</p><p><strong>原因分析：</strong></p><p>read/write，每次写一个字节，由于在用户区没缓冲区，会疯狂进行内核态和用户态的切换，所以非常耗时。</p><p>fgetc/fputc，在用户区有个缓冲区，所以它并不是一个字节一个字节地写进，内核和用户切换就比较少</p><p>所以系统函数并不是一定比库函数牛逼，能使用库函数的地方就使用库函数。</p><p>标准IO函数自带用户缓冲区，系统调用无用户级缓冲。系统缓冲区是都有的。</p><p>这就是<strong>预读入，缓输出机制</strong>。</p><p><img src="https://img-blog.csdnimg.cn/5936e1065bd24b9c870923412337b9d3.png#pic_center" alt=""></p><h2 id="8-阻塞和非阻塞">8.阻塞和非阻塞</h2><p><strong>阻塞、非阻塞： 是设备文件、网络文件的属性。</strong></p><p>产生阻塞的场景。 读设备文件。读网络文件。（读常规文件无阻塞概念。）</p><p>/dev/tty – 终端文件。</p><p>open(“/dev/tty”, O_RDWR|O_NONBLOCK)  — 设置 /dev/tty 非阻塞状态。(默认为阻塞状态)</p><blockquote><p>小案例：从标准输入读，写到标准输出</p></blockquote><p><img src="https://img-blog.csdnimg.cn/339e087f61a745d6bd1991794edfcf13.png#pic_center" alt=""></p><p>执行程序，就会发现程序在阻塞等待输入</p><p><img src="https://img-blog.csdnimg.cn/4a9c4c873fd74094a55fa1cc2b6c7612.png#pic_center" alt=""></p><p>下面是一段更改非阻塞读取终端的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TRY <span class="string">&quot;try again\n&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TIMEOUT <span class="string">&quot;time out\n&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd, n, i;  </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY | O_NONBLOCK);  </span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">        perror(<span class="string">&quot;open /dev/tty&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;open /dev/tty ok... %d\n&quot;</span>, fd);  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//轮询读取</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;  </span><br><span class="line">        n = read(fd, buf, <span class="number">10</span>);  </span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;                    <span class="comment">//说明读到了东西  </span></span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;          <span class="comment">//EWOULDBLOCK    </span></span><br><span class="line">            perror(<span class="string">&quot;read /dev/tty&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            write(STDOUT_FILENO, MSG_TRY, <span class="built_in">strlen</span>(MSG_TRY));  </span><br><span class="line">            sleep(<span class="number">2</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//超时判断</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;  </span><br><span class="line">        write(STDOUT_FILENO, MSG_TIMEOUT, <span class="built_in">strlen</span>(MSG_TIMEOUT));  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        write(STDOUT_FILENO, buf, n);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>执行，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/169bdb2eb71f42b5a26bd23fd636c2ec.png#pic_center" alt=""></p><h2 id="9-fcntl-函数">9.fcntl()函数</h2><blockquote><p>fcntl用来改变一个已经打开的文件的访问控制属性</p></blockquote><p>重点掌握两个参数的使用， <code>F_GETFL</code>，<code>F_SETFL </code></p><h3 id="9-1fcntl函数原型：">9.1fcntl函数原型：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure><h3 id="9-2函数参数">9.2函数参数:</h3><ul class="lvl-0"><li class="lvl-2"><p><code>fd</code>   文件描述符</p></li><li class="lvl-2"><p><code>cmd  命令</code>，决定了后续参数个数</p></li><li class="lvl-2"><p>获取文件状态： <code>F_GETFL</code></p></li><li class="lvl-2"><p>设置文件状态：<code> F_SETFL</code></p></li></ul><h3 id="9-3函数返回值">9.3函数返回值</h3><p><code> int flgs = fcntl(fd, F_GETFL);</code></p><p><code>flgs |= O_NONBLOCK</code></p><p><code> fcntl(fd, F_SETFL, flgs);</code></p><p><strong>一个小案例：</strong></p><p>终端文件默认是阻塞读的，这里用fcntl将其更改为非阻塞读：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TRY <span class="string">&quot;try again\n&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];  </span><br><span class="line">    <span class="type">int</span> flags, n;  </span><br><span class="line"></span><br><span class="line">    flags = fcntl(STDIN_FILENO, F_GETFL); <span class="comment">//获取stdin属性信息  </span></span><br><span class="line">    <span class="keyword">if</span>(flags == <span class="number">-1</span>)&#123;  </span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    flags |= O_NONBLOCK;  </span><br><span class="line">    <span class="type">int</span> ret = fcntl(STDIN_FILENO, F_SETFL, flags);  </span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;  </span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">tryagain:  </span><br><span class="line">    n = read(STDIN_FILENO, buf, <span class="number">10</span>);  </span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(errno != EAGAIN)&#123;          </span><br><span class="line">            perror(<span class="string">&quot;read /dev/tty&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        sleep(<span class="number">3</span>);  </span><br><span class="line">        write(STDOUT_FILENO, MSG_TRY, <span class="built_in">strlen</span>(MSG_TRY));  </span><br><span class="line">        <span class="keyword">goto</span> tryagain;  </span><br><span class="line">    &#125;  </span><br><span class="line">    write(STDOUT_FILENO, buf, n);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="10-lseek-函数">10.lseek()函数</h2><blockquote><p>系统函数 lseek 的功能是比较强大的，我们既可以通过这个函数移动文件指针，也可以通过这个函数进行文件的拓展。</p></blockquote><h3 id="10-1函数原型">10.1函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><h3 id="10-2-函数参数">10.2 函数参数</h3><ul class="lvl-0"><li class="lvl-2"><p>fd: 文件描述符，open () 函数的返回值，通过这个参数定位打开的磁盘文件</p></li><li class="lvl-2"><p>offset: 偏移量，需要和第三个参数配合使用</p></li><li class="lvl-2"><p>whence: 通过这个参数指定函数实现什么样的功能</p><ul class="lvl-2"><li class="lvl-4"><code>SEEK_SET</code>: 从文件头部开始偏移 offset 个字节</li><li class="lvl-4"><code>SEEK_CUR</code>: 从当前文件指针的位置向后偏移 offset 个字节</li><li class="lvl-4"><code>SEEK_END</code>: 从文件尾部向后偏移 offset 个字节</li></ul></li></ul><h3 id="10-3-函数返回值">10.3 函数返回值</h3><ul class="lvl-0"><li class="lvl-2"><p>成功：文件指针从头部开始计算总的偏移量</p></li><li class="lvl-2"><p>失败: -1</p></li></ul><p><strong>一个小案例：</strong></p><p>写一个句子到空白文件，完事调整光标位置，读取刚才写那个文件。</p><p>这个示例中，如果不调整光标位置，是读取不到内容的，因为读写指针在内容的末尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> fd, n;  </span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;It&#x27;s a test for lseek\n&quot;</span>;  </span><br><span class="line">    <span class="type">char</span> ch;  </span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;lseek.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0644</span>);  </span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">        perror(<span class="string">&quot;open lseek.txt error&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    write(fd, msg, <span class="built_in">strlen</span>(msg));     </span><br><span class="line">      </span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);        </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span>((n = read(fd, &amp;ch, <span class="number">1</span>)))&#123;  </span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">            perror(<span class="string">&quot;read error&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        write(STDOUT_FILENO, &amp;ch, n);   <span class="comment">//将文件内容按字节读出，写出到屏幕  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    close(fd);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong></p><p>​1. 文件的“读”、“写”使用同一偏移位置。</p><p>​2. 使用lseek获取文件大小（返回值接收）</p><p>​3. 使用lseek拓展文件大小：要想使文件大小真正拓展，必须【引起IO操作】。</p><p><mark>小案例：</mark></p><p>用lseek的偏移来读取文件大小</p><p><img src="https://img-blog.csdnimg.cn/9059d78a4e794e71b0695cc88a595fd4.png#pic_center" alt=""></p><p>用lseek实现文件拓展：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lseek.c</span></span><br><span class="line"><span class="comment">// 拓展文件大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件拓展, 一共增加了 1001 个字节</span></span><br><span class="line">    lseek(fd, <span class="number">1000</span>, SEEK_END);</span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-truncate-ftruncate-函数">11.truncate()/ftruncate()函数</h2><blockquote><p>truncate/ftruncate 这两个函数的功能是一样的，可以对文件进行拓展也可以截断文件。使用这两个函数拓展文件比使用 lseek 要简单。这两个函数的函数原型如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓展文件或截断文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line">- </span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p><strong>函数参数：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>path: 要拓展 / 截断的文件的文件名</p></li><li class="lvl-2"><p>fd: 文件描述符，open () 得到的</p></li><li class="lvl-2"><p>length: 文件的最终大小</p><ul class="lvl-2"><li class="lvl-4">文件原来 size &gt; length，文件被截断，尾部多余的部分被删除，文件最终长度为 length</li><li class="lvl-4">文件原来 size &lt; length，文件被拓展，文件最终长度为 length</li></ul></li></ul><p><strong>函数返回值</strong>：</p><p>成功返回 0; 失败返回值 - 1</p><p>truncate () 和 ftruncate () 两个函数的区别在于一个使用文件名一个使用文件描述符操作文件，功能相同。</p><p>不管是使用这两个函数还是使用 lseek () 函数拓展文件，文件尾部填充的字符都是 0。</p><p><strong>小案例：</strong></p><p>直接拓展文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = truncate(<span class="string">&quot;dict.cp&quot;</span>, <span class="number">250</span>);</span><br></pre></td></tr></table></figure><h2 id="12-目录项和inode">12.目录项和inode</h2><p><img src="https://img-blog.csdnimg.cn/1bdd32d3d345471dba5ed4da04572d9f.png#pic_center" alt=""></p><p>一个文件主要由两部分组成，dentry(目录项)和inode</p><p>inode本质是结构体，存储文件的属性信息，如：权限、类型、大小、时间、用户、盘快位置…</p><p>也叫做文件属性管理结构，大多数的inode都存储在磁盘上。</p><p>少量常用、近期使用的inode会被缓存到内存中。</p><p>所谓的删除文件，就是删除inode，但是数据其实还是在硬盘上，以后会覆盖掉。</p><h2 id="13-stat-lstate-函数">13.stat()/lstate()函数</h2><p><mark>想深入了解，请看这篇博客,下面只介绍常用的</mark></p><p><a href="https://subingwen.cn/linux/stat/">点我查看</a></p><p>用来获取文件或目录的详细属性信息包括文件系统状态，（从第二个参数结构体中获取）</p><h3 id="13-1-函数原型">13.1 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><p><mark>二者的区别:</mark></p><p><code>lstat ():</code> 得到的是软连接文件本身的属性信息<br><code>stat ():</code> 得到的是软链接文件关联的文件的属性信息(<strong>存在符号穿透</strong>)</p><h3 id="13-2-函数参数">13.2 函数参数</h3><ul class="lvl-0"><li class="lvl-2"><p><code>pathname:</code> 文件名，要获取这个文件的属性信息</p></li><li class="lvl-2"><p><code>buf: </code>传出参数，文件的信息被写入到了这块内存中</p></li></ul><blockquote><p>这个函数的第二个参数是一个结构体类型，这个结构体相对复杂，通过这个结构体可以存储得到的文件的所有属性信息，结构体原型如下:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>          st_dev;        <span class="comment">// 文件的设备编号</span></span><br><span class="line">    <span class="type">ino_t</span>           st_ino;        <span class="comment">// inode节点</span></span><br><span class="line">    <span class="type">mode_t</span>      st_mode;      <span class="comment">// 文件的类型和存取的权限, 16位整形数  -&gt; 常用</span></span><br><span class="line">    <span class="type">nlink_t</span>        st_nlink;     <span class="comment">// 连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">    <span class="type">uid_t</span>           st_uid;       <span class="comment">// 用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>           st_gid;       <span class="comment">// 组ID</span></span><br><span class="line">    <span class="type">dev_t</span>          st_rdev;      <span class="comment">// (设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">    <span class="type">off_t</span>            st_size;      <span class="comment">// 文件字节数(文件大小)   --&gt; 常用</span></span><br><span class="line">    <span class="type">blksize_t</span>     st_blksize;   <span class="comment">// 块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line">    <span class="type">blkcnt_t</span>      st_blocks;    <span class="comment">// block的块数</span></span><br><span class="line">    <span class="type">time_t</span>         st_atime;     <span class="comment">// 最后一次访问时间</span></span><br><span class="line">    <span class="type">time_t</span>         st_mtime;     <span class="comment">// 最后一次修改时间(文件内容)</span></span><br><span class="line">    <span class="type">time_t</span>         st_ctime;     <span class="comment">// 最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="13-3-各种操作">13.3 各种操作</h3><p><strong>获取文件大小</strong><br>下面调用 stat () 函数，以代码的方式演示一下如何得到某个文件的大小:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 定义结构体, 存储文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myst</span>;</span></span><br><span class="line">    <span class="comment">// 2. 获取文件属性 english.txt</span></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;./english.txt&quot;</span>, &amp;myst);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件大小: %d\n&quot;</span>, (<span class="type">int</span>)myst.st_size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取文件类型</strong><br>文件的类型信息存储在 struct stat 结构体的 st_mode 成员中，它是一个 mode_t 类型，本质上是一个 16 位的整数。Linux API 中为我们提供了相关的宏函数，通过对应的宏函数可以直接判断出文件是不是某种类型，这些信息都可以通过 man 文档（man 2 stat）查询到。</p><p>相关的宏函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型是存储在结构体的这个成员中: mode_t  st_mode;  </span></span><br><span class="line"><span class="comment">// 这些宏函数中的m 对应的就是结构体成员  st_mode</span></span><br><span class="line"><span class="comment">// 宏函数返回值: 是对应的类型返回-&gt; 1, 不是对应类型返回0</span></span><br><span class="line"></span><br><span class="line">S_ISREG(m)  is it a regular file?  </span><br><span class="line">- 普通文件</span><br><span class="line">S_ISDIR(m)  directory?</span><br><span class="line">- 目录</span><br><span class="line">S_ISCHR(m)  character device?</span><br><span class="line">- 字符设备</span><br><span class="line">S_ISBLK(m)  block device?</span><br><span class="line">- 块设备</span><br><span class="line">S_ISFIFO(m) FIFO (named pipe)?</span><br><span class="line">- 管道</span><br><span class="line">S_ISLNK(m)  symbolic link?  (Not in POSIX<span class="number">.1</span><span class="number">-1996.</span>)</span><br><span class="line">- 软连接</span><br><span class="line">S_ISSOCK(m) socket?  (Not in POSIX<span class="number">.1</span><span class="number">-1996.</span>)</span><br><span class="line">    - 本地套接字文件</span><br></pre></td></tr></table></figure><p>在程序中通过宏函数判断文件类型，实例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 定义结构体, 存储文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myst</span>;</span></span><br><span class="line">    <span class="comment">// 2. 获取文件属性 english.txt</span></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;./hello&quot;</span>, &amp;myst);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件大小: %d\n&quot;</span>, (<span class="type">int</span>)myst.st_size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断文件类型</span></span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个普通文件...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个目录...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISLNK(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个软连接文件...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-目录操作函数">13.目录操作函数</h2><h3 id="13-1opendir-函数">13.1opendir()函数</h3><blockquote><p>在目录操作之前必须要先通过 opendir () 函数打开这个目录，函数原型如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="comment">// 打开目录</span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数: name -&gt; 要打开的目录的名字</p></li><li class="lvl-2"><p>返回值: DIR*, 结构体类型指针。打开成功返回目录的实例，打开失败返回 NULL</p></li></ul><h3 id="13-2readdir-函数">13.2readdir()函数</h3><blockquote><p>目录打开之后，就可以通过 readdir () 函数遍历目录中的文件信息了。每调用一次这个函数就可以得到目录中的一个文件信息，当目录中的文件信息被全部遍历完毕会得到一个空对象。先来看一下这个函数原型：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数：dirp -&gt; opendir () 函数的返回值</p></li><li class="lvl-2"><p>返回值：函数调用成功，返回读到的文件的信息，目录文件被读完了或者函数调用失败返回 NULL</p></li><li class="lvl-2"><p>函数返回值 struct dirent 结构体原型如下:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="type">ino_t</span>          d_ino;       <span class="comment">/* 文件对应的inode编号, 定位文件存储在磁盘的那个数据块上 */</span></span><br><span class="line">    <span class="type">off_t</span>          d_off;       <span class="comment">/* 文件在当前目录中的偏移量 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* 文件名字的实际长度 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* 文件的类型, linux中有7中文件类型 */</span></span><br><span class="line">    <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* 文件的名字 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于结构体中的文件类型 <code>d_type</code>，可使用的宏值如下</p><p><code>DT_BLK</code>：块设备文件<code>DT_CHR</code>：字符设备文件<code>DT_DIR</code>：目录文件<br><code>DT_FIFO</code> ：管道文件<code>DT_LNK</code>：软连接文件<code>DT_REG </code>：普通文件<code>DT_SOCK</code>：本地套接字文件<code>DT_UNKNOWN</code>：无法识别的文件类型</p><p>通过 readdir () 函数遍历某一个目录中的文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开目录</span></span><br><span class="line">DIR* dir = opendir(<span class="string">&quot;/home/test&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 遍历目录</span></span><br><span class="line"><span class="keyword">while</span>( (ptr=readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-3closedir-函数">13.3closedir()函数</h3><blockquote><p>目录操作完毕之后，需要通过 closedir() 关闭通过 opendir() 得到的实例，释放资源。函数原型如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭目录, 参数是 opendir() 的返回值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>参数：dirp-&gt; opendir () 函数的返回值</p></li><li class="lvl-2"><p>返回值：目录关闭成功返回 0, 失败返回 -1</p></li></ul><h2 id="14-文件描述符复制和重定向-dup-dup2-命令">14.文件描述符复制和重定向(dup(),dup2()命令)</h2><p><mark>请看这篇博客，写的很好</mark></p><p><a href="https://subingwen.cn/linux/fcntl-dup2/">点我查看</a></p><h2 id="15-文件描述符">15.文件描述符</h2><p><img src="https://img-blog.csdnimg.cn/b1d28fb9eeba498596caada0683f47c0.png#pic_center" alt=""></p><p>如上图所示，是我们的虚拟地址空间，其中0-3G为用户区，3-4G为内核区，其中我们的PCB进程控制块就在内核区，它的本质是一个结构体，在这个结构体中有一个成员变量 file_struct *file 指向文件描述符表。 从应用程序使用角度，该指针可理解记忆成一个字符指针数组，下标 0/1/2/3/4…找到文件结构体。本质是一个键值对 0、1、2…都分别对应具体地址。但键值对使用的特性是自动映射，我们只操作键不直接使用值。 新打开文件返回文件描述符表中未使用的最小文件描述符。<br><code>STDIN_FILENO</code>   0标准输入 （键盘）<br><code>STDOUT_FILENO</code> 1标准输出（显示器）<br><code>STDERR_FILENO </code> 2标准错误</p><p><strong>一个进程默认打开文件的个数 1024。</strong></p><h2 id="16-写在最后">16.写在最后</h2><blockquote><p>本文章是我在b站跟着黑马Linux系统编程学习时的笔记，为了防止遗忘和以后复习，写下这篇笔记，如有错误，欢迎指出</p></blockquote><p>笔记中有的地方我是参考了这个博主的博客内容，这个博主的文章质量真的很高，这是它的博客<a href="https://subingwen.cn/linux/">点我查看</a>，这是他的b站账号，有很多优质视频，强烈推荐<a href="https://space.bilibili.com/147020887/?spm_id_from=333.999.0.0">点我查看</a></p><p><mark>黑马Linux系统编程视频链接</mark></p><p><a href="https://www.bilibili.com/video/BV1KE411q7ee?spm_id_from=333.999.list.card_archive.click&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">点我查看</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统编程 </tag>
            
            <tag> 文件IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Json详解</title>
      <link href="/posts/18760bb5.html"/>
      <url>/posts/18760bb5.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://subingwen.cn/qt/json/">原文链接</a><br>JSON(JavaScrip Object Notation) 是一种<mark>轻量级的数据交换格式</mark>。它基于 ECMAScript (欧洲计算机协会制定的 js 规范) 的一个子集，<mark>采用完全独立于编程语言的文本格式来存储和表示数据</mark>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>关于上面的描述可以精简为一句话：<mark>Json 是一种数据格式，和语言无关，在什么语言中都可以使用 Json</mark>。基于这种通用的数据格式，一般处理两方面的任务：</p><p>组织数据（数据序列化），用于数据的网络传输组织数据（数据序列化），写磁盘文件实现数据的持久化存储(一般以 <mark>.json</mark> 作为文件后缀)<br>Json 中主要有两种数据格式：Json 数组和 Json 对象，并且这两种格式可以交叉嵌套使用，下面依次介绍下这两种数据格式：</p><h2 id="1-Json-数组">1.Json 数组</h2><p>Json 数组使用 [] 表示，[] 里边是元素，元素和元素之间使用逗号间隔，<mark>最后一个元素后边没有逗号</mark>，一个 Json 数组中支持同时存在多种不同类型的成员，包括：<mark>整形</mark>、<mark>浮点</mark>、 <mark>字符串</mark>、 <mark>布尔类型</mark>、 <mark>json数组</mark>、 <mark>json对象</mark>、 <mark>空值-null</mark>。由此可见 Json 数组比起 C/C++ 数组要灵活很多。</p><blockquote><p>Json 数组中的元素数据类型一致</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整形</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;luffy&quot;</span><span class="punctuation">,</span> <span class="string">&quot;sanji&quot;</span><span class="punctuation">,</span> <span class="string">&quot;zoro&quot;</span><span class="punctuation">,</span> <span class="string">&quot;nami&quot;</span><span class="punctuation">,</span> <span class="string">&quot;robin&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><blockquote><p>Json 数组中的元素数据类型不一致</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="number">12</span><span class="punctuation">,</span> <span class="number">13.34</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="string">&quot;hello,world&quot;</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><blockquote><p>Json 数组中的数组嵌套使用</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;cat&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dog&quot;</span><span class="punctuation">,</span> <span class="string">&quot;panda&quot;</span><span class="punctuation">,</span> <span class="string">&quot;beer&quot;</span><span class="punctuation">,</span> <span class="string">&quot;rabbit&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;北京&quot;</span><span class="punctuation">,</span> <span class="string">&quot;上海&quot;</span><span class="punctuation">,</span> <span class="string">&quot;天津&quot;</span><span class="punctuation">,</span> <span class="string">&quot;重庆&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;luffy&quot;</span><span class="punctuation">,</span> <span class="string">&quot;boy&quot;</span><span class="punctuation">,</span> <span class="number">19</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><blockquote><p>Json 数组和对象嵌套使用</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;luffy&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">19</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;father&quot;</span><span class="punctuation">:</span><span class="string">&quot;Monkey·D·Dragon&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;grandpa&quot;</span><span class="punctuation">:</span><span class="string">&quot;Monkey D Garp&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brother1&quot;</span><span class="punctuation">:</span><span class="string">&quot;Portgas D Ace&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brother2&quot;</span><span class="punctuation">:</span><span class="string">&quot;Sabo&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="2-Json-对象">2.Json 对象</h2><p>Json 对象使用 {} 来描述，每个 Json 对象中可以存储若干个元素，每一个元素对应一个键值对（key：value 结构），元素和元素之间使用逗号间隔，最后一个元素后边没有逗号。对于每个元素中的键值对有以下细节需要注意：</p><p>1.键值（key）必须是字符串，位于同一层级的键值不要重复（因为是通过键值取出对应的 value 值）<br>2.value 值的类型是可选的，可根据实际需求指定，可用类型包括：<mark>整形</mark>、 <mark>浮点</mark>、 <mark>字符串</mark>、 <mark>布尔类型</mark>、<mark>json数组</mark>、 <mark>json对象</mark>、 <mark>空值-null</mark>。<br><strong>使用 Json 对象描述一个人的信息:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Name&quot;:&quot;Ace&quot;,</span><br><span class="line">    &quot;Sex&quot;:&quot;man&quot;,</span><br><span class="line">    &quot;Age&quot;:20,</span><br><span class="line">    &quot;Family&quot;:&#123;</span><br><span class="line">        &quot;Father&quot;:&quot;Gol·D·Roger&quot;,</span><br><span class="line">        &quot;Mother&quot;:&quot;Portgas·D·Rouge&quot;,</span><br><span class="line">        &quot;Brother&quot;:[&quot;Sabo&quot;, &quot;Monkey D. Luffy&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IsAlive&quot;:false,</span><br><span class="line">    &quot;Comment&quot;:&quot;yyds&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注意事项">3.注意事项</h2><p>通过上面的介绍可用看到，Json 的结构虽然简单，但是进行嵌套之后就可以描述很复杂的事情，在项目开发过程中往往需要我们根据实际需求自己定义 Json 格式用来存储项目数据。</p><p>另外，如果需要将 Json 数据持久化到磁盘文件中，需要注意一个问题：<mark>在一个 Json 文件中只能有一个 Json 数组或者 Json 对象的根节点，不允许同时存储多个并列的根节点</mark>。下面举例说明：</p><blockquote><p>错误的写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// test.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;luffy&quot;,</span><br><span class="line">    &quot;age&quot;:19</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot;:&quot;ace&quot;,</span><br><span class="line">    &quot;passwd&quot;:&quot;123456&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误原因：<mark>在一个 Json 文件中有两个并列的 Json 根节点（并列包含 Json 对象和 Json 对象、Json 对象和 Json 数组、Json 数组和 Json 数组），根节点只能有一个。</mark></p><blockquote><p>正确的写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// test.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Name&quot;:&quot;Ace&quot;,</span><br><span class="line">    &quot;Sex&quot;:&quot;man&quot;,</span><br><span class="line">    &quot;Age&quot;:20,</span><br><span class="line">    &quot;Family&quot;:&#123;</span><br><span class="line">        &quot;Father&quot;:&quot;Gol·D·Roger&quot;,</span><br><span class="line">        &quot;Mother&quot;:&quot;Portgas·D·Rouge&quot;,</span><br><span class="line">        &quot;Brother&quot;:[&quot;Sabo&quot;, &quot;Monkey D. Luffy&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IsAlive&quot;:false,</span><br><span class="line">    &quot;Comment&quot;:&quot;yyds&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>在上面的例子中通过Json对象以及Json数组的嵌套描述了一个人的身份信息，并且根节点只有一个就是Json对象，如果还需要使用Json数组或者Json对象描述其他信息，需要将这些信息写入到其他文件中，不要和这个Json对象并列写入到同一个文件里边，切记！！！</mark></p>]]></content>
      
      
      <categories>
          
          <category> Json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++命名空间详解</title>
      <link href="/posts/553a97ec.html"/>
      <url>/posts/553a97ec.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-作用域运算符">1. ::作用域运算符</h2><p>通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//全局a被隐藏</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是a:20。在test函数的输出语句中，使用的变量a是test函数内定义的局部变量，因此输出的结果为局部变量a的值。</p><p>作用域运算符可以用来解决局部变量与全局变量的重名问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//1. 局部变量和全局变量同名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//打印局部变量a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">//打印全局变量a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量a:&quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子可以看出，作用域运算符可以用来解决局部变量与全局变量的重名问题，即在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。</p><h2 id="2-C-命名空间-namespace">2.  C++命名空间(namespace)</h2><p>在c++ 中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等。工程越大，名称互相冲突性的可能性越大。另外使用多个厂商的类库时，也可能导致名称冲突。为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++ 库时，这些标识符的命名发生冲突，标准C++ 引入关键字namespace（命名空间/名字空间/名称空间），可以更好地控制标识符的作用域。</p><h3 id="2-1命名空间使用语法">2.1命名空间使用语法</h3><p><mark>创建一个命名空间:</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>命名空间只能全局范围内定义（<strong>以下错误写法</strong>）</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>命名空间可嵌套命名空间</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::B::a : &quot;</span> &lt;&lt; A::B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>命名空间是开放的，即可以随时把新的成员加入已有的命名空间中</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello namespace!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">A::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>声明和实现可分离</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MySpace&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MySpace::func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func2</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MySpace::func2 : &quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><mark>无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; a &lt;&lt; endl;<span class="comment">//直接访问就行，可以看成静态变量</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>命名空间别名</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> veryLongName&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> shortName = veryLongName;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;veryLongName::a : &quot;</span> &lt;&lt; shortName::a &lt;&lt; endl;</span><br><span class="line">veryLongName::<span class="built_in">func</span>();</span><br><span class="line">shortName::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-using声明">2.2 using声明</h3><p>using声明可使得指定的标识符可用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">  <span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1. 通过命名空间域运算符</span></span><br><span class="line">cout &lt;&lt; A::paramA &lt;&lt; endl;</span><br><span class="line">A::<span class="built_in">funcA</span>();</span><br><span class="line"><span class="comment">//2. using声明</span></span><br><span class="line"><span class="keyword">using</span> A::paramA;</span><br><span class="line"><span class="keyword">using</span> A::funcA;</span><br><span class="line">cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; paramB &lt;&lt; endl; //不可直接访问</span></span><br><span class="line"><span class="built_in">funcA</span>();</span><br><span class="line"><span class="comment">//3. 同名冲突,using声明和就近原则不要同时出现</span></span><br><span class="line"><span class="comment">//int paramA = 20; //相同作用域注意同名冲突</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>using声明碰到函数重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> A::func;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。</p><h3 id="2-3-using编译指令">2.3 using编译指令</h3><p>using编译指令使整个命名空间标识符可用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcB&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; paramB &lt;&lt; endl;</span><br><span class="line"><span class="built_in">funcA</span>();</span><br><span class="line"><span class="built_in">funcB</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//不会产生二义性，using编译指令和就近原则同时出现，优先使用就近原则</span></span><br><span class="line"><span class="type">int</span> paramA = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcB&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line"><span class="comment">//二义性产生，不知道调用A还是B的paramA</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; paramA &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：使用using声明或using编译指令会增加命名冲突的可能性。也就是说，如果有名称空间，并在代码中使用作用域解析运算符，则不会出现二义性</strong></p></blockquote><h3 id="2-4-命名空间使用">2.4 命名空间使用</h3><p>我们刚讲的一些东西一开始会觉得难一些，这些东西以后还是挺常用，只要理解了它们的工作机理，使用它们非常简单。</p><p>需要记住的关键问题是当引入一个全局的using编译指令时，就为该文件打开了该命名空间，它不会影响任何其他的文件，所以可以在每一个实现文件中调整对命名空间的控制。比如，如果发现某一个实现文件中有太多的using指令而产生的命名冲突，就要对该文件做个简单的改变，通过明确的限定或者using声明来消除名字冲突，这样不需要修改其他的实现文件。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类型转换详解</title>
      <link href="/posts/3665bf7d.html"/>
      <url>/posts/3665bf7d.html</url>
      
        <content type="html"><![CDATA[<p>类型转换(cast)是将一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。</p><p>转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的数据。</p><p>应该小心类型转换，因为转换也就相当于对编译器说：忘记类型检查，把它看做其他的类型。</p><blockquote><p>一般情况下，尽量少的去使用类型转换，除非用来解决非常特殊的问题。 无论什么原因，任何一个程序如果使用很多类型转换都值得怀疑.</p></blockquote><p>标准c++提供了一个显示的转换的语法，来替代旧的C风格的类型转换。</p><p>使用C风格的强制转换可以把想要的任何东西转换成我们需要的类型。那为什么还需要一个新的C++类型的强制转换呢？</p><p>新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。</p><h2 id="1-静态转换-static-cast">1. 静态转换(static_cast)</h2><p>用于<a href="http://baike.baidu.com/view/2405425.htm">类层次结构</a>中基类（父类）和<a href="http://baike.baidu.com/view/535532.htm">派生类</a>（子类）之间指针或引用的转换。</p><p>进行向上转换（把派生类的指针或引用转换成基类表示）是安全的；</p><p>进行向下转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</p><p>用于基本数据类型之间的转换，如把int转换成char，把char转换成int。这种转换的安全性也要开发人员来保证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;&#125;;</span><br><span class="line">class Dog : public Animal&#123;&#125;;</span><br><span class="line">class Other&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//基础数据类型转换</span><br><span class="line">void test01()&#123;</span><br><span class="line">char a = &#x27;a&#x27;;</span><br><span class="line">double b = static_cast&lt;double&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承关系指针互相转换</span><br><span class="line">void test02()&#123;</span><br><span class="line">//继承关系指针转换</span><br><span class="line">Animal* animal01 = NULL;</span><br><span class="line">Dog* dog01 = NULL;</span><br><span class="line">//子类指针转成父类指针,安全</span><br><span class="line">Animal* animal02 = static_cast&lt;Animal*&gt;(dog01);</span><br><span class="line">//父类指针转成子类指针，不安全</span><br><span class="line">Dog* dog02 = static_cast&lt;Dog*&gt;(animal01);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承关系引用相互转换</span><br><span class="line">void test03()&#123;</span><br><span class="line"></span><br><span class="line">Animal ani_ref;</span><br><span class="line">Dog dog_ref;</span><br><span class="line">//继承关系指针转换</span><br><span class="line">Animal&amp; animal01 = ani_ref;</span><br><span class="line">Dog&amp; dog01 = dog_ref;</span><br><span class="line">//子类指针转成父类指针,安全</span><br><span class="line">Animal&amp; animal02 = static_cast&lt;Animal&amp;&gt;(dog01);</span><br><span class="line">//父类指针转成子类指针，不安全</span><br><span class="line">Dog&amp; dog02 = static_cast&lt;Dog&amp;&gt;(animal01);</span><br><span class="line">&#125;</span><br><span class="line">//无继承关系指针转换</span><br><span class="line">void test04()&#123;</span><br><span class="line"></span><br><span class="line">Animal* animal01 = NULL;</span><br><span class="line">Other* other01 = NULL;</span><br><span class="line"></span><br><span class="line">//转换失败</span><br><span class="line">//Animal* animal02 = static_cast&lt;Animal*&gt;(other01);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-动态转换-dynamic-cast">2. 动态转换(dynamic_cast)</h2><p>dynamic_cast主要用于类层次间的向上转换和向下转换；</p><p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；</p><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowName</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I am a dog!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是其他类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不支持基础数据类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//double a = dynamic_cast&lt;double&gt;(a);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承关系指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Dog* dog01 = <span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类指针转换成父类指针 可以</span></span><br><span class="line">Animal* animal02 = <span class="built_in">dynamic_cast</span>&lt;Animal*&gt;(dog01);</span><br><span class="line">animal02-&gt;<span class="built_in">ShowName</span>();</span><br><span class="line"><span class="comment">//父类指针转换成子类指针 不可以</span></span><br><span class="line"><span class="comment">//Dog* dog02 = dynamic_cast&lt;Dog*&gt;(animal01);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承关系引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Dog dog_ref;</span><br><span class="line">Dog&amp; dog01 = dog_ref;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类引用转换成父类引用 可以</span></span><br><span class="line">Animal&amp; animal02 = <span class="built_in">dynamic_cast</span>&lt;Animal&amp;&gt;(dog01);</span><br><span class="line">animal02.<span class="built_in">ShowName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无继承关系指针转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Other* other = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可以</span></span><br><span class="line"><span class="comment">//Animal* animal02 = dynamic_cast&lt;Animal*&gt;(other);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-常量转换-const-cast">3. 常量转换(const_cast)</h2><p>该运算符用来修改类型的const属性。</p><p>常量指针被转化成非常量指针，并且仍然指向原来的对象；</p><p>常量引用被转换成非常量引用，并且仍然指向原来的对象；</p><p><strong>注意:</strong> 不能直接对非指针和非引用的变量使用const_cast操作符去直接移除它的const.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量指针转换成非常量指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>* np = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* pp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* npp = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(pp);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">//不能对非指针或非引用进行转换</span></span><br><span class="line"><span class="comment">//int b = const_cast&lt;int&gt;(a); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量引用转换成非常量引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp; refNum = num;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; refNum2 = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>&amp;&gt;(refNum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3-重新解释转换-reinterpret-cast-不建议使用">2.3 重新解释转换(reinterpret_cast)(不建议使用)</h2><p>这是最不安全的一种转换机制，最有可能出问题。</p><p>主要用于将一种数据类型从一种类型转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针.</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb详解</title>
      <link href="/posts/ff8b855b.html"/>
      <url>/posts/ff8b855b.html</url>
      
        <content type="html"><![CDATA[<h1>一、调试前的准备</h1><p>用gcc编译源程序的时候，编译后的可执行文件不会包含源程序代码，如果您打算编译后的程序可以被调试，编译的时候要加-g的参数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o book113 book113.c</span><br></pre></td></tr></table></figure><p>在命令提示符下输入gdb book113就可以调试book113程序了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb book113</span><br></pre></td></tr></table></figure><h1>二、基本调试命令</h1><table><thead><tr><th><strong>命令</strong></th><th><strong>命令</strong>缩写</th><th>命令说明</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>列出源码，根据源码指定行号，设置断点</td></tr><tr><td>set args</td><td></td><td>设置主程序的参数。例如：./book119 /oracle/c/book1.c /tmp/book1.c设置参数的方法是：gdb book119(gdb) set args /oracle/c/book1.c /tmp/book1.c</td></tr><tr><td>break</td><td>b</td><td>设置断点，b 20 表示在第20行设置断点，可以设置多个断点。</td></tr><tr><td>run</td><td>r</td><td>开始运行程序, 程序运行到断点的位置会停下来，如果没有遇到断点，程序一直运行下去。</td></tr><tr><td>next</td><td>n</td><td>执行当前行语句，如果该语句为函数调用，不会进入函数内部执行。</td></tr><tr><td>step</td><td>s</td><td>执行当前行语句，如果该语句为函数调用，则进入函数执行其中的第一条语句。注意了，如果函数是库函数或第三方提供的函数，用s也是进不去的，因为没有源代码，如果是您自定义的函数，只要有源码就可以进去。</td></tr><tr><td>print</td><td>p</td><td>显示变量值，例如：p name表示显示变量name的值。</td></tr><tr><td>continue</td><td>c</td><td>继续程序的运行，直到遇到下一个断点。</td></tr><tr><td>set var name=value</td><td></td><td>设置变量的值，假设程序有两个变量：int ii; char name[21];set var ii=10 把ii的值设置为10；set var name=“fsda” 把name的值设置为&quot;fsda&quot;，注意，不是strcpy。</td></tr><tr><td>finish</td><td></td><td>结束当前函数调用，返回到函数调用点</td></tr><tr><td>info b</td><td></td><td>info b 查看设置的断点信息</td></tr><tr><td>ptype</td><td></td><td>查看变量类型 例如：ptype name表示查看变量name的类型</td></tr><tr><td>bt</td><td></td><td>列出当前程序存活者的栈帧</td></tr><tr><td>frame</td><td></td><td>根据栈帧编号,替换栈帧</td></tr><tr><td>(un)display</td><td></td><td>设置跟踪变量</td></tr><tr><td>quit</td><td>q</td><td>退出gdb环境。</td></tr></tbody></table><p>注意，在gdb环境中，可以用上下光标键选择执行过的gdb命令。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim/Vi常用命令总结</title>
      <link href="/posts/f8adb3e0.html"/>
      <url>/posts/f8adb3e0.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、是什么">一、是什么</h2><p>VI 是Unix操作系统和类Unix操作系统中最通用的文本编辑器。</p><p>VIM编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM与VI 编辑器完全兼容。</p><h2 id="二、创建-打开文件">二、创建/打开文件</h2><p>vim 文件名</p><p>打开一个文件，如果文件不存在，将会自动创建它。</p><p>示例：</p><p>vim book.c</p><h2 id="三、vim的三种模式">三、vim的三种模式</h2><p>vim 有三种模式，命令行模式、插入模式和替换模式，在命令行模式下，任何键盘输入都是命令，在插入模式和替换模式下，键盘输入的才是字符。</p><p>插入模式和替换模式也合称为编辑模式。</p><p><img src="https://bu.dusays.com/2022/12/31/63b00cb58dcdb.png" alt="p1.png"></p><h2 id="四、vim的常用命令">四、vim的常用命令</h2><p>Esc    从编辑模式切换到命令行模式。</p><p>i   在光标所在位置前面开始插入。</p><p>a   在光标所在的位置后面开始插入。</p><p>o  在光标所在位置行的下面插入空白行。</p><p>O  在光标所在位置行的上面插入空白行。</p><p>I   在光标所在位置行的行首开始插入。</p><p>A  在光标所在位置行的行末开始插入。</p><p>k   类似方向键上。</p><p>j   类似方向键下。</p><p>h  类似方向键左。</p><p>l   类是方向键右。</p><p>Ctrl+u  向上翻半页。</p><p>Ctrl+d  向下翻页。</p><p>Ctrl+g    显示光标所在位置的行号和文件的总行数。</p><p>nG 光标跳到文件的第n行行首。</p><p>G  光标跳到文件最后一行。</p><p>:5回车  光标跳到第5行。</p><p>:n回车  光标跳到第n行。</p><p>:set nu 设置行号</p><p>:set nonu 关闭行号</p><p>0   光标跳到当前行的行首。</p><p>$   光标跳到当前行的行尾。</p><p>Ctrl+Home 光标跳到整篇文章开头</p><p>Ctrl+End 光标跳到整篇文章结尾</p><p>w   光标跳到下个单词的开头。</p><p>b   光标跳到上个单词的开头。</p><p>e  光标跳到本单词的尾部。</p><p>x    每按一次，删除光标所在位置的一个字符。</p><p>nx  如&quot;3x&quot;表示删除光标所在位置开始的3个字符。</p><p>dw 删除光标所在位置到本单词结尾的字符。</p><p>D  删除本行光标所在位置后面全部的内容。</p><p>dd  删除光标所在位置的一行。</p><p>ndd 如&quot;3dd&quot;表示删除光标所在位置开始的3行。</p><p>yy  将光标所在位置的一行复制到缓冲区。</p><p>nyy 将光标所在位置的n行复制到缓冲区。</p><p>p   将缓冲区里的内容粘贴到光标所在位置。</p><p>r   替换光标所在位置的一个字符 replace。</p><p>R  从光标所在位置开始替换，直到按下&quot;Esc&quot;。</p><p>cw 从光标所在位置开始替换单词，直到按下&quot;Esc&quot;。</p><p>u  撤销命令，可多次撤销。</p><p>J  把当前行的下一行接到当前行的尾部。</p><p>/abcd  在当前打开的文件中查找“abcd”文本内容。</p><p>n   查找下一个。</p><p>N   查找上一下。</p><p>.  重复执行上一次执行的vi命令。</p><p>~  对光标当前所在的位置的字符进行大小写转换。</p><p>列操作</p><p>Ctrl+V  光标上或下  大写的I  输入内容  Esc</p><p>:w回车  存盘。</p><p>:w!回车  强制存盘。</p><p>:wq回车 存盘退出。</p><p>:x回车  存盘退出。</p><p>:q回车 不存盘退出。</p><p>:q!回车  不存盘强制退出。</p><p>:g/aaaaaaaaa/s//bbbbbb/g回车  把文件中全部的aaaaaaaaa替换成bbbbbb。</p><p>Ctl+insert  复制鼠标选中的文本，相当于Ctl+c。</p><p>Shift+insert 输出鼠标选中的文本，相当于Ctl+v。</p><p>以上两个命令在windows和UNIX中是通用的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim/Vi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas详解</title>
      <link href="/posts/a8ad0e8e.html"/>
      <url>/posts/a8ad0e8e.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1hx411d7jb?spm_id_from=333.337.search-card.all.click&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><h2 id="1-pandas的常用数据类型">1.pandas的常用数据类型</h2><p>1.Series 一维，带标签数组</p><p>2.DataFrame 二维，Series容器</p><h2 id="2-pandas之Series创建">2.pandas之Series创建</h2><p><img src="https://img-blog.csdnimg.cn/bb43d34acca640a49f6235918cdc9d91.png#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/234e646df7ca4617a62cb02967d66d7d.png#pic_center" alt="图片2"></p><h2 id="3-pandas之Series切片和索引">3.pandas之Series切片和索引</h2><p><img src="https://img-blog.csdnimg.cn/a317d112aac84680ba7668555d2d12a5.png#pic_center" alt="图片3"></p><h2 id="4-pandas之Series的索引和值">4.pandas之Series的索引和值</h2><p><img src="https://img-blog.csdnimg.cn/eb431cfe4c154698ad432933016f986d.png#pic_center" alt="图片4"></p><h2 id="5-pandas之读取外部数据">5.pandas之读取外部数据</h2><p>我们的这组数据存在csv中，我们直接使用pd. read_csv即可</p><p>和我们想象的有些差别，我们以为他会是一个Series类型，但是他是一个DataFrame，那么接下来我们就来了解这种数据类型</p><p><mark>小示例：</mark></p><p>现在假设我们有一个组关于狗的名字的统计数据，那么为了观察这组数据的情况，我们应该怎么做呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">df = pd.read_csv(&#x27;./dogNames2.csv&#x27;)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://img-blog.csdnimg.cn/68be90dd4ba5438998639c7eec18efe3.png#pic_center" alt="图片5"></p><h2 id="6-pandas之DataFrame">6.pandas之DataFrame</h2><p><img src="https://img-blog.csdnimg.cn/be5b901ba4fb47cea1bd2ec48f9ae57e.png#pic_center" alt="图片6"></p><p><strong>DataFrame对象既有行索引，又有列索引</strong></p><p>行索引，表明不同行，横向索引，叫index，0轴，axis=0</p><p>列索引，表名不同列，纵向索引，叫columns，1轴，axis=1</p><p><img src="https://img-blog.csdnimg.cn/9ca03dc5756543d0b8912fdf772ef66a.png#pic_center" alt="图片7"></p><p><img src="https://img-blog.csdnimg.cn/52b5430936d04a96b1506fe210c93b5b.png#pic_center" alt="图片8"></p><p>那么回到之前我们读取的狗名字统计的数据上，我们尝试一下刚刚的方法</p><p>那么问题来了：</p><p>很多同学肯定想知道使用次数最高的前几个名字是什么呢？</p><p><code>df.sort_values(by=&quot;Count_AnimalName&quot;,ascending=*False*)</code></p><p><mark>dataframe排序</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">df = pd.read_csv(&#x27;./dogNames2.csv&#x27;)</span><br><span class="line"># print(df)</span><br><span class="line"># print(&#x27;*&#x27;*100)</span><br><span class="line"># print(df.head())</span><br><span class="line"># print(&#x27;*&#x27;*100)</span><br><span class="line"># print(df.info())</span><br><span class="line"># print(&#x27;*&#x27;*100)</span><br><span class="line"># print(df.describe())</span><br><span class="line"></span><br><span class="line"># 以Count_AnimalName来排序（默认升序）</span><br><span class="line"># df = df.sort_values(by=&#x27;Count_AnimalName&#x27;)</span><br><span class="line"># ascending=True 为升序，False为倒序</span><br><span class="line">df = df.sort_values(by=&#x27;Count_AnimalName&#x27;,ascending=False)</span><br><span class="line">print(df.head(10))</span><br></pre></td></tr></table></figure><h2 id="7-pandas之取行或者列">7.pandas之取行或者列</h2><p>刚刚我们知道了如何给数据按照某一行或者列排序，那么现在我们想单独研究使用次数前100的数据，应该如何做？</p><p><code>df_sorted = df.sort_values(by=&quot;Count_AnimalName&quot;)</code></p><p><code>df_sorted[:100]</code></p><p>那么问题来了：</p><p>我们具体要选择某一列该怎么选择呢？<code>df[&quot; Count_AnimalName &quot;]</code></p><p>我们要同时选择行和列改怎么办？<code>df[:100][&quot; Count_AnimalName &quot;]</code></p><h2 id="8-pandas之loc">8.pandas之loc</h2><p>还有更多的经过pandas优化过的选择方式：</p><p>1.df.loc 通过<strong>标签</strong>索引行数据</p><p>2.df.iloc 通过<strong>位置</strong>获取行数据</p><p><img src="https://img-blog.csdnimg.cn/4b62f336e82e420dac4b8bd321307195.png#pic_center" alt="图片9"></p><p><img src="https://img-blog.csdnimg.cn/9110f21838ff4e9d8834322a3ae3730b.png#pic_center" alt="图片10"></p><h2 id="9-pandas之布尔索引">9.pandas之布尔索引</h2><p>回到之前狗的名字的问题上，假如我们想找到所有的使用次数超过800的狗的名字，应该怎么选择？</p><p><img src="https://img-blog.csdnimg.cn/41bbcc62c40c42ed9f26ec43fd426cf9.png#pic_center" alt="图片11"></p><p>回到之前狗的名字的问题上，假如我们想找到所有的使用次数超过700并且名字的字符串的长度大于4的狗的名字，应该怎么选择？</p><p><img src="https://img-blog.csdnimg.cn/e9560f381945448db72ee3e53ed7c2b6.png#pic_center" alt="图片12"></p><h2 id="10-pandas之字符串方法">10.pandas之字符串方法</h2><p><img src="https://img-blog.csdnimg.cn/4c472eb7157b44a19c24e1e0d4dd2670.png#pic_center" alt="图片13"></p><h2 id="11-缺失数据的处理">11.缺失数据的处理</h2><p>观察下面这组数据</p><p><img src="https://img-blog.csdnimg.cn/e5e6a7182e0c45a9ac32234186f9d287.png#pic_center" alt="图片14"></p><p>我们的数据缺失通常有两种情况：</p><p>一种就是空，None等，在pandas是NaN(和np.nan一样)另一种是我们让其为0，蓝色框中</p><p>对于NaN的数据，在numpy中我们是如何处理的？</p><p>在pandas中我们处理起来非常容易</p><p>判断数据是否为NaN：<code>pd.isnull(df),pd.notnull(df)</code></p><p>处理方式1：删除NaN所在的行列<code>dropna (axis=0, how='any', inplace=False)</code></p><p>处理方式2：填充数据，<code>t.fillna(t.mean()),t.fiallna(t.median()),t.fillna(0)</code></p><p>处理为0的数据：<code>t[t==0]=np.nan</code></p><p>当然并不是每次为0的数据都需要处理</p><p>计算平均值等情况，nan是不参与计算的，但是0会</p><p><mark>示例</mark></p><p>假设现在我们有一组从2006年到2016年1000部最流行的电影数据，我们想知道这些电影数据中评分的平均分，导演的人数等信息，我们应该怎么获取？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd, numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;IMDB-Movie-Data.csv&#x27;)</span><br><span class="line">print(type(df))</span><br><span class="line">print(df.info())</span><br><span class="line">print(df.head())</span><br><span class="line">print(df[&#x27;Rating&#x27;].values)</span><br><span class="line">print(df[&#x27;Rating&#x27;].describe())</span><br><span class="line"># df[&#x27;Rating&#x27;].mean()为numpy类型的数据，不能使用字符串拼接，需要先转换为字符串</span><br><span class="line"># 电影评分平均值</span><br><span class="line">print(&#x27;电影平均分：&#x27; + str(df[&#x27;Rating&#x27;].mean()))</span><br><span class="line"># 导演的人数</span><br><span class="line"># df[&#x27;Director&#x27;].tolist()  #  python tolist()方法:将数组或者矩阵转换成列表</span><br><span class="line"># set(df[&#x27;Director&#x27;].tolist()) # 使用set() 将数组去重并转换为set集合，集合是一个无序的不重复元素序列</span><br><span class="line">print(&#x27;导演人数：&#x27;, len(set(df[&#x27;Director&#x27;].tolist())))</span><br><span class="line"># 别一种方法：df[&#x27;Director&#x27;].unique()可以将df[&#x27;Director&#x27;]去重，并返回</span><br><span class="line">print(&#x27;导演人数：&#x27;, len(df[&#x27;Director&#x27;].unique()))</span><br><span class="line"># 由于每一部电影的演员有多人，所以先使用split(&#x27;,&#x27;)以逗号分隔，让每组数据的字符串重组为数组</span><br><span class="line">print(&#x27;所有演员二维数据：&#x27;)</span><br><span class="line">print(df[&#x27;Actors&#x27;].str.split(&#x27;,&#x27;).tolist())</span><br><span class="line">temp_list = df[&#x27;Actors&#x27;].str.split(&#x27;,&#x27;).tolist()</span><br><span class="line"># 将二维数组展开</span><br><span class="line">nums = [i for j in temp_list for i in j]</span><br><span class="line">print(&#x27;所有演员一维数组：&#x27;)</span><br><span class="line">print(nums)</span><br><span class="line"># 数组去重,并取总数</span><br><span class="line">actors = len(set(nums))  # 使用set集合的特点去重</span><br><span class="line">actors2 = len(pd.Series(nums).unique())  # 使用pandas的unique方法去重</span><br><span class="line">print(&#x27;去重后演员的总人数：&#x27;, actors, actors2)</span><br><span class="line"># 电影时长的最大最小值：</span><br><span class="line">max_runtime = df[&#x27;Runtime (Minutes)&#x27;].max()</span><br><span class="line">max_runtime_index = df[&#x27;Runtime (Minutes)&#x27;].argmax()</span><br><span class="line">min_runtime = df[&#x27;Runtime (Minutes)&#x27;].min()</span><br><span class="line">min_runtime_index = df[&#x27;Runtime (Minutes)&#x27;].argmin()</span><br><span class="line">runtime_median = df[&#x27;Runtime (Minutes)&#x27;].median()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7a158f5466e84d30bc4962abb4d77a75.png#pic_center" alt="图片15"></p><p><mark>示例</mark></p><p>对于这一组电影数据，如果我们希望统计电影分类(genre)的情况，应该如何处理数据？</p><p>思路：重新构造一个全为0的数组，列名为分类，如果某一条数据中分类出现过，就让0变为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;IMDB-Movie-Data.csv&#x27;)</span><br><span class="line">print(df[&#x27;Genre&#x27;])</span><br><span class="line">temp_list = df[&#x27;Genre&#x27;].str.split(&#x27;,&#x27;).tolist()</span><br><span class="line">print(temp_list)</span><br><span class="line"># 利用set展开二维列表并去重</span><br><span class="line">genre_list = list(set([i for j in temp_list for i in j]))</span><br><span class="line">print(genre_list)</span><br><span class="line"># 构造全为0的DataFrame:df一样的行数，分类总数的列数，索引为分类数据genre_list</span><br><span class="line"># np.zeros((a,b))里面传的是元组</span><br><span class="line">zeros_df = pd.DataFrame(np.zeros((df.shape[0], len(genre_list))), columns=genre_list)</span><br><span class="line">print(zeros_df)</span><br><span class="line">for i in range(df.shape[0]):</span><br><span class="line">    zeros_df.loc[i, temp_list[i]] = 1</span><br><span class="line"># 显示所有列</span><br><span class="line">pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># 显示所有列</span><br><span class="line"># pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># #显示所有行</span><br><span class="line"># pd.set_option(&#x27;display.max_rows&#x27;, None)</span><br><span class="line"># #设置value的显示长度为100，默认为50</span><br><span class="line"># pd.set_option(&#x27;max_colwidth&#x27;,100)</span><br><span class="line">print(zeros_df.head(1))</span><br><span class="line"># 统计每个分类的电影的数量和</span><br><span class="line">genre_count = zeros_df.sum(axis=0)</span><br><span class="line">print(genre_count)</span><br><span class="line"># 排序</span><br><span class="line">genre_count = genre_count.sort_values()</span><br><span class="line"># 画柱状图</span><br><span class="line">_x = genre_count.index</span><br><span class="line">_y = genre_count.values</span><br><span class="line">plt.figure(figsize=(20, 8), dpi=80)</span><br><span class="line">plt.bar(range(len(_x)), _y)</span><br><span class="line">plt.xticks(range(len(_x)), _x)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/378e9f5eeb7d4373940e2aa3f7131f91.png#pic_center" alt="图片16"></p><h2 id="12-数据合并之join">12.数据合并之join</h2><p>join:默认情况下他是把行索引相同的数据合并到一起</p><p><img src="https://img-blog.csdnimg.cn/a2b0d6d56c47431baf76ad4ab8f1c9fa.png#pic_center" alt="图片17"></p><h2 id="13-数据合并之merge">13.数据合并之merge</h2><p>merge:按照指定的列把数据按照一定的方式合并到一起</p><p><img src="https://img-blog.csdnimg.cn/1ba88efd40d944d3a995597ec1d810a4.png#pic_center" alt="图片18"></p><p><mark>示例：</mark></p><p>现在我们有一组关于全球星巴克店铺的统计数据，如果我想知道美国的星巴克数量和中国的哪个多，或者我想知道中国每个省份星巴克的数量的情况，那么应该怎么办？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;starbucks_store_worldwide.csv&#x27;)</span><br><span class="line"># print(df)</span><br><span class="line"># print(df.info())</span><br><span class="line"># df_country = df.groupby(&#x27;Country&#x27;)  # 生成一个DataFrameGroupBy object</span><br><span class="line"># print(df_country)</span><br><span class="line"># # 显示所有列</span><br><span class="line"># pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># # 遍历</span><br><span class="line"># # for i in df_country:</span><br><span class="line"># #     print(i) # 遍历后的每一个数据都是一个元组</span><br><span class="line">#</span><br><span class="line"># # 由于遍历后的每一个值都是元组，所以还可以这样遍历</span><br><span class="line"># for i, j in df_country:</span><br><span class="line">#     print(i, j, type(j))  # i为国家信息，j为一个DataFrame,其中所有的country字段均为i</span><br><span class="line">#     print(&#x27;*&#x27; * 100)</span><br><span class="line">#</span><br><span class="line"># # 调用聚合方法</span><br><span class="line"># print(df_country.count())  # count()可以统计每个字段的总数</span><br><span class="line"># print(df_country[&#x27;City&#x27;].count())  # 单独统计一个字段的总数</span><br><span class="line"># #</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">平均值，中位数等方法也可以使用，但这里使用没有意义，因为都是字符串</span><br><span class="line">count:分组中非NA值的数量</span><br><span class="line">sum:非NA的和</span><br><span class="line">mean:非NA值的平均值 </span><br><span class="line">median:非NA值的算术中位数</span><br><span class="line">std、var: 无偏（分母为n-a)标准差和方差</span><br><span class="line">min,max:非NA值的最小值和最大值 &quot;&quot;&quot;</span><br><span class="line"># country_count = df_country[&#x27;City&#x27;].count()</span><br><span class="line"># # 美国和中国的星巴克店铺数量</span><br><span class="line"># print(&#x27;美国：&#x27;, country_count[&#x27;US&#x27;])</span><br><span class="line"># print(&#x27;中国：&#x27;, country_count[&#x27;CN&#x27;])</span><br><span class="line"></span><br><span class="line"># 统计中国每个省份的星巴克</span><br><span class="line">china_data = df[df[&#x27;Country&#x27;] == &#x27;CN&#x27;]  # 取出中国的星巴克数据，这里可以不需要分组，直接取数据</span><br><span class="line"># print(china_data)</span><br><span class="line"># print(china_data.info())</span><br><span class="line"># province_data = china_data.groupby(&#x27;State/Province&#x27;).count()[&#x27;Brand&#x27;]</span><br><span class="line"># print(province_data)</span><br><span class="line"># groupby可以传入多个条件来分组</span><br><span class="line">print(df[&#x27;Brand&#x27;])</span><br><span class="line">china_data_group = df.groupby(</span><br><span class="line">    by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]]).count()  # 返回一个Series,列索引有两个，一个是country,一个是State/Province</span><br><span class="line">print(china_data_group)</span><br><span class="line">print(china_data_group[&#x27;Brand&#x27;])</span><br><span class="line"></span><br><span class="line"># 以下三种写法，结果相同</span><br><span class="line">group1 = df.groupby(by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]]).count()[&#x27;Brand&#x27;]</span><br><span class="line">group2 = df[&#x27;Brand&#x27;].groupby(by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]]).count()</span><br><span class="line">group3 = df.groupby(by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]])[&#x27;Brand&#x27;].count()</span><br><span class="line">print(group1, type(group1))</span><br><span class="line">print(&#x27;*&#x27; * 100)</span><br><span class="line">print(group2, type(group2))</span><br><span class="line">print(&#x27;*&#x27; * 100)</span><br><span class="line">print(group3, type(group3))</span><br><span class="line"># 取值可以为DataFrame,需要使用一个小技巧</span><br><span class="line">group4 = df[[&#x27;Brand&#x27;]].groupby(by=[df[&#x27;Country&#x27;], df[&#x27;State/Province&#x27;]]).count()</span><br><span class="line">print(&#x27;*&#x27; * 100)</span><br><span class="line">print(group4, type(group4))</span><br><span class="line">print(group1.index)</span><br></pre></td></tr></table></figure><h2 id="14-分组和聚合">14.分组和聚合</h2><p><code>grouped = df.groupby(by=&quot;columns_name&quot;)</code></p><p>grouped是一个DataFrameGroupBy对象，是可迭代的</p><p>grouped中的每一个元素是一个元组</p><p>元组里面是（索引(分组的值)，分组之后的DataFrame）</p><p>DataFrameGroupBy对象有很多经过优化的方法</p><p><img src="https://img-blog.csdnimg.cn/139e675a90e1446098f585c5279e346c.png#pic_center" alt="图片19"></p><p>如果我们需要对国家和省份进行分组统计，应该怎么操作呢？</p><p><code>grouped = df.groupby(by=[df[&quot;Country&quot;],df[&quot;State/Province&quot;]])</code></p><p>很多时候我们只希望对获取分组之后的某一部分数据，或者说我们只希望对某几列数据进行分组，这个时候我们应该怎么办呢？</p><p>获取分组之后的某一部分数据：</p><p><code>df.groupby(by=[&quot;Country&quot;,&quot;State/Province&quot;])[&quot;Country&quot;].count()</code></p><p>对某几列数据进行分组：</p><p><code>df[&quot;Country&quot;].groupby(by=[df[&quot;Country&quot;],df[&quot;State/Province&quot;]]).count()</code></p><p>观察结果，由于只选择了一列数据，所以结果是一个Series类型</p><p>如果我想返回一个DataFrame类型呢？</p><p><code>t1 = df[[&quot;Country&quot;]].groupby(by=[df[&quot;Country&quot;],df[&quot;State/Province&quot;]]).count()</code><br><code>t2 = df.groupby(by=[&quot;Country&quot;,&quot;State/Province&quot;])[[&quot;Country&quot;]].count()</code></p><p>以上的两条命令结果一样</p><p>和之前的结果的区别在于当前返回的是一个DataFrame类型</p><p>简单的索引操作：</p><p>•获取index：<code>df.index</code></p><p>•指定index ：<code>df.index = ['x','y']</code></p><p>•重新设置index : <code>df.reindex(list(&quot;abcedf&quot;))</code></p><p>•指定某一列作为index ：<code>df.set_index(&quot;Country&quot;,drop=False)</code></p><p>•返回index的唯一值：<code>df.set_index(&quot;Country&quot;).index.unique()</code></p><h2 id="15-Series复合索引">15.Series复合索引</h2><p><img src="https://img-blog.csdnimg.cn/65d81c0cc1934479aeb8cee008889f63.png#pic_center" alt="图片20"></p><p><img src="https://img-blog.csdnimg.cn/40eeea952b1340a594e96bb67792006c.png#pic_center" alt="图片21"></p><p><img src="https://img-blog.csdnimg.cn/89c065dd558b4334bddd49b9ddab9b90.png#pic_center" alt="图片22"></p><p><mark>示例</mark></p><p>现在我们有2015到2017年25万条911的紧急电话的数据，请统计出出这些数据中不同类型的紧急情况的次数，如果我们还想统计出不同月份不同类型紧急电话的次数的变化情况，应该怎么做呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd, numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;911.csv&#x27;)</span><br><span class="line"># 显示所有列</span><br><span class="line">pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># print(df.head())</span><br><span class="line"># print(df.info())</span><br><span class="line"># print(df[&#x27;title&#x27;].str.split(&#x27;:&#x27;))</span><br><span class="line"># print(df[&#x27;title&#x27;].str.split(&#x27;:&#x27;)[0]) # 不能取到数据</span><br><span class="line"># to_list()将序列转换为数组</span><br><span class="line">temp_list = df[&#x27;title&#x27;].str.split(&#x27;:&#x27;).to_list()</span><br><span class="line"># temp_list = df[&#x27;title&#x27;].str.split(&#x27;:&#x27;).tolist()</span><br><span class="line">print(temp_list)</span><br><span class="line"># 遍历并取出第一项数据并去重</span><br><span class="line">cate_list = list(set([i[0] for i in temp_list]))</span><br><span class="line">print(cate_list)</span><br><span class="line"># 构造一个DataFrame,三列，与df同行，数据全为0</span><br><span class="line">zeros_df = pd.DataFrame(np.zeros((df.shape[0], len(cate_list))), columns=cate_list)</span><br><span class="line">print(zeros_df)</span><br><span class="line"># 　由于df数据量太大，如果直接遍历，会消耗很长时间</span><br><span class="line"># for i in range(df.shape[0]):</span><br><span class="line">#     zeros_df.loc[i,temp_list[i][0]] = 1</span><br><span class="line">#</span><br><span class="line"># print(zeros_df)</span><br><span class="line"></span><br><span class="line"># 遍历cate_list,只需要循环三次</span><br><span class="line">for cate in cate_list:</span><br><span class="line">    # df[&#x27;title&#x27;].str.contains(cate)返回的是一个布尔型数组，行数与zeros_df相同，列数为三列，</span><br><span class="line">    # 包含cate的那一列为True,具体可见5.62布尔索引章节</span><br><span class="line">    zeros_df[cate][df[&#x27;title&#x27;].str.contains(cate)] = 1</span><br><span class="line"></span><br><span class="line"># print(zeros_df)</span><br><span class="line"></span><br><span class="line"># 统计邮寄类型的数量</span><br><span class="line">sum_ret = zeros_df.sum(axis=0)</span><br><span class="line">print(sum_ret)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd, numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&#x27;911.csv&#x27;)</span><br><span class="line"># #显示所有行</span><br><span class="line">pd.set_option(&#x27;display.max_rows&#x27;, None)</span><br><span class="line">print(df.head())</span><br><span class="line">print(df.info())</span><br><span class="line"></span><br><span class="line"># to_list()将序列转换为数组</span><br><span class="line">temp_list = df[&#x27;title&#x27;].str.split(&#x27;:&#x27;).to_list()</span><br><span class="line"></span><br><span class="line"># print(temp_list)</span><br><span class="line"># 遍历并取出第一项的分类</span><br><span class="line">cate_list = [i[0] for i in temp_list]</span><br><span class="line"># print(cate_list)</span><br><span class="line">cate_df = pd.DataFrame(np.array(cate_list).reshape((df.shape[0]), 1), columns=[&#x27;cate&#x27;])</span><br><span class="line">print(cate_df)</span><br><span class="line"># 添加一列，列索引为cate</span><br><span class="line">df[&#x27;cate&#x27;] = cate_df</span><br><span class="line"># print(df[&#x27;cate&#x27;])</span><br><span class="line">print(df.groupby(by=&#x27;cate&#x27;).count()[&#x27;title&#x27;])</span><br></pre></td></tr></table></figure><h2 id="16-pandas中的时间序列">16.pandas中的时间序列</h2><p><mark>生成一段时间范围</mark></p><p><code>pd.date_range(start=None, end=None, periods=None, freq='D')</code></p><p>start和end以及freq配合能够生成start和end范围内以频率freq的一组时间索引</p><p>start和periods以及freq配合能够生成从start开始的频率为freq的periods个时间索引</p><p><img src="https://img-blog.csdnimg.cn/94cf1dc007ba4c459281320984f69db1.png#pic_center" alt="图片23"></p><p><mark>关于频率的更多缩写</mark></p><p><img src="https://img-blog.csdnimg.cn/4615b163445f4fd8a3e88cdf7cfc452a.png#pic_center" alt="图片24"></p><p><mark>在DataFrame中使用时间序列</mark></p><p><code>index=pd.date_range(&quot;20170101&quot;,periods=10)</code></p><p><code>df = pd.DataFrame(np.random.rand(10),index=index)</code></p><p>回到最开始的911数据的案例中，我们可以使用pandas提供的方法把时间字符串转化为时间序列</p><p><code>df[&quot;timeStamp&quot;] = pd.to_datetime(df[&quot;timeStamp&quot;],format=&quot;&quot;)</code></p><p>format参数大部分情况下可以不用写，但是对于pandas无法格式化的时间字符串，我们可以使用该参数，比如包含中文</p><p>那么问题来了：</p><p>我们现在要统计每个月或者每个季度的次数怎么办呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">df = pd.read_csv(&#x27;911.csv&#x27;)</span><br><span class="line">#显示所有列</span><br><span class="line">pd.set_option(&#x27;display.max_columns&#x27;, None)</span><br><span class="line"># #显示所有行</span><br><span class="line">pd.set_option(&#x27;display.max_rows&#x27;, None)</span><br><span class="line">print(df.info())</span><br><span class="line">print(df.head())</span><br><span class="line"># 将时间字符串转换为时间类型数据datetime64，以便进一步处理</span><br><span class="line">print(pd.to_datetime(df[&#x27;timeStamp&#x27;]).head())</span><br><span class="line"># 重新赋值df[&#x27;timeStamp&#x27;]</span><br><span class="line">df[&#x27;timeStamp&#x27;] = pd.to_datetime(df[&#x27;timeStamp&#x27;])</span><br><span class="line"># 将列timeStamp转换为行索引</span><br><span class="line">df.set_index(&#x27;timeStamp&#x27;,inplace=True)</span><br><span class="line">print(df.head())</span><br><span class="line"></span><br><span class="line"># 统计出911数据中不同月份电话次数</span><br><span class="line">count_by_month = df.resample(&#x27;M&#x27;).count()[&#x27;title&#x27;]</span><br><span class="line">print(count_by_month)</span><br><span class="line"></span><br><span class="line">_x = count_by_month.index</span><br><span class="line">_y = count_by_month.values</span><br><span class="line">print(_x)</span><br><span class="line">print(_y)</span><br><span class="line">_x = [i.strftime(&#x27;%Y%m%d&#x27;) for i in _x]</span><br><span class="line">plt.figure(figsize=(20,8), dpi=80)</span><br><span class="line">plt.plot(_x,_y)</span><br><span class="line"># plt.plot(range(len(_x)),_y)</span><br><span class="line">plt.xticks(_x,rotation=45)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="17-pandas重采样">17.pandas重采样</h2><p><img src="https://img-blog.csdnimg.cn/b7551d9e0d7a43e09dd27e6fbc66121d.png#pic_center" alt="图片25"></p><p><mark>示例</mark></p><p>1.统计出911数据中不同月份电话次数的变化情况</p><p>2.统计出911数据中不同月份不同类型的电话的次数的变化情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import pandas as pd,numpy as np</span><br><span class="line">df = pd.read_csv(&#x27;911.csv&#x27;)</span><br><span class="line"># 重新赋值df[&#x27;timeStamp&#x27;]</span><br><span class="line">df[&#x27;timeStamp&#x27;] = pd.to_datetime(df[&#x27;timeStamp&#x27;])</span><br><span class="line">#添加列，表示分类</span><br><span class="line">temp_list = df[&quot;title&quot;].str.split(&quot;: &quot;).tolist()</span><br><span class="line">cate_list = [i[0] for i in temp_list]</span><br><span class="line"># 创建列</span><br><span class="line">df[&quot;cate&quot;] = pd.DataFrame(np.array(cate_list).reshape((df.shape[0],1)))</span><br><span class="line"># 将时间列转化为索引</span><br><span class="line">df.set_index(&quot;timeStamp&quot;,inplace=True)</span><br><span class="line">print(df.head(1))</span><br><span class="line">dk = df.groupby(&#x27;cate&#x27;)</span><br><span class="line">print(dk)</span><br><span class="line">plt.figure(figsize=(20, 8), dpi=80)</span><br><span class="line">for group_name,group_data in dk:</span><br><span class="line">    print(group_name,group_data)</span><br><span class="line">    # 对不同的分类都进行绘图</span><br><span class="line">    count_by_month = group_data.resample(&quot;M&quot;).count()[&quot;title&quot;]</span><br><span class="line">    # 画图</span><br><span class="line">    _x = count_by_month.index</span><br><span class="line">    print(_x)</span><br><span class="line">    _y = count_by_month.values</span><br><span class="line">    print(_y)</span><br><span class="line">    _x = [i.strftime(&quot;%Y%m%d&quot;) for i in _x]</span><br><span class="line"></span><br><span class="line">    plt.plot(range(len(_x)), _y, label=group_name)</span><br><span class="line"></span><br><span class="line">plt.xticks(range(len(_x)), _x, rotation=45)</span><br><span class="line">plt.legend(loc=&quot;best&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>现在我们有北上广、深圳、和沈阳5个城市空气质量数据，请绘制出5个城市的PM2.5随时间的变化情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">import pandas as pd</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">file_path = &quot;./PM2.5/BeijingPM20100101_20151231.csv&quot;</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(file_path)</span><br><span class="line">print(df.head())</span><br><span class="line">print(df.info())</span><br><span class="line"># 把分开的时间字符串通过periodIndex的方法转化为pandas的时间类型</span><br><span class="line">period = pd.PeriodIndex(year=df[&quot;year&quot;], month=df[&quot;month&quot;], day=df[&quot;day&quot;], hour=df[&quot;hour&quot;], freq=&quot;H&quot;)</span><br><span class="line"># 增加一列df[&quot;datetime&quot;]</span><br><span class="line">df[&quot;datetime&quot;] = period</span><br><span class="line">print(df.head(10))</span><br><span class="line">#</span><br><span class="line"># 把datetime 设置为索引</span><br><span class="line">df.set_index(&quot;datetime&quot;, inplace=True)</span><br><span class="line">#</span><br><span class="line"># 进行降采样,如果按日来排序，数据图不好看，按月份太稀疏，按日太绸</span><br><span class="line">df = df.resample(&quot;7D&quot;).mean()</span><br><span class="line">print(df.head())</span><br><span class="line"># 处理缺失数据，删除缺失数据</span><br><span class="line">print(df[&quot;PM_US Post&quot;])</span><br><span class="line"># dropna()该函数主要用于滤除缺失数据。</span><br><span class="line"># 如果是Series,则返回一个仅含非空数据和索引值的Series，默认丢弃含有缺失值的行。</span><br><span class="line"># 美国数据</span><br><span class="line">data = df[&quot;PM_US Post&quot;].dropna()  # 使用降采样后，会计算均值，这里再使用dropna()过滤空值意义不大</span><br><span class="line"># 中国数据</span><br><span class="line">data_china = df[&quot;PM_Nongzhanguan&quot;]</span><br><span class="line"></span><br><span class="line">print(data_china.head(100))</span><br><span class="line">#画图</span><br><span class="line"></span><br><span class="line">_x = data.index</span><br><span class="line">_x = [i.strftime(&quot;%Y%m%d&quot;) for i in _x]</span><br><span class="line"># 取中国PM2.5数据</span><br><span class="line">_x_china = [i.strftime(&quot;%Y%m%d&quot;) for i in data_china.index]</span><br><span class="line">print(len(_x_china),len(_x_china))</span><br><span class="line">_y = data.values</span><br><span class="line">_y_china = data_china.values</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(20,8),dpi=80)</span><br><span class="line"></span><br><span class="line">plt.plot(range(len(_x)),_y,label=&quot;US_POST&quot;,alpha=0.7)</span><br><span class="line">plt.plot(range(len(_x_china)),_y_china,label=&quot;CN_POST&quot;,alpha=0.7)</span><br><span class="line"></span><br><span class="line">plt.xticks(range(0,len(_x_china),10),list(_x_china)[::10],rotation=45)</span><br><span class="line"></span><br><span class="line">plt.legend(loc=&quot;best&quot;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const修饰指针的三种情况详解</title>
      <link href="/posts/6fb97407.html"/>
      <url>/posts/6fb97407.html</url>
      
        <content type="html"><![CDATA[<p>今天突然脑袋发热，对const修饰指针有点模糊，特此记录，方便复习<br>const修饰指针有三种情况</p><p>const修饰指针 — 常量指针<br>const修饰常量 — 指针常量<br>const即修饰指针，又修饰常量<br><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line">  p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">  <span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">  a = <span class="number">100</span>;    <span class="comment">//a的值还是能修改</span></span><br><span class="line">  cout &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">  <span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">  <span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">  *p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line">  <span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">  <span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于多信息融合的疲劳驾驶检测系统</title>
      <link href="/posts/feb32ed4.html"/>
      <url>/posts/feb32ed4.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-眨眼检测原理">1.眨眼检测原理</h2><p>基于dlib人脸识别68特征点检测、分别获取左右眼面部标志的索引，通过opencv对视频流进行灰度化处理，检测出人眼的位置信息。人脸特征点检测用到了dlib，dlib有两个关键函数：dlib.get_frontal_face_detector()和dlib.shape_predictor(predictor_path)。</p><p>前者是内置的人脸检测算法，检测人脸区域的界限后者是用来检测一个区域内的特征点，并输出这些特征点的坐标，它需要一个预先训练好的模型（通过文件路径的方法传入），才能正常工作。使用开源模型shape_predictor_68_face_landmarks.dat，可以得到68个特征点位置的坐标</p><p><a href="https://pypi.org/simple/dlib/">点我下载开源数据集</a></p><p>基本原理：计算 眼睛长宽比EAR.当人眼在正常状态下时，EAR在某个值上下波动，当人眼闭合时，EAR迅速下降。所以我们认为当EAR低于某个阈值时，眼睛处于闭合状态。为检测眨眼次数，我们设置了阈值为0.2，如果当前帧两双眼睛宽高比的平均值小于0.2，则加1，如果连续3次都小于阈值，则表示进行了一次眨眼活动。</p><p><img src="https://img-blog.csdnimg.cn/20191211162451238.png" alt="在这里插入图片描述"></p><p>（68点landmark中可以看到37-42为左眼，43-48为右眼）</p><p><img src="https://img-blog.csdnimg.cn/20191210164401726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1bmd1ZGFmYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>右眼开合度可以通过以下公式得到（左眼同理）：</p><p><img src="https://img-blog.csdnimg.cn/2019121016443063.png#pic_center" alt="在这里插入图片描述"></p><p>通过计算38、39、42、41的纵坐标、37、40的横坐标来计算眼睛的睁开度。如：1/2*[(y42+y41)-(y38+y39)]/(x40-x37)通过一个阈值确定眼睛是睁开还是闭上。也可以将这个值与初始的值的比值作为睁开度，根据不同程度来进行比较。睁开度从大到小为进入闭眼期，从小到大为进入睁眼期，计算 最长闭眼时间（可用帧数来代替）闭眼次数为进入闭眼、进入睁眼的次数 。</p><p>主要代码思路</p><p>第一步：使用dlib.get_frontal_face_detector() 获得脸部位置检测器第二步：使用dlib.shape_predictor获得脸部特征位置检测器第三步：分别获取左右眼面部标志的索引第四步：打开cv2 本地摄像头第五步：从视频流进行循环，读取图片，并对图片做维度扩大，并进灰度化第六步：使用detector(gray, 0) 进行脸部位置检测第七步：循环脸部位置信息，使用predictor(gray, rect)获得脸部特征位置的信息第八步：将脸部特征信息转换为数组array的格式第九步：提取左眼和右眼坐标第十步：构造函数计算左右眼的EAR值，使用平均值作为最终的EAR<br>第十一步：使用cv2.convexHull获得凸包位置，使用drawContours画出轮廓位置进行画图操作第十二步：进行画图操作，用矩形框标注人脸第十三步：分别计算左眼和右眼的评分求平均作为最终的评分，如果小于阈值，则加1，如果连续3次都小于阈值，则表示进行了一次眨眼活动第十四步：进行画图操作，68个特征点标识第十五步：进行画图操作，同时使用cv2.putText将眨眼次数进行显示</p><h2 id="2-打哈欠检测原理">2.打哈欠检测原理</h2><p>嘴部主要取六个参考点：</p><p><img src="https://img-blog.csdnimg.cn/20191211181733274.png#pic_center" alt="在这里插入图片描述"></p><p>打哈欠可利用嘴巴处通过计算51、59、53、57、的纵坐标、49、55的横坐标来计算眼睛的睁开度。如：1/2*[(y51+y53)-(y59+y57)]/(x55-x49)点的距离来判断是否张嘴及张嘴时间，从而确定人是否是在打哈欠，同时这个阈值应当合理，能够与正常说话或哼歌区分开来。</p><p>同眼睛相类似方法求嘴部欧式距离：</p><p><img src="https://img-blog.csdnimg.cn/20191211162451238.png" alt="在这里插入图片描述"></p><p><mark>主要代码思路</mark></p><p>Step1:提取帧图像检测人脸，嘴部粗定位进行肤色分割；<br>Step2: 嘴部精确定位，获取嘴部欧式距离K1，若k1大于阈值T1，则Step3,并且count+1；否则count=0回到step1，检测下一帧。<br>Step3: 统计哈欠特征值count,当count超过阈值3,则记作打一次哈欠，保存count到Yawn，Yawn(i)=count，count=0（count清0）回到Step1，否则的话也直接转回Step1。</p><h2 id="3-瞌睡点头检测原理">3.瞌睡点头检测原理</h2><p>采用Head Pose Estimation(头部姿态估计) 算法,该算法的步骤一般为：2D人脸关键点检测；3D人脸模型匹配；求解3D点和对应2D点的转换关系；根据旋转矩阵求解欧拉角</p><p><a href="https://developer.aliyun.com/article/674048">https://developer.aliyun.com/article/674048</a></p><p><a href="https://blog.csdn.net/lql0716/article/details/72597719">https://blog.csdn.net/lql0716/article/details/72597719</a></p><p>具体原理请看上面那两篇博客，网上有开源代码(如下)，大神已经帮我们搞好了，我们拿来直接用就行，最后得到欧拉角</p><p><a href="https://developer.aliyun.com/article/674048">点我查看参考代码</a></p><p><mark>主要代码思路</mark></p><p>头部姿态判断打瞌睡得到实时头部姿态的旋转角度过后,如下所示为头部旋转角度的3个参数Yaw,Pitch和Roll的示意图,驾驶员在打瞌睡时，显然头部会做类似于点头和倾斜的动作.而根据一般人的打瞌睡时表现出来的头部姿态，显然很少会在Yaw上有动作，而主要集中在Pitch和Roll的行为.设定参数阈值为0.3,在一个时间段内10 s内，当I PitchI≥20°或者|Rolll≥20°的时间比例超过0.3时,就认为驾驶员处于点头打瞌睡的状态</p><p><img src="https://img-blog.csdnimg.cn/20191212141457194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1bmd1ZGFmYQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-多信息融合的疲劳判断">4.多信息融合的疲劳判断</h2><p>我们分别计算出单位时间内瞌睡点头的频率，眨眼频率以及打哈欠的频率分别赋予他们不同的权值，采用信息融合的方式进行综合打分，最后根据最终分数，设置疲劳等级，分别为轻度疲劳，中度疲劳和重度疲劳，相应的做出报警等操作</p><h2 id="5-效果展示">5.效果展示</h2><h3 id="5-1ui界面设计">5.1ui界面设计</h3><p>[<img src="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue%20driving%20detection%20system/images/123.png" alt="img">](<a href="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue">https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue</a> driving detection system/images/123.png)</p><h3 id="5-2效果演示">5.2效果演示</h3><p>[<img src="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue%20driving%20detection%20system/images/%E6%BC%94%E7%A4%BA%E7%94%BB%E9%9D%A2.png" alt="img">](<a href="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue">https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue</a> driving detection system/images/演示画面.png)</p><h3 id="5-3报表界面部分演示">5.3报表界面部分演示</h3><p>[<img src="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue%20driving%20detection%20system/images/%E6%89%87%E5%BD%A2%E5%9B%BE.png" alt="img">](<a href="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue">https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue</a> driving detection system/images/扇形图.png)</p><p>[<img src="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue%20driving%20detection%20system/images/%E6%8A%98%E7%BA%BF%E5%9B%BE.png" alt="img">](<a href="https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue">https://raw.githubusercontent.com/Billysturate/Fatigue-driving-detection-system-based-on-opencv-dlib/main/Fatigue</a> driving detection system/images/折线图.png)</p><h2 id="6-项目进展">6.项目进展</h2><table><thead><tr><th><s><strong>眨眼检测</strong></s></th><th><strong>DONE</strong></th></tr></thead><tbody><tr><td><s><strong>打哈欠检测</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>瞌睡点头检测</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>实时眨眼频率计算</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>实时打哈欠频率</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>实时瞌睡点头频率</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>疲劳程度的计算</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>疲劳程度划分</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>UI界面设计</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>FPS计算以及语音播报</strong></s></td><td><strong>DONE</strong></td></tr><tr><td><s><strong>报表界面设计</strong></s></td><td><strong>DONE</strong></td></tr></tbody></table><h2 id="7-界面参数介绍">7.界面参数介绍</h2><table><thead><tr><th>Blinks</th><th>眨眼次数</th></tr></thead><tbody><tr><td><strong>Yawning</strong></td><td><strong>打哈欠次数</strong></td></tr><tr><td><strong>Nod</strong></td><td><strong>瞌睡点头次数</strong></td></tr><tr><td><strong>Blink Frequency</strong></td><td><strong>实时眨眼频率</strong></td></tr><tr><td><strong>Yawing Frequency</strong></td><td><strong>实时打哈欠频率</strong></td></tr><tr><td><strong>Nod Frequency</strong></td><td><strong>实时瞌睡点头频率</strong></td></tr><tr><td><strong>Score</strong></td><td><strong>疲劳程度</strong></td></tr><tr><td><strong>FPS</strong></td><td><strong>视频帧率</strong></td></tr></tbody></table><h2 id="8-文件介绍">8.文件介绍</h2><p>main.py-------------------------主程序</p><p>sats2.py--------------------------报表界面制作(pyecharts,感觉还是挺好用的，具体操作可以看官网文档，中国人开发的库值得推荐)</p><p><a href="https://gallery.pyecharts.org/#/Bar/stack_bar_percent">pyecharts gallery</a> <a href="https://pyecharts.org/#/zh-cn/intro">pyecharts操作手册</a></p><p>images目录下存放图片png以及ico</p><p>model目录下存放68人脸关键点模型</p><p>fatigue_detect.html-----------------可视化报表</p><h2 id="9-项目所有源代码获取">9.项目所有源代码获取</h2><p><a href="https://github.com/BillySturate/Fatigue-driving-detection-system-based-on-opencv-dlib">https://github.com/BillySturate/Fatigue-driving-detection-system-based-on-opencv-dlib</a></p><h2 id="10-参考博客">10.参考博客</h2><p><a href="https://blog.csdn.net/cungudafa/article/details/103477960">https://blog.csdn.net/cungudafa/article/details/103477960</a></p><p><a href="https://blog.csdn.net/cungudafa/article/details/103499230">https://blog.csdn.net/cungudafa/article/details/103499230</a></p><p><a href="https://blog.csdn.net/cungudafa/article/details/103496881">https://blog.csdn.net/cungudafa/article/details/103496881</a></p><p><a href="https://blog.csdn.net/lql0716/article/details/72597719">https://blog.csdn.net/lql0716/article/details/72597719</a></p><p><a href="https://developer.aliyun.com/article/674048">https://developer.aliyun.com/article/674048</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy详解</title>
      <link href="/posts/ee5d2157.html"/>
      <url>/posts/ee5d2157.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1hx411d7jb?spm_id_from=333.337.search-card.all.click&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><h2 id="1-什么是numpy">1.什么是numpy</h2><p>一个在Python中做科学计算的基础库，重在数值计算，也是大部分PYTHON科学计算库的基础库，多用于在大型、多维数组上执行数值运算</p><p><mark>为什么学习numpy?</mark></p><p>1.快速</p><p>2.方便</p><p>3.科学计算的基础库</p><h2 id="2-numpy基础">2.numpy基础</h2><h3 id="2-1numpy创建数组-矩阵">2.1numpy创建数组(矩阵)</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acb56f6.png" alt="图片1.png"></p><h3 id="2-2numpy中常见的更多数据类型">2.2numpy中常见的更多数据类型</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acbefda.png" alt="图片2.png"></p><h3 id="2-3数据类型的操作">2.3数据类型的操作</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acc056e.png" alt="图片3.png"></p><p><mark>代码示例</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">import numpy as np</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">#使用numpy生成数组,得到ndarray的类型</span><br><span class="line">t1 = np.array([1,2,3,])</span><br><span class="line">print(t1)</span><br><span class="line">print(type(t1))</span><br><span class="line"></span><br><span class="line">t2 = np.array(range(10))</span><br><span class="line">print(t2)</span><br><span class="line">print(type(t2))</span><br><span class="line"></span><br><span class="line">t3 = np.arange(4,10,2)</span><br><span class="line">print(t3)</span><br><span class="line">print(type(t3))</span><br><span class="line"></span><br><span class="line">print(t3.dtype)</span><br><span class="line">print(&quot;*&quot;*100)</span><br><span class="line">#numpy中的数据类型</span><br><span class="line"></span><br><span class="line">t4 = np.array(range(1,4),dtype=&quot;i1&quot;)</span><br><span class="line">print(t4)</span><br><span class="line">print(t4.dtype)</span><br><span class="line"></span><br><span class="line">##numpy中的bool类型</span><br><span class="line">t5 = np.array([1,1,0,1,0,0],dtype=bool)</span><br><span class="line">print(t5)</span><br><span class="line">print(t5.dtype)</span><br><span class="line"></span><br><span class="line">#调整数据类型</span><br><span class="line">t6 = t5.astype(&quot;int8&quot;)</span><br><span class="line">print(t6)</span><br><span class="line">print(t6.dtype)</span><br><span class="line"></span><br><span class="line">#numpy中的小数</span><br><span class="line">t7 = np.array([random.random() for i in range(10)])</span><br><span class="line">print(t7)</span><br><span class="line">print(t7.dtype)</span><br><span class="line"></span><br><span class="line">t8 = np.round(t7,2)</span><br><span class="line">print(t8)</span><br></pre></td></tr></table></figure><h3 id="2-4数组的形状">2.4数组的形状</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acbdfef.png" alt="图片4.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013acc138e.png" alt="图片5.png"></p><h3 id="2-5数组和数的计算">2.5数组和数的计算</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013acc50d8.png" alt="图片6.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013acc136b.png" alt="图片7.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013acc4f33.png" alt="图片8.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013acc5caa.png" alt="图片9.png"></p><h3 id="2-7广播原则">2.7广播原则</h3><p><img src="https://bu.dusays.com/2022/12/31/63b015961bd39.png" alt="图片10.png"></p><p>怎么理解呢?</p><p>可以把维度指的是shape所对应的数字个数</p><p>那么问题来了:</p><p>shape为(3,3,3)的数组能够和(3,2)的数组进行计算么?   <mark>不能</mark></p><p>shape为(3,3,2)的数组能够和(3,2)的数组进行计算么?<mark>能</mark></p><p>有什么好处呢?</p><p>举个例子:每列的数据减去列的平均值的结果</p><h3 id="2-8轴-axis">2.8轴(axis)</h3><p>在numpy中可以理解为方向,使用0,1,2…数字表示,对于一个一维数组,只有一个0轴,对于2维数组(shape(2,2)),有0轴和1轴,对于三维数组(shape(2,2, 3)),有0,1,2轴</p><p>有了轴的概念之后,我们计算会更加方便,比如计算一个2维数组的平均值,必须指定是计算哪个方向上面的数字的平均值</p><p>那么问题来了:</p><p>在前面的知识,轴在哪里?</p><p>回顾np.arange(0,10).reshape((2,5)),reshpe中2表示0轴长度(包含数据的条数)为2,1轴长度为5,2X5一共10个数据</p><p><mark>二维数组的轴</mark></p><p><img src="https://img-blog.csdnimg.cn/e9bbdf8a2c874bac9c160dfaf8e866c8.png#pic_center" alt=""></p><p><mark>三维数组的轴</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b013ada241e.png" alt="图片12.png"></p><h3 id="2-9numpy读取数据">2.9numpy读取数据</h3><p>CSV:Comma-Separated Value,逗号分隔值文件</p><p>显示：表格状态</p><p>源文件：换行和逗号分隔行列的格式化文本,每一行的数据表示一条记录</p><p>由于csv便于展示,读取和写入,所以很多地方也是用csv的格式存储和传输中小型的数据,为了方便教学,我们会经常操作csv格式的文件,但是操作数据库中的数据也是很容易的实现的</p><p><code>np.loadtxt(fname,dtype=np.float,delimiter=None,skiprows=0,usecols=None,unpack=False)</code></p><p><img src="https://bu.dusays.com/2022/12/31/63b013adc062d.png" alt="图片13.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b013adf27fc.png" alt="图片14.png"></p><h3 id="2-10numpy中的转置">2.10numpy中的转置</h3><p>转置是一种变换,对于numpy中的数组来说,就是在对角线方向交换数据,目的也是为了更方便的去处理数据</p><p><img src="https://bu.dusays.com/2022/12/31/63b013ae1a505.png" alt="图片15.png"></p><p>以上的三种方法都可以实现二维数组的转置的效果,大家能够看出来,转置和交换轴的效果一样</p><p><mark>示例</mark></p><p>现在这里有一个英国和美国各自youtube1000多个视频的点击,喜欢,不喜欢,评论数量([“views”,“likes”,“dislikes”,“comment_total”])的csv,运用刚刚所学习的只是,我们尝试来对其进行操作，那么,结合之前的所学的matplotlib把英国和美国的数据呈现出来?</p><p>看到这个问题,我们应该考虑什么?</p><p>1.我们想要反映出什么样的结果,解决什么问题?</p><p>2.选择什么样的呈现方式?</p><p>3.数据还需要做什么样的处理?</p><p>4.写代码</p><h3 id="2-11numpy索引和切片">2.11numpy索引和切片</h3><p>对于刚刚加载出来的数据,我如果只想选择其中的某一列(行)我们应该怎么做呢?</p><p>其实操作很简单,和python中列表的操作一样</p><p><img src="https://bu.dusays.com/2022/12/31/63b013ae34081.png" alt="图片16.png"></p><p><mark>代码示例</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">us_file_path = &quot;./youtube_video_data/US_video_data_numbers.csv&quot;</span><br><span class="line">uk_file_path = &quot;./youtube_video_data/GB_video_data_numbers.csv&quot;</span><br><span class="line"></span><br><span class="line"># t1 = np.loadtxt(us_file_path,delimiter=&quot;,&quot;,dtype=&quot;int&quot;,unpack=True)</span><br><span class="line">t2 = np.loadtxt(us_file_path,delimiter=&quot;,&quot;,dtype=&quot;int&quot;)</span><br><span class="line"></span><br><span class="line"># print(t1)</span><br><span class="line">print(t2)</span><br><span class="line"></span><br><span class="line">print(&quot;*&quot;*100)</span><br><span class="line"></span><br><span class="line">#取行</span><br><span class="line"># print(t2[2])</span><br><span class="line"></span><br><span class="line">#取连续的多行</span><br><span class="line"># print(t2[2:])</span><br><span class="line"></span><br><span class="line">#取不连续的多行</span><br><span class="line"># print(t2[[2,8,10]])</span><br><span class="line"></span><br><span class="line"># print(t2[1,:])</span><br><span class="line"># print(t2[2:,:])</span><br><span class="line"># print(t2[[2,10,3],:])</span><br><span class="line"></span><br><span class="line">#取列</span><br><span class="line"># print(t2[:,0])</span><br><span class="line"></span><br><span class="line">#取连续的多列</span><br><span class="line"># print(t2[:,2:])</span><br><span class="line"></span><br><span class="line">#取不连续的多列</span><br><span class="line"># print(t2[:,[0,2]])</span><br><span class="line"></span><br><span class="line">#去行和列，取第3行，第四列的值</span><br><span class="line"># a = t2[2,3]</span><br><span class="line"># print(a)</span><br><span class="line"># print(type(a))</span><br><span class="line"></span><br><span class="line">#取多行和多列，取第3行到第五行，第2列到第4列的结果</span><br><span class="line">#去的是行和列交叉点的位置</span><br><span class="line">b = t2[2:5,1:4]</span><br><span class="line"># print(b)</span><br><span class="line"></span><br><span class="line">#取多个不相邻的点</span><br><span class="line">#选出来的结果是（0，0） （2，1） （2，3）</span><br><span class="line">c = t2[[0,2,2],[0,1,3]]</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h3 id="2-12numpy中数值的修改">2.12numpy中数值的修改</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013ae5a6c8.png" alt="图片17.png"></p><h3 id="2-13numpy中布尔索引">2.13numpy中布尔索引</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013ae866a9.png" alt="图片18.png"></p><h3 id="2-14numpy中三元运算符">2.14numpy中三元运算符</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013aea983a.png" alt="图片19.png"></p><h3 id="2-15numpy中的clip-裁剪">2.15numpy中的clip(裁剪)</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013aec2565.png" alt="图片20.png"></p><p>观察上方的操作：</p><p>小于10的替换为10，大于18的替换为了18，nan不会被替换</p><h3 id="2-16numpy中的nan和inf">2.16numpy中的nan和inf</h3><p>nan(NAN,Nan):not a number表示不是一个数字</p><p>什么时候numpy中会出现nan：</p><p>当我们读取本地的文件为float的时候，如果有缺失，就会出现nan</p><p>当做了一个不合适的计算的时候(比如无穷大(inf)减去无穷大)</p><p>inf(-inf,inf):infinity,inf表示正无穷，-inf表示负无穷</p><p>什么时候回出现inf包括（-inf，+inf）</p><p>比如一个数字除以0，（python中直接会报错，numpy中是一个inf或者-inf）</p><p><img src="https://bu.dusays.com/2022/12/31/63b013aee5dab.png" alt="图片21.png"></p><p><mark>numpy中的nan的注意点</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b013af24d7d.png" alt="图片22.png"></p><p>那么问题来了，在一组数据中单纯的把nan替换为0，合适么？会带来什么样的影响？</p><p>比如，全部替换为0后，替换之前的平均值如果大于0，替换之后的均值肯定会变小，所以更一般的方式是把缺失的数值替换为均值（中值）或者是直接删除有缺失值的一行</p><h3 id="2-17numpy中常用统计函数">2.17numpy中常用统计函数</h3><p>求和：t.sum(axis=None)</p><p>均值：t.mean(a,axis=None) 受离群点的影响较大</p><p>中值：np.median(t,axis=None)</p><p>最大值：t.max(axis=None)</p><p>最小值：t.min(axis=None)</p><p>极值：np.ptp(t,axis=None) 即最大值和最小值只差</p><p>标准差：t.std(axis=None)</p><p>默认返回多维数组的全部的统计结果,如果指定axis则返回一个当前轴上的结果</p><h3 id="2-18-一个小案例">2.18 一个小案例</h3><p>t中存在nan值，如何操作把其中的nan填充为每一列的均值</p><p>t = array([[ 0.,  1.,  2.,  3.,  4.,  5.],</p><p>​    [ 6.,  7., nan,  9., 10., 11.],</p><p>​    [ 12., 13., 14., nan, 16., 17.],</p><p>​    [ 18., 19., 20., 21., 22., 23.]])</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">def Fill_Ndarry(r1):</span><br><span class="line">    for i in range(r1.shape[1]):</span><br><span class="line">        temp_col = r1[:, i]</span><br><span class="line">        nan_num = np.count_nonzero(temp_col != temp_col)</span><br><span class="line">        if nan_num != 0:</span><br><span class="line">            temp_not_nan = temp_col[temp_col == temp_col]</span><br><span class="line">            # print(temp_not_nan)</span><br><span class="line">            temp_col[np.isnan(temp_col)] = temp_not_nan.mean()</span><br><span class="line">            # print(temp_col[np.isnan(temp_col)])</span><br><span class="line">    return r1</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    t1 = np.arange(24).reshape((4, 6)).astype(&quot;float&quot;)</span><br><span class="line">    t1[1, 2:] = np.nan</span><br><span class="line">    print(t1)</span><br><span class="line">    t1 = Fill_Ndarry(t1)</span><br><span class="line">    print(t1)</span><br></pre></td></tr></table></figure><h3 id="2-19数组的拼接及行列交换">2.19数组的拼接及行列交换</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013af34138.png" alt="图片23.png"></p><p><mark>数组的行列交换</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b013af52fd3.png" alt="图片24.png"></p><p><mark>numpy更多好用的方法</mark></p><p>1.获取最大值最小值的位置</p><p>​ np.argmax(t,axis=0)</p><p>​ np.argmin(t,axis=1)</p><p>2.创建一个全0的数组: np.zeros((3,4))</p><p>3.创建一个全1的数组:np.ones((3,4))</p><p>4.创建一个对角线为1的正方形数组(方阵)：np.eye(3)</p><h3 id="2-20numpy生成随机数">2.20numpy生成随机数</h3><p><img src="https://bu.dusays.com/2022/12/31/63b013af8130a.png" alt="图片25.png"></p><p><mark>分布的补充</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b013afbdc30.png" alt="图片26.png"></p><h3 id="2-21numpy的注意点copy和view">2.21numpy的注意点copy和view</h3><p>1.a=b 完全不复制，a和b相互影响</p><p>2.a = b[:],视图的操作，一种切片，会创建新的对象a，但是a的数据完全由b保管，他们两个的数据变化是一致的，</p><p>3.a = b.copy(),复制，a和b互不影响</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib详解</title>
      <link href="/posts/68795d4b.html"/>
      <url>/posts/68795d4b.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1hx411d7jb?spm_id_from=333.337.search-card.all.click&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><h2 id="1-什么是matplotlib">1.什么是matplotlib</h2><p>matplotlib: 最流行的Python底层绘图库，主要做数据可视化图表,名字取材于MATLAB，模仿MATLAB构建</p><h2 id="2-样例">2.样例</h2><h3 id="2-1折线图">2.1折线图</h3><p>eg：假设一天中每隔两个小时(range(2,26,2))的气温(℃)分别是[15,13,14.5,17,20,25,26,26,27,22,18,15]</p><p><mark>matplotlib基本要点</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bc4084.png" alt="图片1.png"></p><p><mark>设置图片大小</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bca508.png" alt="图片2.png"></p><p><mark>调整X或者Y轴上的刻度</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bca5a2.png" alt="图片3.png"></p><p>那么问题来了:</p><p>​    如果列表a表示10点到12点的每一分钟的气温,如何绘制折线图观察每分钟气温的变化情况?</p><p>​    <code>a= [random.randint(20,35) for i in range(120)]</code></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd4ea9.png" alt="图片4.png"></p><p><mark>设置中文显示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd9667.png" alt="图片5.png"></p><p><mark>给图像添加描述信息</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd3f81.png" alt="图片6.png"></p><p><mark>最终代码展示</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager</span><br><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&quot;C:/Windows/Fonts/SimHei.ttf&quot;</span>, size=<span class="number">14</span>)</span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">120</span>)</span><br><span class="line">y = [random.randint(<span class="number">20</span>, <span class="number">35</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">120</span>)]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>), dpi=<span class="number">80</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">_x = x[::<span class="number">5</span>]</span><br><span class="line">_xtick_labels = [<span class="string">&quot;10点&#123;&#125;分&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>)]</span><br><span class="line">_xtick_labels += [<span class="string">&quot;11点&#123;&#125;分&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>)]</span><br><span class="line">plt.xticks(_x, _xtick_labels[::<span class="number">5</span>], rotation=<span class="number">45</span>, fontproperties=my_font)  <span class="comment"># rotation旋转的度数</span></span><br><span class="line"><span class="comment"># 添加描述信息</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;时间&quot;</span>, fontproperties=my_font)</span><br><span class="line">plt.ylabel(<span class="string">&quot;温度 单位(℃)&quot;</span>, fontproperties=my_font)</span><br><span class="line">plt.title(<span class="string">&quot;10点到12点每分钟的气温变化情况&quot;</span>, fontproperties=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>最终效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bddb36.png" alt="图片7.png"></p><p><mark>动手一练</mark></p><p>假设大家在30岁的时候,根据自己的实际情况,统计出来了你和你同桌各自从11岁到30岁每年交的女(男)朋友的数量如列表a和b,请在一个图中绘制出该数据的折线图,以便比较自己和同桌20年间的差异,同时分析每年交女(男)朋友的数量走势</p><p>a = [1,0,1,1,2,4,3,2,3,4,4,5,6,5,4,3,3,1,1,1]</p><p>b = [1,0,3,1,2,2,3,3,2,1 ,2,1,1,1,1,1,1,1,1,1]</p><p>要求:</p><p>y轴表示个数</p><p>x轴表示岁数,比如11岁,12岁等</p><p><mark>代码展示</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&quot;C:/Windows/Fonts/SimHei.ttf&quot;</span>, size=<span class="number">14</span>)</span><br><span class="line">y1 = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">y2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">11</span>, <span class="number">31</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>), dpi=<span class="number">80</span>)</span><br><span class="line">plt.plot(x, y1, label=<span class="string">&quot;自己&quot;</span>)</span><br><span class="line">plt.plot(x, y2, label=<span class="string">&quot;同桌&quot;</span>)</span><br><span class="line">_xtick = [<span class="string">&quot;&#123;&#125;岁&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">plt.xticks(x, _xtick, rotation=<span class="number">45</span>, fontproperties=my_font)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制网格</span></span><br><span class="line">plt.grid(alpha=<span class="number">0.4</span>)</span><br><span class="line">plt.legend(prop=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>在上一个案例中如果大家希望自定义绘制图形的风格怎么办?</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd369f.png" alt="图片8.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bd7729.png" alt="图片9.png"></p><p><mark>虽然线条有了不一样的风格,但是读者还是不知道那条线是谁怎么办?</mark></p><p><strong>为每条线添加图例</strong></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120bdbff9.png" alt="图片10.png"></p><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120c91049.png" alt="图片11.png"></p><p><mark>总结:前面我们都做了什么</mark>？</p><p>1.绘制了折线图(plt.plot)</p><p>2.设置了图片的大小和分辨率(plt.figure)</p><p>3.实现了图片的保存(plt.savefig)</p><p>4.设置了xy轴上的刻度和字符串(xticks)</p><p>5.解决了刻度稀疏和密集的问题(xticks)</p><p>6.设置了标题,xy轴的lable(title,xlable,ylable)</p><p>7.设置了字体(font_manager. fontProperties,matplotlib.rc)</p><p>8.在一个图上绘制多个图形(plt多次plot即可)</p><p>9.为不同的图形添加图例</p><p>以上统统很重要</p><h3 id="2-2散点图">2.2散点图</h3><p>eg:假设通过爬虫你获取到了北京2016年3,10月份每天白天的最高气温(分别位于列表a,b),那么此时如何寻找出气温和随时间(天)变化的某种规律?</p><p>a = [11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23]</p><p>b = [26,26,28,19,21,17,16,19,18,20,20,19,22,23,17,20,21,20,22,15,11,15,5,13,17,10,11,13,12,13,6]</p><p><mark>代码展示</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=&quot;C:/Windows/Fonts/SimHei.ttf&quot;, size=14)</span><br><span class="line">y_3 = [11, 17, 16, 11, 12, 11, 12, 6, 6, 7, 8, 9, 12, 15, 14, 17, 18, 21, 16, 17, 20, 14, 15, 15, 15, 19, 21, 22, 22,</span><br><span class="line">       22, 23]</span><br><span class="line">y_10 = [26, 26, 28, 19, 21, 17, 16, 19, 18, 20, 20, 19, 22, 23, 17, 20, 21, 20, 22, 15, 11, 15, 5, 13, 17, 10, 11, 13,</span><br><span class="line">        12, 13, 6]</span><br><span class="line">x_3 = range(1, 32)</span><br><span class="line">x_10 = range(41, 72)</span><br><span class="line">x = list(x_3) + list(x_10)</span><br><span class="line">plt.figure(figsize=(20, 10), dpi=80)</span><br><span class="line">plt.scatter(x_3, y_3, label=&quot;3月&quot;)</span><br><span class="line">plt.scatter(x_10, y_10, label=&quot;10月&quot;)</span><br><span class="line">_xtick = [&quot;3月&#123;&#125;日&quot;.format(i) for i in x_3]</span><br><span class="line">_xtick += [&quot;10月&#123;&#125;日&quot;.format(i) for i in x_3]</span><br><span class="line">plt.xticks(x[::3], _xtick[::3], rotation=45, fontproperties=my_font)</span><br><span class="line">plt.xlabel(&quot;时间&quot;, fontproperties=my_font)</span><br><span class="line">plt.ylabel(&quot;温度&quot;, fontproperties=my_font)</span><br><span class="line">plt.title(&quot;标题&quot;, fontproperties=my_font)</span><br><span class="line">plt.legend(loc=&quot;upper left&quot;, prop=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120cabc50.png" alt="图片12.png"></p><h3 id="2-3条形图">2.3条形图</h3><p>eg:假设你获取到了2017年内地电影票房前20的电影(列表a)和电影票房数据(列表b),那么如何更加直观的展示该数据?</p><p>a = [“战狼2”,“速度与激情8”,“功夫瑜伽”,“西游伏妖篇”,“变形金刚5：最后的骑士”,“摔跤吧！爸爸”,“加勒比海盗5：死无对证”,“金刚：骷髅岛”,“极限特工：终极回归”,“生化危机6：终章”,“乘风破浪”,“神偷奶爸3”,“智取威虎山”,“大闹天竺”,“金刚狼3：殊死一战”,“蜘蛛侠：英雄归来”,“悟空传”,“银河护卫队2”,“情圣”,“新木乃伊”,]</p><p>b=[56.01,26.94,17.53,16.49,15.45,12.96,11.8,11.61,11.28,11.12,10.49,10.3,8.75,7.55,7.32,6.99,6.88,6.86,6.58,6.23] 单位:亿</p><p><img src="https://bu.dusays.com/2022/12/31/63b0120cc2aa6.png" alt="图片13.png"></p><p><mark>完整代码展示</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=&quot;C:/Windows/Fonts/SimHei.ttf&quot;, size=14)</span><br><span class="line">a = [&quot;战狼2&quot;, &quot;速度与激情8&quot;, &quot;功夫瑜伽&quot;, &quot;西游伏妖篇&quot;, &quot;变形金刚5：最后的骑士&quot;, &quot;摔跤吧！爸爸&quot;, &quot;加勒比海盗5：死无对证&quot;, &quot;金刚：骷髅岛&quot;, &quot;极限特工：终极回归&quot;, &quot;生化危机6：终章&quot;,</span><br><span class="line">     &quot;乘风破浪&quot;, &quot;神偷奶爸3&quot;, &quot;智取威虎山&quot;, &quot;大闹天竺&quot;, &quot;金刚狼3：殊死一战&quot;, &quot;蜘蛛侠：英雄归来&quot;, &quot;悟空传&quot;, &quot;银河护卫队2&quot;, &quot;情圣&quot;, &quot;新木乃伊&quot;, ]</span><br><span class="line"></span><br><span class="line">b = [56.01, 26.94, 17.53, 16.49, 15.45, 12.96, 11.8, 11.61, 11.28, 11.12, 10.49, 10.3, 8.75, 7.55, 7.32, 6.99, 6.88,</span><br><span class="line">     6.86, 6.58, 6.23]</span><br><span class="line">plt.figure(figsize=(20, 15), dpi=80)</span><br><span class="line">plt.bar(range(len(a)), b, width=0.3)</span><br><span class="line">plt.xticks(range(len(a)), a, rotation=90, fontproperties=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120cea641.png" alt="图片14.png"></p><p><mark>动手一练</mark></p><p>假设你知道了列表a中电影分别在2017-09-14(b_14), 2017-09-15(b_15), 2017-09-16(b_16)三天的票房,为了展示列表中电影本身的票房以及同其他电影的数据对比情况,应该如何更加直观的呈现该数据?</p><p>a = [“猩球崛起3：终极之战”,“敦刻尔克”,“蜘蛛侠：英雄归来”,“战狼2”]</p><p>b_16 = [15746,312,4497,319]</p><p>b_15 = [12357,156,2045,168]</p><p>b_14 = [2358,399,2358,362]</p><p><mark>代码展示</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=&quot;C:/Windows/Fonts/SimHei.ttf&quot;, size=14)</span><br><span class="line">a = [&quot;猩球崛起3：终极之战&quot;, &quot;敦刻尔克&quot;, &quot;蜘蛛侠：英雄归来&quot;, &quot;战狼2&quot;]</span><br><span class="line">b_16 = [15746, 312, 4497, 319]</span><br><span class="line">b_15 = [12357, 156, 2045, 168]</span><br><span class="line">b_14 = [2358, 399, 2358, 362]</span><br><span class="line">bar_width = 0.2</span><br><span class="line">x_14 = list(range(len(a)))</span><br><span class="line">x_15 = [i + bar_width for i in x_14]</span><br><span class="line">x_16 = [i + bar_width * 2 for i in x_14]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(20, 10), dpi=80)</span><br><span class="line">plt.bar(range(len(a)), b_14, width=bar_width, label=&quot;9月14日&quot;)</span><br><span class="line">plt.bar(x_15, b_15, width=bar_width, label=&quot;9月15日&quot;)</span><br><span class="line">plt.bar(x_16, b_16, width=bar_width, label=&quot;9月15日&quot;)</span><br><span class="line">plt.legend(prop=my_font)</span><br><span class="line">plt.xticks(x_15, a, fontproperties=my_font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120d17a0a.png" alt="图片15.png"></p><h3 id="2-4直方图">2.4直方图</h3><p>eg:假设你获取了250部电影的时长(列表a中),希望统计出这些电影时长的分布状态(比如时长为100分钟到120分钟电影的数量,出现的频率)等信息,你应该如何呈现这些数据?</p><p>a=[131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, 142, 127, 130, 124, 101, 110, 116, 117, 110, 128, 128, 115, 99, 136, 126, 134, 95, 138, 117, 111,78, 132, 124, 113, 150, 110, 117, 86, 95, 144, 105, 126, 130,126, 130, 126, 116, 123, 106, 112, 138, 123, 86, 101, 99, 136,123, 117, 119, 105, 137, 123, 128, 125, 104, 109, 134, 125, 127,105, 120, 107, 129, 116, 108, 132, 103, 136, 118, 102, 120, 114,105, 115, 132, 145, 119, 121, 112, 139, 125, 138, 109, 132, 134,156, 106, 117, 127, 144, 139, 139, 119, 140, 83, 110, 102,123,107, 143, 115, 136, 118, 139, 123, 112, 118, 125, 109, 119, 133,112, 114, 122, 109, 106, 123, 116, 131, 127, 115, 118, 112, 135,115, 146, 137, 116, 103, 144, 83, 123, 111, 110, 111, 100, 154,136, 100, 118, 119, 133, 134, 106, 129, 126, 110, 111, 109, 141,120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126,114, 140, 103, 130, 141, 117, 106, 114, 121, 114, 133, 137, 92,121, 112, 146, 97, 137, 105, 98, 117, 112, 81, 97, 139, 113,134, 106, 144, 110, 137, 137, 111, 104, 117, 100, 111, 101, 110,105, 129, 137, 112, 120, 113, 133, 112, 83, 94, 146, 133, 101,131, 116, 111, 84, 137, 115, 122, 106, 144, 109, 123, 116, 111,111, 133, 150]</p><p><img src="https://bu.dusays.com/2022/12/31/63b0120d4a7c7.png" alt="图片16.png"></p><p><mark>代码展示</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"></span><br><span class="line">my_font = font_manager.FontProperties(fname=&quot;C:/Windows/Fonts/SimHei.ttf&quot;, size=14)</span><br><span class="line">a = [131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, 142, 127, 130, 124,</span><br><span class="line">     101, 110, 116, 117, 110, 128, 128, 115, 99, 136, 126, 134, 95, 138, 117, 111, 78, 132, 124, 113, 150, 110, 117, 86,</span><br><span class="line">     95, 144, 105, 126, 130, 126, 130, 126, 116, 123, 106, 112, 138, 123, 86, 101, 99, 136, 123, 117, 119, 105, 137,</span><br><span class="line">     123, 128, 125, 104, 109, 134, 125, 127, 105, 120, 107, 129, 116, 108, 132, 103, 136, 118, 102, 120, 114, 105, 115,</span><br><span class="line">     132, 145, 119, 121, 112, 139, 125, 138, 109, 132, 134, 156, 106, 117, 127, 144, 139, 139, 119, 140, 83, 110, 102,</span><br><span class="line">     123, 107, 143, 115, 136, 118, 139, 123, 112, 118, 125, 109, 119, 133, 112, 114, 122, 109, 106, 123, 116, 131, 127,</span><br><span class="line">     115, 118, 112, 135, 115, 146, 137, 116, 103, 144, 83, 123, 111, 110, 111, 100, 154, 136, 100, 118, 119, 133, 134,</span><br><span class="line">     106, 129, 126, 110, 111, 109, 141, 120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126, 114, 140, 103,</span><br><span class="line">     130, 141, 117, 106, 114, 121, 114, 133, 137, 92, 121, 112, 146, 97, 137, 105, 98, 117, 112, 81, 97, 139, 113, 134,</span><br><span class="line">     106, 144, 110, 137, 137, 111, 104, 117, 100, 111, 101, 110, 105, 129, 137, 112, 120, 113, 133, 112, 83, 94, 146,</span><br><span class="line">     133, 101, 131, 116, 111, 84, 137, 115, 122, 106, 144, 109, 123, 116, 111, 111, 133, 150]</span><br><span class="line"># 计算组数</span><br><span class="line">d = 3</span><br><span class="line">num_bins = (max(a) - min(a)) // d</span><br><span class="line">plt.figure(figsize=(20, 15), dpi=80)</span><br><span class="line">plt.hist(a, num_bins, density=True)</span><br><span class="line">plt.xticks(range(min(a), max(a) + d, d))</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><mark>效果展示</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63b0120d5db0c.png" alt="图片17.png"></p><p><mark>matplotlib常见问题总结</mark></p><p>1.应该选择那种图形来呈现数据</p><p>2.matplotlib.plot(x,y)</p><p>3.matplotlib.bar(x,y)</p><p>4.matplotlib.scatter(x,y)</p><p>5.matplotlib.hist(data,bins,normed)</p><p>6.xticks和yticks的设置</p><p>7.label和titile,grid的设置</p><p>8.绘图的大小和保存图片</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt5.15.2中编译报错：“invalid use of incomplete type &#39;class Ui::xxx&#39;”的解决方法</title>
      <link href="/posts/c53a16ca.html"/>
      <url>/posts/c53a16ca.html</url>
      
        <content type="html"><![CDATA[<p>今天新建项目，用Qt连接数据库时，发现如下报错：</p><p><a href="https://bu.dusays.com/2022/12/31/63b0104259b03.png"><img src="https://bu.dusays.com/2022/12/31/63b0104259b03.png" alt="Snipaste_2022-07-17_20-10-30.png"></a></p><p>在网上找了很多解决方法，但是发现好像都不行，还是会报错，最后认真重新检查了一下文件，发现竟然是没有加头文件，然后把头文件</p><p>**#include “ui_mainwindow.h”**加上，如下图所示</p><p><a href="https://bu.dusays.com/2022/12/31/63b01057075ee.png"><img src="https://bu.dusays.com/2022/12/31/63b01057075ee.png" alt="Snipaste_2022-07-17_20-13-13.png"></a></p><p>然后再重新编译，成功运行</p><p><a href="https://bu.dusays.com/2022/12/31/63b0106e00925.png"><img src="https://bu.dusays.com/2022/12/31/63b0106e00925.png" alt="Snipaste_2022-07-17_20-19-19.png"></a></p><p>浪费了很多时间，特此记录</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>do{...}while(0)的妙用</title>
      <link href="/posts/4970cab7.html"/>
      <url>/posts/4970cab7.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzkwNzMwNzI1Ng==&amp;mid=2247483674&amp;idx=3&amp;sn=458052f964148f7f71d96c037b726635&amp;chksm=c0da708df7adf99b931f22a0e61251f6f0fcce5e8494d7c5911155ecffb0cfca8343241d71da&amp;token=2107487666&amp;lang=zh_CN#rd">原文地址</a></p><p>第一次见到 do{…}while(0)是在学习libevent的时候，看到里面有很多类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define TT_URI(want) do &#123; \</span><br><span class="line">char *ret = evhttp_uri_join(uri, url_tmp, sizeof(url_tmp));\</span><br><span class="line">tt_want(ret != NULL);\</span><br><span class="line">tt_want(ret == url_tmp);\</span><br><span class="line">if (strcmp(ret,want) != 0)\</span><br><span class="line">TT_FAIL((&quot;\&quot;%s\&quot; != \&quot;%s\&quot;&quot;,ret,want));\</span><br><span class="line">&#125; while(0)</span><br></pre></td></tr></table></figure><p>当时特别疑惑，do{…}while()不是做循环的吗，类似for,while的语法，不过现实开发中，用for和while的比较多，do{…}while()比较少了，算是比较不常用的语法。但是在这里，这样的代码一看就不是一个循环，do…while表面上在这里一点意义都没有，那么为什么要这么用呢？特别疑惑的google之，恍然大悟，原来do{…}while()还有此等妙用，看来自己还差得远啊。</p><p>总体来说，do{…}while(0)有两种用法。</p><h3 id="一-定义宏，实现局部作用域。"><strong>一.定义宏，实现局部作用域。</strong></h3><p>1.大家做c语言题目的时候，一道必考题就是 #define的算术运算。比如，我随手写一个最简单的#define</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define FUNC(x) x*3+4</span><br><span class="line">...</span><br><span class="line">int result = 2 * FUNC(3);</span><br></pre></td></tr></table></figure><p>result输出多少?  26？错！这是c语言新手一定会犯的错误，至少我第一次看到这，我就做错了。要知道这道题答案是多少，首先就要知道#define的作用。<br>1).#define M (a+b)　它的作用是指定标识符M来代替表达式(a+b)。在编写源程序时，所有的(a+b)都可由M代替，而对源程序作编译时，将先由预处理程序进行宏代换，即用(a+b)表达式去置换所有的宏名M，然后再进行编译。<br>2).c语言允许宏带有参数。在宏定义中的参数称为形式参数，在宏调用中的参数称为实际参数。对带参数的宏，在调用中，不仅要宏展开，而且要用实参去代换形参。(以上两句来自百度百科)</p><p>也就是 #define是在预处理的时候进行直接替换！(这句话是这一节的重点)<br>例如之上的展开就是.<br>int result = 2 * x * 3 + 4<br>x用实参3代替就是：<br>int result = 2 * 3 * 3 + 4 = 22而不是26.</p><p>有些人可能说，这些我都知道，这跟do{…}while(0)有什么关系。</p><p>其实，我只是为了告诉你，#define使用的时候要特别小心，尤其是#define一个很复杂的逻辑的时候。</p><p>我们举个简单的#define的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;print: &quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void send()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;&quot;send: &quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define LOG print();send();</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (false)</span><br><span class="line">LOG</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码输出什么?理论上，if(false)里面的代码不会被执行，也就是LOG不会被执行，所以只应该打印出&quot;hello world&quot;.</p><p>但是事实上：</p><p><img src="https://img-blog.csdn.net/20150424152000982" alt="01"></p><p>纳闷？</p><p>注意我上面说的一句话：</p><p>也就是 #define是在预处理的时候进行直接替换！(这句话是这一节的重点)</p><p>也就是说，上面的if(false)…在这里是：</p><pre><code>if (false)print();send(); cout &lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</code></pre><p>懂了吧。</p><p>怎么解决了，有些人马上想到，用{…}把#define 的值括住不就可以了。的确，在这里是可以的。</p><p>我们在写代码的时候都习惯在语句右面加上分号，如果在宏中使用{},我们通常会这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define LOG &#123;print();send();&#125;;</span><br></pre></td></tr></table></figure><p>当我们的if后面有一个else呢？</p><p>就变成了：</p><pre><code>if (false)&#123;print();send();&#125;;else&#123;cout &lt;&lt;&quot;hello&quot;&lt;&lt;endl;&#125;</code></pre><p>这样就会因为if语句后面多加了个;而编译不通过。不要说你说，那我不加;那要是你开发一个大型项目的时候你自己也不知道你自己要不要加;了，你就会被自己给绕晕了，所以统一的规范很重要。</p><p>那么来我们的最终版本：do{…}while(0);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define LOG do&#123;print();send();&#125;while (0);</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">if (false)</span><br><span class="line">LOG</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;&quot;hello&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">cout &lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就相当于：</p><pre><code>if (false)do&#123;print();send();&#125;while (0);else&#123;cout &lt;&lt;&quot;hello&quot;&lt;&lt;endl;&#125;cout &lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</code></pre><p>用do{…}while(0);包裹住要操作的#define,无论你外面怎么操作，都不会影响#define的操作。妙哉妙哉啊。</p><h3 id="二-替代goto">二.替代goto.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int dosomething()</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int clear()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int foo()</span><br><span class="line">&#123;</span><br><span class="line">int error = dosomething();</span><br><span class="line"></span><br><span class="line">if(error = 1)</span><br><span class="line">&#123;</span><br><span class="line">goto END;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if(error = 2)</span><br><span class="line">&#123;</span><br><span class="line">goto END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line">clear();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这只是一个简单的例子，有些人说，我可以不用goto，在每一个goto调用的地方直接，那么加一个判断，你就要加一条clear()，万一你漏了呢？而且正常情况下,foo里面的if有很多个，你要写很多goto,END里面的逻辑也更复杂。这样就更要小心。</p><p>由于goto不符合软件工程的结构化，而且有可能使得代码难懂，所以很多人都不倡导使用，那这个时候就可以用do{}while(0)来进行统一的管理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int foo()</span><br><span class="line">&#123;</span><br><span class="line">do </span><br><span class="line">&#123;</span><br><span class="line">int error = dosomething();</span><br><span class="line"></span><br><span class="line">if(error = 1)</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if(error = 2)</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (0);</span><br><span class="line"></span><br><span class="line">clear();</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是看起来好看多了，而且还避免了由于错误导致的严重bug（比如你在clear里面是清理内存的操作，你忘记了写goto，而走不到END里面）。</p><p>在do{…}while(0)里面，在任何地方都可以break跳出，然后继续下面的执行逻辑。即使你不写break，也会在执行完一遍do之后，while(0)不满足，自己跳出去。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC详解</title>
      <link href="/posts/e7035e9f.html"/>
      <url>/posts/e7035e9f.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1fy4y1b7TC/?spm_id_from=333.999.0.0&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><p><strong>前言</strong>：</p><ol><li class="lvl-3"><p><strong>GCC 编译器</strong>支持编译 Go、Objective-C，Objective-C ++，Fortran，Ada，D 和 BRIG（HSAIL）等程序；</p></li><li class="lvl-3"><p>Linux  开发C/C++ <strong>一定</strong>要熟悉 GCC</p></li><li class="lvl-3"><p><strong>VSCode是通过调用GCC编译器来实现C/C++的编译工作的；</strong></p></li></ol><p>实际使用中：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>使用 gcc 指令编译 C 代码</strong></p></li><li class="lvl-2"><p><strong>使用 g<ins>指令编译 C</ins> 代码</strong></p></li></ul><h3 id="1-编译过程">1. 编译过程</h3><ol><li class="lvl-3"><p><strong>预处理-Pre-Processing        //.i文件</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -E 选项指示编译器仅对输入文件进行预处理</span><br><span class="line">g++  -E  test.cpp  -o  test.i    //.i文件</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>编译-Compiling             // .s文件</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译</span><br><span class="line">#  g++ 产生的汇编语言文件的缺省扩展名是 .s </span><br><span class="line">g++  -S  test.i  -o   test.s</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>汇编-Assembling          // .o文件</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码</span><br><span class="line"># 缺省时 g++ 建立的目标代码文件有一个 .o 的扩展名。</span><br><span class="line">g++  -c  test.s  -o  test.o</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>链接-Linking            // bin文件</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -o 编译选项来为将产生的可执行文件用指定的文件名</span><br><span class="line">g++  test.o  -o  test</span><br></pre></td></tr></table></figure><h3 id="2-g-重要编译参数">2. g++重要编译参数</h3><ol><li class="lvl-3"><p><strong>-g</strong>   编译带调试信息的可执行文件</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -g 选项告诉 GCC 产生能被 GNU 调试器GDB使用的调试信息，以调试程序。</span><br><span class="line"></span><br><span class="line"># 产生带调试信息的可执行文件test</span><br><span class="line">g++ -g test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-O[n]</strong>   优化源代码</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## 所谓优化，例如省略掉代码中从未使用过的变量、直接将常量表达式用结果值代替等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。</span><br><span class="line"></span><br><span class="line"># -O 选项告诉 g++ 对源代码进行基本优化。这些优化在大多数情况下都会使程序执行的更快。 -O2 选项告诉 g++ 产生尽可能小和尽可能快的代码。 如-O2，-O3，-On（n 常为0–3）</span><br><span class="line"># -O 同时减小代码的长度和执行时间，其效果等价于-O1</span><br><span class="line"># -O0 表示不做优化</span><br><span class="line"># -O1 为默认优化</span><br><span class="line"># -O2 除了完成-O1的优化之外，还进行一些额外的调整工作，如指令调整等。</span><br><span class="line"># -O3 则包括循环展开和其他一些与处理特性相关的优化工作。</span><br><span class="line"># 选项将使编译的速度比使用 -O 时慢， 但通常产生的代码执行速度会更快。</span><br><span class="line"></span><br><span class="line"># 使用 -O2优化源代码，并输出可执行文件</span><br><span class="line">g++ -O2 test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-l  和  -L</strong>   指定库文件  |  指定库文件路径</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># -l参数(小写)就是用来指定程序要链接的库，-l参数紧接着就是库名</span><br><span class="line"># 在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接</span><br><span class="line"></span><br><span class="line"># 链接glog库</span><br><span class="line">g++ -lglog test.cpp</span><br><span class="line"></span><br><span class="line"># 如果库文件没放在上面三个目录里，需要使用-L参数(大写)指定库文件所在目录</span><br><span class="line"># -L参数跟着的是库文件所在的目录名</span><br><span class="line"></span><br><span class="line"># 链接mytest库，libmytest.so在/home/bing/mytestlibfolder目录下</span><br><span class="line">g++ -L/home/bing/mytestlibfolder -lmytest test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-I</strong>   指定头文件搜索目录</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -I </span><br><span class="line"># /usr/include目录一般是不用指定的，gcc知道去那里找，但 是如果头文件不在/usr/icnclude里我们就要用-I参数指定了，比如头文件放在/myinclude目录里，那编译命令行就要加上-I/myinclude 参数了，如果不加你会得到一个”xxxx.h: No such file or directory”的错误。-I参数可以用相对路径，比如头文件在当前 目录，可以用-I.来指定。上面我们提到的–cflags参数就是用来生成-I参数的。</span><br><span class="line"></span><br><span class="line">g++ -I/myinclude test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-Wall</strong>   打印警告信息</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 打印出gcc提供的警告信息</span><br><span class="line">g++ -Wall test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-w</strong>   关闭警告信息</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 关闭所有警告信息</span><br><span class="line">g++ -w test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-std=c++11</strong>   设置编译标准</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 c++11 标准编译 test.cpp</span><br><span class="line">g++ -std=c++11 test.cpp</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-o</strong>   指定输出文件名</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 指定即将产生的文件名</span><br><span class="line"></span><br><span class="line"># 指定输出可执行文件名为test</span><br><span class="line">g++ test.cpp -o test</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>-D</strong>   定义宏</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在使用gcc/g++编译的时候定义宏</span><br><span class="line"></span><br><span class="line"># 常用场景：</span><br><span class="line"># -DDEBUG 定义DEBUG宏，可能文件中有DEBUG宏部分的相关信息，用个DDEBUG来选择开启或关闭DEBUG</span><br></pre></td></tr></table></figure><p><strong>示例代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// -Dname 定义宏name,默认定义内容为字符串“1”</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   #ifdef DEBUG</span><br><span class="line">       printf(&quot;DEBUG LOG\n&quot;);</span><br><span class="line">   #endif</span><br><span class="line">       printf(&quot;in\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1. 在编译的时候，使用gcc -DDEBUG main.cpp</span><br><span class="line">// 2. 第七行代码可以被执行</span><br></pre></td></tr></table></figure><p>注：使用 <code>man gcc</code>命令可以查看gcc英文使用手册</p><h3 id="3-【实战】g-命令行编译">3 .【实战】g++命令行编译</h3><p>**案例：**最初目录结构: 2 directories, 3 files</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 最初目录结构</span><br><span class="line"></span><br><span class="line">├── include</span><br><span class="line">│   └── Swap.h</span><br><span class="line">├── main.cpp</span><br><span class="line">└── src</span><br><span class="line">    └── Swap.cpp</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br></pre></td></tr></table></figure><h4 id="3-1-直接编译">3.1 直接编译</h4><p><strong>最简单的编译，并运行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将 main.cpp src/Swap.cpp 编译为可执行文件</span><br><span class="line">g++ main.cpp src/Swap.cpp -Iinclude</span><br><span class="line"># 运行a.out</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure><p><strong>增加参数编译，并运行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将 main.cpp src/Swap.cpp 编译为可执行文件 附带一堆参数</span><br><span class="line">g++ main.cpp src/Swap.cpp -Iinclude -std=c++11 -O2 -Wall -o b.out</span><br><span class="line"># 运行 b.out</span><br><span class="line">./b.out</span><br></pre></td></tr></table></figure><h4 id="3-2-生成库文件并编译">3.2 生成库文件并编译</h4><p>链接<strong>静态库</strong>生成可执行文件①：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">## 进入src目录下</span><br><span class="line">$cd src</span><br><span class="line"></span><br><span class="line"># 汇编，生成Swap.o文件</span><br><span class="line">g++ Swap.cpp -c -I../include</span><br><span class="line"># 生成静态库libSwap.a</span><br><span class="line">ar rs libSwap.a Swap.o</span><br><span class="line"></span><br><span class="line">## 回到上级目录</span><br><span class="line">$cd ..</span><br><span class="line"></span><br><span class="line"># 链接，生成可执行文件:staticmain</span><br><span class="line">g++ main.cpp -Iinclude -Lsrc -lSwap -o staticmain</span><br></pre></td></tr></table></figure><p>链接<strong>动态库</strong>生成可执行文件②：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">## 进入src目录下</span><br><span class="line">$cd src</span><br><span class="line"></span><br><span class="line"># 生成动态库libSwap.so</span><br><span class="line">g++ Swap.cpp -I../include -fPIC -shared -o libSwap.so</span><br><span class="line">## 上面命令等价于以下两条命令</span><br><span class="line"># gcc Swap.cpp -I../include -c -fPIC</span><br><span class="line"># gcc -shared -o libSwap.so Swap.o</span><br><span class="line"></span><br><span class="line">## 回到上级目录</span><br><span class="line">$cd ..</span><br><span class="line"></span><br><span class="line"># 链接，生成可执行文件:sharemain</span><br><span class="line">g++ main.cpp -Iinclude -Lsrc -lSwap -o sharemain</span><br></pre></td></tr></table></figure><p><strong>编译完成后的目录结构</strong></p><p>最终目录结构：2 directories, 8 files</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 最终目录结构</span><br><span class="line"></span><br><span class="line">├── include</span><br><span class="line">│   └── Swap.h</span><br><span class="line">├── main.cpp</span><br><span class="line">├── sharemain</span><br><span class="line">├── src</span><br><span class="line">│   ├── libSwap.a</span><br><span class="line">│   ├── libSwap.so</span><br><span class="line">│   ├── Swap.cpp</span><br><span class="line">│   └── Swap.o</span><br><span class="line">└── staticmain</span><br><span class="line"></span><br><span class="line">2 directories, 8 files</span><br></pre></td></tr></table></figure><h4 id="3-3-运行可执行文件">3.3 运行可执行文件</h4><p>运行可执行文件①</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 运行可执行文件</span><br><span class="line">./staticmain</span><br></pre></td></tr></table></figure><p>运行可执行文件②</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 运行可执行文件</span><br><span class="line">LD_LIBRARY_PATH=src ./sharemain</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake详解</title>
      <link href="/posts/3976864f.html"/>
      <url>/posts/3976864f.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1fy4y1b7TC/?spm_id_from=333.999.0.0&amp;vd_source=2896408aa1ddac57180818bd00dd8b57">视频教程</a></p><h3 id="1-前言：">1.前言：</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>CMake</strong>是一个<strong>跨平台</strong>的安装<strong>编译工具</strong>，可以用<strong>简单</strong>的语句来描述<strong>所有平台</strong>的安装(编译过程)。</p></li><li class="lvl-2"><p>CMake可以说已经成为<strong>大部分C++开源项目标配</strong></p></li></ul><h3 id="2-语法特性介绍">2. 语法特性介绍</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>基本语法格式：指令(参数 1 参数 2…)</strong></p><ul class="lvl-2"><li class="lvl-4">参数使用<strong>括弧</strong>括起</li></ul><ul class="lvl-2"><li class="lvl-4"><p>参数之间使用<strong>空格</strong>或<strong>分号</strong>分开</p></li></ul></li><li class="lvl-2"><p><strong>指令是大小写无关的，参数和变量是大小写相关的</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(HELLO hello.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cpp hello.cpp)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.cpp <span class="variable">$&#123;HELLO&#125;</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</strong></p></li></ul><h3 id="3-重要指令和CMake常用变量">3. 重要指令和CMake常用变量</h3><h4 id="3-1-重要指令">3.1 重要指令</h4><ul class="lvl-0"><li class="lvl-2"><p><mark><strong>cmake_minimum_required</strong></mark> <strong>- 指定CMake的最小版本要求</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>cmake_minimum_required(VERSION versionNumber [FATAL_ERROR])</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake最小版本要求为2.8.3</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><mark><strong>project</strong></mark> <strong>- 定义工程名称，并可指定工程支持的语言</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>project(projectname [CXX] [C] [Java])</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定工程名为HELLOWORLD</span></span><br><span class="line"><span class="keyword">project</span>(HELLOWORLD)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><mark><strong>set</strong></mark> <strong>- 显式的定义变量</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>set(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义SRC变量，其值为main.cpp hello.cpp</span></span><br><span class="line"><span class="keyword">set</span>(SRC sayhello.cpp hello.cpp)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><mark><strong>include_directories</strong></mark> <strong>- 向工程添加多个特定的头文件搜索路径</strong> —&gt;相当于指定g++编译器的-I参数</p><ul class="lvl-2"><li class="lvl-4">语法：<strong>include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将/usr/include/myincludefolder 和 ./include 添加到头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(/usr/<span class="keyword">include</span>/myincludefolder ./<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><mark><strong>link_directories</strong></mark> <strong>- 向工程添加多个特定的库文件搜索路径</strong> —&gt;相当于指定g++编译器的-L参数</p><ul class="lvl-2"><li class="lvl-4">语法：**link_directories(dir1 dir2 …) **</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(/usr/lib/mylibfolder ./lib)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong><mark>add_library</mark></strong> <strong>- 生成库文件</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 … sourceN)</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过变量 SRC 生成 libhello.so 共享库</span></span><br><span class="line"><span class="keyword">add_library</span>(hello SHARED <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong><mark>add_compile_options</mark></strong> - 添加编译参数</p><ul class="lvl-2"><li class="lvl-4">语法：<strong>add_compile_options(</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加编译参数 -Wall -std=c++11</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-Wall -std=c++<span class="number">11</span> -O2)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong><mark>add_executable</mark></strong> <strong>- 生成可执行文件</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>add_library(exename source1 source2 … sourceN)</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译main.cpp生成可执行文件main</span></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong><mark>target_link_libraries</mark></strong> - 为 target 添加需要链接的共享库  —&gt;相同于指定g++编译器-l参数</p><ul class="lvl-2"><li class="lvl-4">语法：<strong>target_link_libraries(target library1library2…)</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将hello动态库文件链接到可执行文件main</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main hello)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong><mark>add_subdirectory</mark> - 向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加src子目录，src中需有一个CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>aux_source_directory - 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表</strong></p><ul class="lvl-2"><li class="lvl-4">语法：<strong>aux_source_directory(dir VARIABLE)</strong></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义SRC变量，其值为当前目录下所有的源代码文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC)</span><br><span class="line"><span class="comment"># 编译SRC变量所代表的源代码文件，生成main可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-CMake常用变量">3.2 CMake常用变量</h4><ul class="lvl-0"><li class="lvl-2"><p><strong><mark>CMAKE_C_FLAGS</mark>  gcc编译选项</strong></p></li><li class="lvl-2"><p><strong><mark>CMAKE_CXX_FLAGS</mark>  g++编译选项</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在CMAKE_CXX_FLAGS编译选项后追加-std=c++11</span><br><span class="line">set( CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong><mark>CMAKE_BUILD_TYPE</mark>  编译类型(Debug, Release)</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 设定编译类型为debug，调试时需要选择debug</span><br><span class="line">set(CMAKE_BUILD_TYPE Debug) </span><br><span class="line"># 设定编译类型为release，发布时需要选择release</span><br><span class="line">set(CMAKE_BUILD_TYPE Release) </span><br></pre></td></tr></table></figure><blockquote><p><strong>CMAKE_BINARY_DIR</strong></p><p><strong>PROJECT_BINARY_DIR</strong></p><p><strong>__BINARY_DIR</strong></p></blockquote><ol><li class="lvl-3"><p>这三个变量指代的内容是一致的。</p></li><li class="lvl-3"><p>如果是 in source build，指的就是工程顶层目录。</p></li><li class="lvl-3"><p>如果是 out-of-source 编译,指的是工程编译发生的目录。</p></li><li class="lvl-3"><p>PROJECT_BINARY_DIR 跟其他指令稍有区别，不过现在，你可以理解为他们是一致的。</p></li></ol><blockquote><p><strong>CMAKE_SOURCE_DIR</strong></p><p><strong>PROJECT_SOURCE_DIR</strong><br><strong>__SOURCE_DIR</strong></p></blockquote><ol><li class="lvl-3"><p>这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录。</p></li><li class="lvl-3"><p>也就是在 in source build时,他跟 CMAKE_BINARY_DIR 等变量一致。</p></li><li class="lvl-3"><p>PROJECT_SOURCE_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><strong>CMAKE_C_COMPILER：指定C编译器</strong></p></li><li class="lvl-2"><p><strong>CMAKE_CXX_COMPILER：指定C++编译器</strong></p></li><li class="lvl-2"><p><strong>EXECUTABLE_OUTPUT_PATH：可执行文件输出的存放路径</strong></p></li><li class="lvl-2"><p><strong>LIBRARY_OUTPUT_PATH：库文件输出的存放路径</strong></p></li></ul><h3 id="4-CMake编译工程">4. CMake编译工程</h3><p>CMake目录结构：项目主目录存在一个CMakeLists.txt文件</p><p><strong>两种方式设置编译规则</strong>：</p><ol><li class="lvl-3"><p>包含源文件的子文件夹包含CMakeLists.txt文件，主目录的CMakeLists.txt通过add_subdirectory添加子目录即可；</p></li><li class="lvl-3"><p>包含源文件的子文件夹未包含CMakeLists.txt文件，子目录编译规则体现在主目录的CMakeLists.txt中；</p></li></ol><h4 id="4-1-编译流程">4.1 编译流程</h4><p><strong>在 linux 平台下使用 CMake 构建C/C++工程的流程如下:</strong></p><ul class="lvl-0"><li class="lvl-2"><p>手动编写 CmakeLists.txt。</p></li><li class="lvl-2"><p>执行命令 <code>cmake PATH</code>生成 Makefile ( PATH 是顶层CMakeLists.txt 所在的目录 )。</p></li><li class="lvl-2"><p>执行命令<code>make</code> 进行编译。</p></li></ul><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">important tips</span></span><br><span class="line">.          # 表示当前目录</span><br><span class="line">./         # 表示当前目录</span><br><span class="line"></span><br><span class="line">..      # 表示上级目录</span><br><span class="line">../     # 表示上级目录</span><br></pre></td></tr></table></figure><hr><h4 id="6-4-2-两种构建方式">6.4.2 两种构建方式</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>内部构建(in-source build)</strong>：不推荐使用</p><p>内部构建会在同级目录下产生一大堆中间文件，这些中间文件并不是我们最终所需要的，和工程源文件放在一起会显得杂乱无章。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 内部构建</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录下，编译本目录的CMakeLists.txt，生成Makefile和其他文件</span></span><br><span class="line">cmake .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行make命令，生成target</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>外部构建(out-of-source build)</strong>：<mark>推荐使用</mark></p><p>将编译输出文件与源文件放到不同目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 外部构建</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 在当前目录下，创建build文件夹</span></span><br><span class="line">mkdir build </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 进入到build文件夹</span></span><br><span class="line">cd build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 编译上级目录的CMakeLists.txt，生成Makefile和其他文件</span></span><br><span class="line">cmake ..</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 执行make命令，生成target</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-【实战】CMake代码实践">5. 【实战】CMake代码实践</h3><h4 id="5-1-最小CMake工程">5.1 最小CMake工程</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the minimum version of CMake that can be used</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the project name</span></span><br><span class="line"><span class="keyword">project</span> (HELLO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add an executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello_cmake main.cpp)</span><br></pre></td></tr></table></figure><h4 id="5-2-多目录工程-直接编译">5.2 多目录工程 - 直接编译</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the minimum version of CMake that can be used</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#project name</span></span><br><span class="line"><span class="keyword">project</span>(SWAP)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#head file pat</span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="keyword">include</span> )</span><br><span class="line"> </span><br><span class="line"><span class="comment">#source directory files to var</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>( src DIR_SRCS )</span><br><span class="line"></span><br><span class="line"><span class="comment">#add executable file  </span></span><br><span class="line"><span class="keyword">add_executable</span>(swap_02 <span class="variable">$&#123;TEST_MATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#add link library  </span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;FS_BUILD_BINARY_PREFIX&#125;</span>sqrt <span class="variable">$&#123;LIBRARIES&#125;</span>) </span><br></pre></td></tr></table></figure><h4 id="6-5-3-多目录工程-生成库编译">6.5.3 多目录工程 - 生成库编译</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the minimum version of CMake that can be used</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#project name  </span></span><br><span class="line"><span class="keyword">project</span>(SWAP_LIBRARY)</span><br><span class="line"></span><br><span class="line"><span class="comment">#add compile options</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;-Wall -std=c++11&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#set CMAKE_BUILD_TYPE</span></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE Debug ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># set output binary path  </span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># Create a library</span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Generate the static library from the library sources</span></span><br><span class="line"><span class="keyword">add_library</span>( swap_library STATIC src/Swap.cpp )</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>( swap_lib PUBLIC <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># Create an executable</span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add an executable with the above sources</span></span><br><span class="line"><span class="keyword">add_executable</span>( swap_01 main.cpp )</span><br><span class="line"></span><br><span class="line"><span class="comment"># link the new swap_01 target with the swap_lib target</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( swap_01 swap_liby )</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Json+Shell联合使用</title>
      <link href="/posts/2f2b7b43.html"/>
      <url>/posts/2f2b7b43.html</url>
      
        <content type="html"><![CDATA[<p>json文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;options&quot;: &#123;</span><br><span class="line">        &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;/build&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;cmake&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cmake&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;..&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;make&quot;,</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: &quot;true&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;command&quot;: &quot;make -j12&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;Build&quot;,</span><br><span class="line">            &quot;dependsOn&quot;:[</span><br><span class="line">                &quot;cmake&quot;,</span><br><span class="line">                &quot;make&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;inputs&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;promptString&quot;,</span><br><span class="line">          &quot;id&quot;: &quot;commitInfo&quot;,</span><br><span class="line">          &quot;description&quot;: &quot;输入commit信息&quot;,</span><br><span class="line">          &quot;default&quot;: &quot;default information&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;提交代码&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;./push.sh&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;$&#123;input:commitInfo&#125;&quot;//inputs中的id</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &quot;test&quot;,</span><br><span class="line">            &quot;presentation&quot;: &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>shell脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -am $1</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode 调试教程 tasks.json和launch.json的设置</title>
      <link href="/posts/804002d4.html"/>
      <url>/posts/804002d4.html</url>
      
        <content type="html"><![CDATA[<p><strong>运行环境：</strong></p><p>VSCode 1.68.1</p><p>wsl：ubuntu子系统</p><p><img src="https://bu.dusays.com/2022/12/31/63affe9d58d5d.png" alt="debug.png"></p><p>废话不多说，直接开整，首先选择左侧任务栏的第四个选项<mark>运行和调试</mark>，点击创建launch.json</p><p><img src="https://bu.dusays.com/2022/12/31/63affeb0da4ac.png" alt="addconfig.png"></p><p>创建好的界面如上图所示。点击右下角的添加配置</p><p><img src="https://bu.dusays.com/2022/12/31/63affec35aae7.png" alt="addgdb.png">此时如上图所示，选择第一个<mark>c/c++(gdb)启动</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63affedb8b071.png" alt="改目录.png"></p><p>此时会生成如上图所示代码，注意我画箭头的这两个地方，那个cwd是我们当前文件所在的工作目录，把画箭头的这两个地方改成一样的</p><p><img src="https://bu.dusays.com/2022/12/31/63affeefa07c4.png" alt="改名字.png"></p><p>改完后如上图所示，后面的a.out是我们一会儿要调试的可执行文件名称，这里用系统生成的也行，改成自己的也行，接下来我们开始配置tasks.json</p><p><img src="https://bu.dusays.com/2022/12/31/63afff0234ac7.png" alt="生成task.png"></p><p>首先回到main.cpp，然后点击上方菜单栏的终端，选择最后一个<mark>配置默认生成任务</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63afff1345fea.png" alt="g++.png"></p><p>此时如上如所示，再选择第二个<mark>c/c++:g++生成活动文件</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63afff24c1d74.png" alt="初始化的tasks.png"></p><p>此时如上图所示，生成tasks.json,接着我们打开launch.json做一个比较，我们先在launch.json后面加一行代码&quot;prelaunchTask&quot;,这行代码意思就是在launch之前运行的任务名，这个名字一定要跟tasks.json中的任务名字写一致，如下图所示，tasks.json中的label要和launch.json中的prelaunchTask完全一致，因为在执行launch.json之前系统会根据这行代码先去执行tasks.json中的内容，可以简单理解为tasks.json中的代码会帮我们用g++/gcc编译生成可执行文件，而launch.json中的代码是让系统来调试我们的可执行文件。</p><p><img src="https://bu.dusays.com/2022/12/31/63afff3d70382.png" alt="Snipaste_2022-07-07_11-00-37.png"></p><p>接下来看到tasks.json中的文件，如下图所示，其中的command 配置 , 是指定编译器 , 一般是 gcc 或者 g++ 编译器 ，接着下面的args是编译器后的编译选项，注意这个-g意思就是编译出带调试信息的可执行文件，如果少了这个-g，生成的可执行文件就不能够调试了，下面的main.cpp和swap.cpp是要编译的文件名，-0参数指定生成可执行文件的名字，下一行就是生成可执行文件的位置在当前的工作目录，名字叫a.out</p><p><img src="https://bu.dusays.com/2022/12/31/63afff4e70efe.png" alt="Snipaste_2022-07-07_15-37-53.png"></p><p>大家注意，文中的画箭头部分，这两个起的名字要一样，左边的是生成可执行文件叫a.out右边的是调试的文件叫a.out，名字可以自己更换</p><p>所以tasks.json实际上就相当于帮我们完成了<mark>g++ -g main.cpp swap.cpp -o a.out</mark>的功能</p><p><img src="https://bu.dusays.com/2022/12/31/63afff6322ee7.png" alt="Snipaste_2022-07-07_15-47-13.png"></p><p>配置好上面的文件后，回到main.cpp设置自己的断点，然后按F5键进行调试，成功啦</p><p><img src="https://bu.dusays.com/2022/12/31/63afff82eabb1.png" alt="Snipaste_2022-07-07_11-00-56.png"></p>]]></content>
      
      
      <categories>
          
          <category> VScode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> Json </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ mutable关键字</title>
      <link href="/posts/3afa66e.html"/>
      <url>/posts/3afa66e.html</url>
      
        <content type="html"><![CDATA[<p>mutalbe的中文意思是“可变的，易变的”，跟constant（既C++ 中的const）是反义词。</p><p>在C++ 中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。</p><p>我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。</p><p>下面是一个小例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class  ClxTest</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">     void  Output()  const ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void  ClxTest::Output()  const</span><br><span class="line">&#123;</span><br><span class="line">    cout  &lt;&lt;   &quot; Output for test! &quot;   &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  OutputTest( const  ClxTest &amp;  lx)</span><br><span class="line">&#123;</span><br><span class="line">    lx.Output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    类ClxTest的成员函数Output是用来输出的，不会修改类的状态，所以被声明为const的。​    函数OutputTest也是用来输出的，里面调用了对象lx的Output输出方法，为了防止在函数中调用其他成员函数修改任何成员变量，所以参数也被const修饰。​    如果现在，我们要增添一个功能：计算每个对象的输出次数。如果用来计数的变量是普通的变量的话，那么在const成员函数Output里面是不能修改该变量的值的；而该变量跟对象的状态无关，所以应该为了修改该变量而去掉Output的const属性。这个时候，就该我们的mutable出场了——只要用mutalbe来修饰这个变量，所有问题就迎刃而解了。​    下面是修改过的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class  ClxTest</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">    ClxTest();</span><br><span class="line">     ~ ClxTest();</span><br><span class="line"></span><br><span class="line">     void  Output()  const ;</span><br><span class="line">     int  GetOutputTimes()  const ;</span><br><span class="line"></span><br><span class="line">private :</span><br><span class="line">    mutable  int  m_iTimes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ClxTest::ClxTest()</span><br><span class="line">&#123;</span><br><span class="line">    m_iTimes  =   0 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClxTest:: ~ ClxTest()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  ClxTest::Output()  const</span><br><span class="line">&#123;</span><br><span class="line">    cout  &lt;&lt;   &quot; Output for test! &quot;   &lt;&lt;  endl;</span><br><span class="line">    m_iTimes ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int  ClxTest::GetOutputTimes()  const</span><br><span class="line">&#123;</span><br><span class="line">     return  m_iTimes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  OutputTest( const  ClxTest &amp;  lx)</span><br><span class="line">&#123;</span><br><span class="line">    cout  &lt;&lt;  lx.GetOutputTimes()  &lt;&lt;  endl;</span><br><span class="line"></span><br><span class="line">    lx.Output();</span><br><span class="line">    </span><br><span class="line">    cout  &lt;&lt;  lx.GetOutputTimes()  &lt;&lt;  endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    计数器m_iTimes被mutable修饰，那么它就可以突破const的限制，在被const修饰的函数里面也能被修改。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Lambda表达式</title>
      <link href="/posts/74cd693d.html"/>
      <url>/posts/74cd693d.html</url>
      
        <content type="html"><![CDATA[<p>Lambda函数也叫匿名函数，是自定义函数的一种,专指用关键字” lambda”定义的无名短函数，所以也有Lambda表达式这种说法。这种函数得名于省略了用def声明函数的标准步骤，是C++ 11中新增的特性。</p><h2 id="一-函数语法">一 .函数语法</h2><p>我们平时调用函数的时候，都是需要被调用函数的函数名，但是匿名函数就不需要函数名，而且直接写在需要调用的地方，对于以前没用过的小伙伴来说，第一眼看见了这语法可能很迷惑。</p><h3 id="C-11的基本语法格式：">C++11的基本语法格式：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>（1） [capture] ：[]内为外部变量的传递方式，值、引用等，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]        <span class="comment">//表示的是在lambda定义之前的域，对外部参数的调用；</span></span><br><span class="line">[=]       <span class="comment">//表示外部参数直接传值</span></span><br><span class="line">[&amp;]       <span class="comment">//表示外部参数传引用，可修改值。当默认捕获符是 &amp; 时，后继的简单捕获符必须不以 &amp; 开始。而当默认捕获符是 = 时，后继的简单捕获符必须以 &amp; 开始。</span></span><br><span class="line">[x, &amp;y]   <span class="comment">//x is captured by value, y is captured by reference</span></span><br><span class="line">[&amp;, x]    <span class="comment">//x is explicitly captured by value. Other variables will be captured by reference</span></span><br><span class="line">[=, &amp;z]   <span class="comment">//z is explicitly captured by reference. Other variables will be captured by value</span></span><br></pre></td></tr></table></figure><p>（2）(parameters) ：（）内为形参，和普通函数的形参一样。（3）-&gt; return_type：-&gt;后面为lambda函数的返回类型，如 -&gt; int、-&gt; string等。一般情况下，编译器推出lambda函数的返回值，所以这部分可以省略不写。（4）{ /* … */ }：{}内为函数主体，和普通函数一样。</p><h3 id="修饰符">修饰符</h3><p>这一部分是可以省略的，常见的修饰符有两个，一个是mutable，另一个是exception</p><p>mutable：当函数参数以值引用传递方式传递时，在函数体内是不可以修改该函数参数的值的，我们可以使用mutable修饰符，使得该函数参数可以在函数体内改变，下面我们实验一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> test = [x] () &#123; x++; &#125;;</span><br><span class="line"><span class="built_in">test</span>();</span><br></pre></td></tr></table></figure><p>这样会报错，参数x是值传递的方式，是一个只读变量，但是我们加入mutable后，就不会报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> test = [x] () <span class="keyword">mutable</span> &#123; x++; cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;;</span><br><span class="line"><span class="built_in">test</span>();cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这样我们就过了编译，不妨猜猜输出结果，是2 2还是2 1呢？</p><p>答案是2 1，注意上边加黑的字体：被mutable修饰的函数参数，该函数参数可以在函数体内改变，也就是说不会改变函数体外该变量的值，我们也可以理解为在函数体内拷贝了这个变量的同名变量。</p><p>exception：exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。</p><h2 id="二-函数应用">二. 函数应用</h2><h3 id="1、在普通函数中使用">1、在普通函数中使用</h3><p>首先是定义，执行下面这句，不会运行函数 ！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; addFunction= [](<span class="type">int</span> a,<span class="type">int</span> b) -&gt;<span class="type">int</span> &#123;  <span class="keyword">return</span> a + b;   &#125;;</span><br></pre></td></tr></table></figure><p>上面代码，你知道lambda函数返回类型为int类型，但是函数左边不能直接赋值给int变量（编译器会报错），因为此处为lambda函数的定义，所以左边为函数指针类型变量，一般懒得写函数指针类型，就直接赋值给auto类型变量，如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> addFunction = [](<span class="type">int</span> a,<span class="type">int</span> b) -&gt;<span class="type">int</span> &#123;  <span class="keyword">return</span> a + b;   &#125;;</span><br></pre></td></tr></table></figure><p>下面才是函数的使用、运行！！！如何运行lambda函数并获取函数返回值？执行函数需要看下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> addFunction= [](<span class="type">int</span> a,<span class="type">int</span> b) -&gt;<span class="type">int</span> &#123;  <span class="keyword">return</span> a + b;   &#125;;</span><br><span class="line"><span class="type">int</span> result  = <span class="built_in">addFunction</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>又或者如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> addFunction= [](<span class="type">int</span> a,<span class="type">int</span> b) -&gt;<span class="type">int</span> &#123;  <span class="keyword">return</span> a + b;   &#125;;</span><br><span class="line"><span class="built_in">int</span>(*func_ptr)(<span class="type">int</span>,<span class="type">int</span>) = addFunction;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">func_ptr</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="2、在qt信号槽绑定中使用">2、在qt信号槽绑定中使用</h3><p>我觉得labmda函数非常适合在信号槽中使用。（1）返回的函数指针可以直接用在connect函数中，刚好契合。（2）该槽函数可能比较简单，只有这个地方使用，可以省去槽函数声明，使代码看上去更加简便，且业务代码更加集中。</p><h4 id="基本使用">基本使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sys, &amp;SYSClass::sig_1, <span class="keyword">this</span>, [=](<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>绑定信号槽的时候定义lambda函数，当收到信号的时候才执行槽函数，即lambda函数。使用示范在mTime时间后执行动画，动画执行后delete对象，非常适合弹窗关闭时，窗口关闭的动画操作。（widgetPtr为弹窗的指针）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QTimer::<span class="built_in">singleShot</span>(mTime,widgetPtr,[=]()</span><br><span class="line">&#123;</span><br><span class="line">    QPropertyAnimation *pAnimation = <span class="keyword">new</span> <span class="built_in">QPropertyAnimation</span>(widgetPtr,<span class="string">&quot;windowOpacity&quot;</span>,widgetPtr);</span><br><span class="line">    pAnimation-&gt;<span class="built_in">setDuration</span>(<span class="number">1000</span>);</span><br><span class="line">    pAnimation-&gt;<span class="built_in">setEasingCurve</span>(QEasingCurve::InCirc);</span><br><span class="line">    pAnimation-&gt;<span class="built_in">setStartValue</span>(<span class="number">1.0</span>);</span><br><span class="line">    pAnimation-&gt;<span class="built_in">setEndValue</span>(<span class="number">0.0</span>);</span><br><span class="line">    pAnimation-&gt;<span class="built_in">start</span>();</span><br><span class="line">    <span class="built_in">connect</span>(pAnimation,&amp;QPropertyAnimation::finished,[=]&#123;</span><br><span class="line">        <span class="keyword">delete</span> widgetPtr;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3、在函数回调中使用（std-sort排序函数为例子）">3、在函数回调中使用（std::sort排序函数为例子）</h3><p>在标准库的排序函数使用中，可以使用函数回调的方式自定义排序的比较规则。（1）sort函数提供排序算法；（2）floatList为容器变量，提供数据结构和数据；（3）他们两个之间使用迭代器连接。理解如下图：</p><p>而我们sort函数可以使用第三个参数（函数回调方式）作为比较依据进行排序，该参数就可以写成lambda函数，这样比较方法写在排序函数这里，可以使得代码更加直白、简便、集中。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>( floatList, floatList + N, [](<span class="type">float</span> a, <span class="type">float</span> b) </span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>上面lambda函数，是sort函数中的迭代器每次运行做排序比较的时候就调用。</p><h4 id="注意：">注意：</h4><p>（1）lambda函数参数为（ float , float ），类型必须与容器的元素类型一致。（2）运行时，迭代器自动帮你把参数传入回调函数。（3）回调函数返回值固定为bool，这里可以不写，由编译器自动确定。</p><h2 id="三-总结">三 .总结</h2><p>lambda函数定义后返回的是函数指针类型，即如：std::function&lt;int(int,int)&gt;，所以一般很少使用，我们在很多代码中也很少看到。正常情况下，lambda函数相对普通函数的定义和使用其实没什么优势。但是某些使用到函数指针的场合下，我们就可以酌情考虑使用，特别是函数指针作为函数参数的时候，比如qt的信号槽、回调函数等，使用起来即方便，又显得代码高大上，简直就完美O(∩_∩)O。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode中文乱码问题的解决</title>
      <link href="/posts/af899832.html"/>
      <url>/posts/af899832.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/Staokgo/article/details/124897213">原文地址</a></p><p>一开始为了解决这个问题查了很多文章，有方法：0、先在命令行执行 chcp 65001（换成utf-8编码） 再运行程序的（但不能一劳永逸）；1、修改 VsCode 的 settings.json 的；2、还有修改系统注册表的；3、还有修改系统全局字符编码为 utf-8 的。比如下面的链接等等：</p><p>我试了试确实如文内所说的，都副作用很大，尤其是第二个链接里面的，系统目录、包括压缩文件和解压的时候，中文会乱码，得不偿失。</p><p>我转念一闪，在程序开头加一个 system() 执行 chcp 65001（换成utf-8编码） 不就每次执行程序都能在命令行正确打印中文了嘛-.-</p><p>本来程序的打印效果：</p><p><img src="https://img-blog.csdnimg.cn/d8e4f2e970ae4dd0980f6f2b96b3ba97.png" alt="img"></p><p>然后在自己的程序最前面加上这段话（紧跟着 main() 的后面第一句话就执行下面这句）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(&quot;chcp 65001&quot;); /* cmd chcp 命令切换字符编码为 utf-8 以显示中文 */</span><br></pre></td></tr></table></figure><p>加上之后，程序的打印效果：</p><p><img src="https://img-blog.csdnimg.cn/99a1855bbf60495bbaa2223e12e3beba.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> VScode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数指针</title>
      <link href="/posts/e3c1df92.html"/>
      <url>/posts/e3c1df92.html</url>
      
        <content type="html"><![CDATA[<p>最近遇到了函数指针的内容，有部分遗忘，经过复习巩固后，写下这篇博客，方便以后查看</p><p><strong>函数指针基础：</strong></p><p>1.获取函数的地址</p><p>2.声明一个函数指针</p><p>3.使用函数指针来调用函数</p><p><strong>获取函数指针：</strong></p><p>函数的地址就是函数名，要将函数作为参数进行传递，必须传递函数名。</p><p><strong>声明函数指针</strong></p><p>声明指针时，必须指定指针指向的数据类型，同样，声明指向函数的指针时，必须指定指针指向的函数类型，这意味着声明应当指定函数的返回类型以及函数的参数列表。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cal</span><span class="params">(<span class="type">int</span>)</span></span>;   <span class="comment">// prototype</span></span><br><span class="line"><span class="built_in">double</span> (*pf)(<span class="type">int</span>);   <span class="comment">// 指针pf指向的函数， 输入参数为int,返回值为double </span></span><br><span class="line">pf = cal;    <span class="comment">// 指针赋值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (Teacher:: *teacherSignal)(QString) = &amp;Teacher::hungry; <span class="comment">//定义函数指  teacherSignal指向函数hungry，并接受一个QString类型的参数</span></span><br><span class="line"><span class="built_in">connect</span>(zt, teacherSignal, st, studentSlot);</span><br></pre></td></tr></table></figure><p>如果将指针作为函数的参数传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate</span><span class="params">(<span class="type">int</span> lines, <span class="type">double</span> (*pf)(<span class="type">int</span>))</span></span>;  <span class="comment">// 函数指针作为参数传递 </span></span><br></pre></td></tr></table></figure><p>使用指针调用函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> y = <span class="built_in">cal</span>(<span class="number">5</span>);   <span class="comment">// 通过函数调用</span></span><br><span class="line"><span class="type">double</span> y = (*pf)(<span class="number">5</span>);   <span class="comment">// 通过指针调用 推荐的写法 </span></span><br><span class="line"><span class="type">double</span> y = <span class="built_in">pf</span>(<span class="number">5</span>);     <span class="comment">// 这样也对， 但是不推荐这样写</span></span><br></pre></td></tr></table></figure><p>函数指针的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cal_m1</span><span class="params">(<span class="type">int</span> lines)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.05</span> * lines;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cal_m2</span><span class="params">(<span class="type">int</span> lines)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.5</span> * lines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate</span><span class="params">(<span class="type">int</span> line_num, <span class="type">double</span> (*pf)(<span class="type">int</span> lines))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The &quot;</span> &lt;&lt; line_num &lt;&lt; <span class="string">&quot; need time is: &quot;</span> &lt;&lt; (*pf)(line_num) &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> line_num = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 函数名就是指针，直接传入函数名</span></span><br><span class="line">  <span class="built_in">estimate</span>(line_num, cal_m1);</span><br><span class="line">  <span class="built_in">estimate</span>(line_num, cal_m2); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt学习笔记(下)</title>
      <link href="/posts/cab9f41b.html"/>
      <url>/posts/cab9f41b.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-自定义控件封装">1.  自定义控件封装</h2><p><mark>添加新文件 - Qt – 设计师界面类 (.h .cpp .ui)</mark></p><p><mark>ui中 设计 QSpinBox和QSlider 两个控件</mark></p><p><mark>Widget中使用自定义控件，拖拽一个Widget，点击提升为，点击添加，点击提升</mark></p><p><mark>实现功能，改变数字，滑动条跟着移动 ，信号槽监听。</mark></p><p><mark>提供 getNum 和 setNum对外接口</mark></p><p><mark>测试接口</mark></p><h2 id="2-Qt中的事件">2. Qt中的事件</h2><p><mark>鼠标事件</mark></p><p><mark>鼠标进入事件 enterEvent</mark></p><p><mark>鼠标离开事件 leaveEvent</mark></p><p><mark>鼠标按下  mousePressEvent ( QMouseEvent ev)</mark></p><p><mark>鼠标释放  mouseReleaseEvent</mark></p><p><mark>鼠标移动  mouseMoveEvent</mark></p><p><mark>ev-&gt;x() x坐标 ev-&gt;y() y坐标</mark></p><p><mark>ev-&gt;button() 可以判断所有按键 Qt::LeftButton Qt::RightButton</mark></p><p><mark>ev-&gt;buttons()判断组合按键 判断move时候的左右键 结合 &amp; 操作符</mark></p><p><mark>格式化字符串 QString( “ %1 %2 ” ).arg( 111 ).arg(222)</mark></p><p><mark>设置鼠标追踪   setMouseTracking(true);</mark></p><h2 id="3-定时器1">3.  定时器1</h2><p><mark>利用事件 void timerEvent ( QTimerEvent * ev)</mark></p><p><mark>启动定时器 startTimer( 1000) 毫秒单位</mark></p><p><mark>timerEvent 的返回值是定时器的唯一标示 可以和ev-&gt;timerId 做比较</mark></p><h2 id="4-定时器2">4.  定时器2</h2><p><mark>利用定时器类 QTimer</mark></p><p><mark>创建定时器对象 QTimer * timer = new QTimer(this)</mark></p><p><mark>启动定时器 timer-&gt;start(毫秒)</mark></p><p><mark>每隔一定毫秒，发送信号 timeout ,进行监听</mark></p><p><mark>暂停 timer-&gt;stop</mark></p><h2 id="5-event事件">5.  event事件</h2><p><mark>用途：用于事件的分发</mark></p><p><mark>也可以做拦截操作，不建议</mark></p><p><mark>bool event( QEvent * e);</mark></p><p><mark>返回值 如果是true 代表用户处理这个事件，不向下分发了</mark></p><p><mark>e-&gt;type() == 鼠标按下 …</mark></p><h2 id="6-事件过滤器">6.  事件过滤器</h2><p><img src="https://bu.dusays.com/2022/12/31/63affb18b8cbb.png" alt="01.png"></p><p><mark>在程序将时间分发到事件分发器前，可以利用过滤器做拦截</mark></p><h3 id="6-2-步骤">6.2   步骤</h3><p><mark>1、给控件安装事件过滤器</mark></p><p><mark>2、重写 eventFilter函数 （obj ， ev）</mark></p><h2 id="7-QPainter-绘图">7. QPainter 绘图</h2><p><mark>绘图事件 void paintEvent()</mark></p><p><mark>声明一个画家对象 QPainter painter(this)  this指定绘图设备</mark></p><p><mark>画线、画圆、画矩形、画文字</mark></p><p><mark>设置画笔 QPen 设置画笔宽度 、风格</mark></p><p><mark>设置画刷 QBrush 设置画刷 风格</mark></p><h2 id="8-QPainter高级设置">8.  QPainter高级设置</h2><h3 id="8-1-抗锯齿-效率低">8.1  抗锯齿 效率低</h3><p><mark>painter.setRenderHint(QPainter::Antialiasing);</mark></p><h3 id="8-2-对画家进行移动">8.2  对画家进行移动</h3><p><mark>painter.translate(100,0);</mark></p><p><mark>保存状态 save</mark></p><p><mark>还原状态 restore</mark></p><h3 id="8-3-如果想手动调用绘图事件-利用update">8.3  如果想手动调用绘图事件 利用update</h3><h3 id="8-4-利用画家画图片-painter-drawPixmap-x，y，QPixmap-路飞">8.4   利用画家画图片 painter.drawPixmap( x，y，QPixmap( 路飞) )</h3><h2 id="9-QPaintDevice绘图设备">9. QPaintDevice绘图设备</h2><p><mark>QPixmap QImage QBitmap(黑白色) QPicture QWidget</mark></p><h3 id="9-1-QPixmap-对不同平台做了显示的优化">9.1   QPixmap 对不同平台做了显示的优化</h3><p><mark>QPixmap pix( 300,300)</mark></p><p><mark>pix.fill( 填充颜色 )</mark></p><p><mark>利用画家 往pix上画画 QPainter painter( &amp; pix)</mark></p><p><mark>保存 pix.save( “路径”)</mark></p><h3 id="9-2-Qimage-可以对像素进行访问">9.2   Qimage 可以对像素进行访问</h3><p><mark>使用和QPixmap差不多 QImage img(300,300,<strong>QImage::Format_RGB32</strong>);</mark></p><p><mark>其他流程和QPixmap一样</mark></p><p><mark>可以对像素进行修改 img.setPixel(i,j,value);</mark></p><h3 id="9-3-QPicture-记录和重现-绘图指令">9.3  QPicture  记录和重现 绘图指令</h3><p><mark>QPicture pic</mark></p><p><mark>painter.begin(&amp;pic);</mark></p><p><mark>保存 pic.save( 任意后缀名 )</mark></p><p><mark>重现 利用画家可以重现painter.drawPicture(0,0,pic);</mark></p><h2 id="10-QFile-对文件进行读写操作">10.  QFile 对文件进行读写操作</h2><h3 id="10-1-QFile进行读写操作">10.1   QFile进行读写操作</h3><h3 id="10-2-QFile-file-path-文件路径">10.2   QFile file( path 文件路径)</h3><h3 id="10-3-读">10.3   读</h3><p><mark>ile.open(打开方式) QIODevice::readOnly</mark></p><p><mark>全部读取 file.readAll()  按行读 file.readLine() atend()判断是否读到文件尾</mark></p><p><mark>默认支持编码格式 utf-8</mark></p><p><mark>利用编码格式类 指定格式 QTextCodeC</mark></p><p><mark>QTextCodec * codec = QTextCodec::codecForName(“gbk”);</mark></p><p><mark>//ui-&gt;textEdit-&gt;setText( codec-&gt;toUnicode(array) );</mark></p><p><mark>文件对象关闭 close</mark></p><h3 id="10-4-写">10.4   写</h3><p><mark>file.open( QIODevice::writeOnly / Append)</mark></p><p><mark>file.write(内容)</mark></p><p><mark>file.close 关闭</mark></p><h2 id="11-QFileInfo-读取文件信息">11.  QFileInfo 读取文件信息</h2><p><mark>QFileInfo info(路径)</mark></p><p><mark>qDebug() &lt;&lt; “大小：” &lt;&lt; info.size() &lt;&lt; &quot; 后缀名：&quot; &lt;&lt; <strong>info.suffix()</strong> &lt;&lt; &quot; 文件名称：“&lt;&lt;info.fileName() &lt;&lt; &quot; 文件路径：”&lt;&lt; info.filePath();</mark></p><p><mark>qDebug() &lt;&lt; “创建日期：” &lt;&lt; info.created().toString(“yyyy/MM/dd hh:mm:ss”);</mark></p><p><mark>qDebug() &lt;&lt; “最后修改日期：”&lt;&lt;info.lastModified().toString(“yyyy-MM-dd hh:mm:ss”);</mark></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt学习笔记(中)</title>
      <link href="/posts/967773f.html"/>
      <url>/posts/967773f.html</url>
      
        <content type="html"><![CDATA[<h1>QT学习2</h1><h2 id="1-QMainWindow">1.QMainWindow</h2><h3 id="1-1-菜单栏-最多有一个">1.1     菜单栏 最多有一个</h3><p><mark>QMenuBar * bar = MenuBar();</mark></p><p><mark>setMenuBar( bar )</mark></p><p><mark>QMenu * fileMenu = bar -&gt; addMenu(“文件”)  创建菜单</mark></p><p><mark>QAction * newAction = fileMenu -&gt;addAction(“新建”); 创建菜单项</mark></p><p><mark>添加分割线 fileMenu-&gt;addSeparator();</mark></p><h3 id="1-2-工具栏-可以有多个">1.2     工具栏 可以有多个</h3><p><mark>QToolBar * toolbar = new QToolBar(this);</mark></p><p><mark>addToolBar( 默认停靠区域， toolbar ); Qt::LeftToolBarArea</mark></p><p><mark>设置 后期停靠区域，设置浮动，设置移动</mark></p><p><mark>添加菜单项 或者添加 小控件</mark></p><h3 id="1-3-状态栏-最多一个">1.3     状态栏 最多一个</h3><p><mark>QStatusBar * stBar = statusBar();</mark></p><p><mark>设置到窗口中 setStatusBar(stBar);</mark></p><p><mark>stBar-&gt;addWidget(label);放左侧信息</mark></p><p><mark>stBar-&gt;addPermanentWidget(label2); 放右侧信息</mark></p><h3 id="1-4-铆接部件-浮动窗口-可以多个">1.4     铆接部件 浮动窗口 可以多个</h3><p><mark>QDockWidget</mark></p><p><mark>addDockWidget( 默认停靠区域，浮动窗口指针)</mark></p><p><mark>设置后期停靠区域</mark></p><h3 id="1-5-设置核心部件-只能一个">1.5     设置核心部件 只能一个</h3><p><mark>setCentralWidget(edit);</mark></p><h2 id="2-资源文件">2.  资源文件</h2><p><mark>将图片文件 拷贝到项目位置下</mark></p><p><mark>右键项目-&gt;添加新文件 –&gt; Qt - &gt; Qt recourse File  - &gt;给资源文件起名</mark></p><p><mark>res 生成 res.qrc</mark></p><p><mark>open in editor 编辑资源</mark></p><p><mark>添加前缀 添加文件</mark></p><p><mark>使用 “ : + 前缀名 + 文件名 ”</mark></p><h2 id="3-对话框">3. 对话框</h2><h3 id="3-1-分类-：">3.1 分类 ：</h3><h4 id="3-1-1-模态对话框-不可以对其他窗口进行操作-阻塞">3.1.1  模态对话框  不可以对其他窗口进行操作 阻塞</h4><p><mark>QDialog dlg(this)</mark></p><p><mark>dlg.exec();</mark></p><h4 id="3-1-2-非模态对话框-可以对其他窗口进行操作">3.1.2  非模态对话框 可以对其他窗口进行操作</h4><p><mark>防止一闪而过 创建到堆区</mark></p><p><mark>QDialog * dlg = new QDialog(this)</mark></p><p><mark>dlg-&gt;show();</mark></p><p><mark>dlg2-&gt;setAttribute(Qt::WA_DeleteOnClose); //55号 属性</mark></p><h3 id="3-2-标准对话框-–-消息对话框">3.2     标准对话框 – 消息对话框</h3><p><mark>QMessageBox 静态成员函数 创建对话框</mark></p><p><mark>错误、信息、提问、警告</mark></p><p><mark>参数1 父亲 参数2 标题 参数3 显示内容 参数4 按键类型 参数5 默认关联回车按键</mark></p><p><mark>返回值 也是StandardButton类型，利用返回值判断用户的输入</mark></p><h3 id="3-3-其他标准对话框">3.3 其他标准对话框</h3><p><mark>颜色对话框 QColorDialog：：getColor</mark></p><p><mark>文件对话框 QFileDialog：：getOpenFileName(父亲，标题，默认路径，过滤文件)</mark></p><p><mark>字体对话框 QFontDialog：：getFont</mark></p><h2 id="4-界面布局">4. 界面布局</h2><p><mark>实现登陆窗口</mark></p><p><mark>利用布局方式 给窗口进行美化</mark></p><p><mark>选取 widget 进行布局 ，水平布局、垂直布局、栅格布局</mark></p><p><mark>给用户名、密码、登陆、退出按钮进行布局</mark></p><p><mark>默认窗口和控件之间 有9间隙，可以调整 layoutLeftMargin</mark></p><p><mark>利用弹簧进行布局</mark></p><h2 id="5-控件">5. 控件</h2><h3 id="5-1-按钮组">5.1  按钮组</h3><p><mark>QPushButton 常用按钮</mark></p><p><mark>QToolButton 工具按钮 用于显示图片，如图想显示文字，修改风格：toolButtonStyle ， 凸起风格autoRaise</mark></p><p><mark>radioButton 单选按钮，设置默认 ui-&gt;rBtnMan-&gt;setChecked(true);</mark></p><p><mark>checkbox多选按钮，监听状态，2 选中 1 半选 0 未选中</mark></p><h3 id="5-2-QListWidget-列表容器">5.2  QListWidget 列表容器</h3><p><mark>QListWidgetItem * item 一行内容</mark></p><p><mark>ui-&gt;listWidget -&gt;addItem ( item )</mark></p><p><mark>设置居中方式item-&gt;setTextAlignment(Qt::AlignHCenter);</mark></p><p><mark>可以利用addItems一次性添加整个诗内容</mark></p><h3 id="5-3-QTreeWidget-树控件">5.3  QTreeWidget 树控件</h3><h4 id="5-3-1-设置头">5.3.1  设置头</h4><p><mark>ui-&gt;treeWidget-&gt;setHeaderLabels(QStringList()&lt;&lt; “英雄”&lt;&lt; “英雄介绍”);</mark></p><h4 id="5-3-2-创建根节点">5.3.2  创建根节点</h4><p><mark>QTreeWidgetItem * liItem = new QTreeWidgetItem(QStringList()&lt;&lt; “力量”);</mark></p><h4 id="5-3-3-添加根节点-到-树控件上">5.3.3  添加根节点 到 树控件上</h4><p><mark>ui-&gt;treeWidget-&gt;addTopLevelItem(liItem);</mark></p><h4 id="5-3-4-添加子节点">5.3.4  添加子节点</h4><p><mark>liItem-&gt;addChild(l1);</mark></p><h3 id="5-4-QTableWidget-表格控件">5.4     QTableWidget 表格控件</h3><h4 id="5-4-1-设置列数">5.4.1  设置列数</h4><p><mark>ui-&gt;tableWidget-&gt;setColumnCount(3);</mark></p><h4 id="5-4-2-设置水平表头">5.4.2  设置水平表头</h4><p><mark>ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;“姓名”&lt;&lt; “性别”&lt;&lt; “年龄”);</mark></p><h4 id="5-4-3-设置行数">5.4.3  设置行数</h4><p><mark>ui-&gt;tableWidget-&gt;setRowCount(5);</mark></p><h4 id="5-4-4-设置正文">5.4.4  设置正文</h4><p><mark>ui-&gt;tableWidget-&gt;setItem(0,0, new QTableWidgetItem(“亚瑟”));</mark></p><h3 id="5-5-其他控件介绍">5.5 其他控件介绍</h3><h4 id="5-5-1-stackedWidget-栈控件">5.5.1  stackedWidget 栈控件</h4><p><mark>ui-&gt;stackedWidget-&gt;setCurrentIndex(1);</mark></p><h4 id="5-5-2-下拉框">5.5.2  下拉框</h4><p><mark>ui-&gt;comboBox-&gt;addItem(“奔驰”);</mark></p><h4 id="5-5-3-QLabel-显示图片">5.5.3  QLabel 显示图片</h4><p><mark>ui-&gt;lbl_Image-&gt;setPixmap(QPixmap(“:/Image/butterfly.png”))</mark></p><h4 id="5-5-4-QLabel显示动图-gif图片">5.5.4  QLabel显示动图 gif图片</h4><p><mark>ui-&gt;lbl_movie-&gt;setMovie(movie);</mark></p><p><mark>movie-&gt;start();</mark></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt学习笔记(上)</title>
      <link href="/posts/d3a2c55a.html"/>
      <url>/posts/d3a2c55a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://bu.dusays.com/2022/12/31/63aff83d62ff8.png" alt="Qt5 模块.png"></p><h2 id="1-Qt简介">1.  Qt简介</h2><h3 id="1-1-跨平台图形界面引擎">1.1  跨平台图形界面引擎</h3><h3 id="1-2-历史">1.2  历史</h3><p><mark>1991 奇趣科技</mark></p><h3 id="1-3-优点">1.3  优点</h3><p><mark>跨平台</mark></p><p><mark>接口简单，容易上手</mark></p><p><mark>一定程度上简化了内存回收</mark></p><h3 id="1-4-版本">1.4  版本</h3><p><mark>商业版</mark></p><p><mark>开源版</mark></p><h3 id="1-5-成功案例">1.5  成功案例</h3><p><mark>Linux桌面环境 KDE</mark></p><p><mark>谷歌地图</mark></p><p><mark>VLC多媒体播放器</mark></p><h2 id="2-创建第一个Qt程序">2.  创建第一个Qt程序</h2><h3 id="2-1创建过程">2.1创建过程</h3><p><mark>点击创建项目后，选择项目路径以及给项目起名称</mark></p><p><mark>名称 - 不能有中文不能有空格</mark></p><p><mark>路径 - 不能有中文路径</mark></p><p><mark>默认创建有窗口类，myWidget，基类有三种选择： QWidget 、QMainWindow、QDialog</mark></p><h3 id="2-2-main函数">2.2  main函数</h3><p><mark>QApplication a 应用程序对象，有且仅有一个</mark></p><p><mark>myWidget w;实例化窗口对象</mark></p><p><mark>w.show()调用show函数 显示窗口</mark></p><p><mark>return a.exec() 让应用程序对象进入消息循环机制中，代码阻塞到当前行</mark></p><h2 id="3-按钮控件常用API">3.  按钮控件常用API</h2><p><mark>创建 QPushButton * btn = new QPushButton</mark></p><p><mark>设置父亲 setParent(this)</mark></p><p><mark>设置文本 setText(“文字”)</mark></p><p><mark>设置位置 move(宽，高)</mark></p><p><mark>重新指定窗口大小 resize</mark></p><p><mark>设置窗口标题 setWindowTitle</mark></p><p><mark>设置窗口固定大小 setFixedSize</mark></p><h2 id="4-对象树">4. 对象树</h2><p><mark>当创建的对象在堆区时候，如果指定的父亲是QObject派生下来的类或者QObject子类派生下来的类，可以不用管理释放的操作，将对象会放入到对象树中。</mark></p><p><mark>一定程度上简化了内存回收机制</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63aff83d6af71.png" alt="01.png"></p><h2 id="5-Qt中的坐标系">5. Qt中的坐标系</h2><p><mark>左上角为 0 ， 0 点</mark></p><p><mark>x以右为正方向</mark></p><p><mark>y以下为正方向</mark></p><h2 id="6-信号和槽">6. 信号和槽</h2><p><mark>连接函数 ：connect</mark></p><h3 id="6-1-参数">6.1     参数</h3><p><mark>参数1 信号的发送者</mark></p><p><mark>参数2 发送的信号（函数地址）</mark></p><p><mark>参数3 信号的接受者</mark></p><p><mark>参数4 处理的槽函数 （函数的地址）</mark></p><h3 id="6-2-松散耦合">6.2     松散耦合</h3><h3 id="6-3-实现-点击按钮-关闭窗口的案例">6.3     实现 点击按钮 关闭窗口的案例</h3><h3 id="6-4-connect-btn-QPushButton-click-this-QWidget-close">6.4     connect(btn , &amp;QPushButton::click , this , &amp;QWidget::close );</h3><p><img src="https://bu.dusays.com/2022/12/31/63aff83d612f3.png" alt="02.png"></p><p><img src="https://bu.dusays.com/2022/12/31/63aff90cf379e.png" alt="n1.png"></p><h2 id="7-自定义信号和槽">7.    自定义信号和槽</h2><h3 id="7-1-自定义信号">7.1    自定义信号</h3><p><mark>写到 signals下</mark></p><p><mark>返回 void</mark></p><p><mark>需要声明，不需要实现</mark></p><p><mark>可以有参数 ，可以重载</mark></p><h3 id="7-2-自定义槽函数">7.2 自定义槽函数</h3><p><mark>返回void</mark></p><p><mark>需要声明 ，也需要实现</mark></p><p><mark>可以有参数 ，可以重载</mark></p><p><mark>写到 public slot下 或者public 或者全局函数</mark></p><h3 id="7-3-触发自定义的信号">7.3  触发自定义的信号</h3><p><mark>emit 自定义信号</mark></p><h3 id="7-4-案例-下课后，老师触发饿了信号，学生响应信号，请客吃饭">7.4 案例-下课后，老师触发饿了信号，学生响应信号，请客吃饭</h3><p><img src="https://bu.dusays.com/2022/12/31/63aff83d67e26.png" alt="n2.png"></p><h2 id="8-当自定义信号和槽出现重载">8 当自定义信号和槽出现重载</h2><p><mark>需要利用函数指针 明确指向函数的地址</mark></p><p><mark>void( Teacher:: * tSignal )( QString ) = &amp;Teacher::hungry;</mark></p><h3 id="8-1-QString-转成-char">8.1 QString 转成 char *</h3><p><mark>ToUtf8() 转为 QByteArray</mark></p><p><mark>Data() 转为 Char *</mark></p><h3 id="8-2-信号可以连接信号">8.2 信号可以连接信号</h3><h3 id="8-3-断开信号-disconnect">8.3 断开信号 disconnect</h3><h2 id="9-拓展">9 拓展</h2><p><mark>信号可以连接信号</mark></p><p><mark>一个信号可以连接多个槽函数</mark></p><p><mark>多个信号可以连接同一个槽函数</mark></p><p><mark>信号和槽函数的参数 必须类型一一对应</mark></p><p><mark>信号和槽的参数个数 是不是要一致？信号的参数个数 可以多余槽函数的参数个数</mark></p><p><mark>信号槽可以断开连接 disconnect</mark></p><h2 id="10-Qt4版本写法">10 Qt4版本写法</h2><p><mark>connect( 信号的发送者， 发送的信号SIGNAL( 信号) ，信号接受者， 槽函数SLOT(槽函数) )</mark></p><p><mark>优点 参数直观</mark></p><p><mark>缺点 编译器不会检测参数类型</mark></p><h2 id="11-Lambda表达式">11 Lambda表达式</h2><h3 id="11-1-标识符-匿名函数">11.1 []标识符 匿名函数</h3><p><mark>值传递</mark></p><p><mark>&amp; 引用传递</mark></p><h3 id="11-2-参数">11.2 () 参数</h3><h3 id="11-3-实现体">11.3 {} 实现体</h3><h3 id="11-4-mutable-修饰-值传递变量-，可以修改拷贝出的数据，改变不了本体">11.4 mutable 修饰 值传递变量 ，可以修改拷贝出的数据，改变不了本体</h3><h3 id="11-5-返回值-int">11.5 返回值 <a href=""></a> -&gt;int {}</h3>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决win10下SecureCRT SSH连接慢的问题</title>
      <link href="/posts/8816fee1.html"/>
      <url>/posts/8816fee1.html</url>
      
        <content type="html"><![CDATA[<p>最近用SecureCRT连接远程服务器的时候，发现真的巨慢无比，真的无法忍受啊，于是在网上查阅了大约资料后，终于完美解决了问题</p><p>首先点击Options按钮，选择Session Options，如下图所示:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c8c0c35b05c2769b9c8f1d09e94d0e9b.png" alt=""></p><p>如上图所示，选择SSH2，找到Authenticiation中的GSSAPI,选中它，点击Properties弹出如下界面:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5ae48494bd390ca5b1129ea3cd6477e7.png" alt="img"></p><p>找到Method中的MS kerberos,然后选中它，点击OK,退出。</p><p>重新连接服务器，可以看到迅速连接上，问题完美解决。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/11b06521e022b61357c92e198cbaa44a.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算法总结</title>
      <link href="/posts/3adda9b3.html"/>
      <url>/posts/3adda9b3.html</url>
      
        <content type="html"><![CDATA[<h1>1.背包问题</h1><h2 id="1-1递归">1.1递归</h2><h3 id="1-1-1普通递归方法">1.1.1普通递归方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">w[]  物品的重量</span></span><br><span class="line"><span class="comment">c[]  物品的价值</span></span><br><span class="line"><span class="comment">index 物品的数量（下标）</span></span><br><span class="line"><span class="comment">capacity 背包的容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> w[maxn], c[maxn], dp[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> w[], <span class="type">int</span> c[], <span class="type">int</span> index, <span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//基准条件：如果索引无效或者容量不足，直接返回当前价值0</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//不放第index个物品所得价值</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">solve</span>(w, c, index - <span class="number">1</span>, capacity);</span><br><span class="line">  <span class="comment">//放第index个物品所得价值（前提是：第index个物品可以放得下）</span></span><br><span class="line">    <span class="keyword">if</span> (w[index] &lt;= capacity) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, c[index] + <span class="built_in">solve</span>(w, c, index - <span class="number">1</span>, capacity - w[index]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, capacity;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;capacity);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">solve</span>(w, c, n, capacity);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-2记忆化搜索递归">1.1.2记忆化搜索递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> w[maxn], c[maxn], dp[maxn];</span><br><span class="line"><span class="type">int</span> memo[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> w[], <span class="type">int</span> c[], <span class="type">int</span> index, <span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//基准条件：如果索引无效或者容量不足，直接返回当前价值0</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//不放第index个物品所得价值</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">solve</span>(w, c, index - <span class="number">1</span>, capacity);</span><br><span class="line">  <span class="comment">//如果此子问题已经求解过，则直接返回上次求解的结果</span></span><br><span class="line">    <span class="keyword">if</span> (memo[index][capacity] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[index][capacity];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//放第index个物品所得价值（前提是：第index个物品可以放得下）</span></span><br><span class="line">    <span class="keyword">if</span> (w[index] &lt;= capacity) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, c[index] + <span class="built_in">solve</span>(w, c, index - <span class="number">1</span>, capacity - w[index]));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//添加子问题的解，便于下次直接使用</span></span><br><span class="line">    memo[index][capacity] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, capacity;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;capacity);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">solve</span>(w, c, n, capacity);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-动态规划算法">1.2.动态规划算法</h2><h3 id="1-2-1下标从1开始">1.2.1下标从1开始</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> w[maxn] = &#123; <span class="number">0</span> &#125;, c[maxn] = &#123; <span class="number">0</span> &#125;, dp[maxn] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, capacity;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;capacity);</span><br><span class="line">    <span class="comment">//vector&lt;vector&lt;int&gt; &gt; a(n + 1, vector&lt;int&gt;(capacity + 1));</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">30</span>][<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">                a[i][j] = a[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                a[i][j] = <span class="built_in">max</span>(a[i - <span class="number">1</span>][j], a[i - <span class="number">1</span>][j - w[i]] + c[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] &gt; max) &#123;</span><br><span class="line">                max = a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max=%d\n&quot;</span>, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2下标从0开始">1.2.2下标从0开始</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> w[maxn] = &#123; <span class="number">0</span> &#125;, c[maxn] = &#123; <span class="number">0</span> &#125;, dp[maxn] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, capacity;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;capacity);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">a</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(capacity + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//int a[30][30] = &#123;0&#125;;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= capacity; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w[<span class="number">0</span>] &lt; i) &#123;</span><br><span class="line">            a[<span class="number">0</span>][i] = c[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">                a[i][j] = a[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                a[i][j] = <span class="built_in">max</span>(a[i - <span class="number">1</span>][j], a[i - <span class="number">1</span>][j - w[i]] + c[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] &gt; max) &#123;</span><br><span class="line">                max = a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max=%d\n&quot;</span>, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-3-深度优先搜索">1.3.深度优先搜索</h2><h3 id="1-3-1常规算法">1.3.1常规算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n, V, maxvalue = <span class="number">0</span>; <span class="comment">//物品件数n，背包容量V，最大价值maxvalue</span></span><br><span class="line"><span class="type">int</span> w[maxn], c[maxn];   <span class="comment">//w[i]为每件物品的重量，c[i]为每件物品的价值</span></span><br><span class="line"><span class="comment">//DFS,index为当前处理物品的编号</span></span><br><span class="line"><span class="comment">//sumw和sumc为当前总重量和当前总价值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> sumw, <span class="type">int</span> sumc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == n) &#123;   <span class="comment">//已经完成对n件物品的选择(死胡同)</span></span><br><span class="line">        <span class="keyword">if</span> (sumw &lt;= V &amp;&amp; sumc &gt; maxvalue) &#123;</span><br><span class="line">            maxvalue = sumc;    <span class="comment">//不超过背包容量时更新背包的最大价值</span></span><br><span class="line">        &#125;</span><br><span class="line">        retusrn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//岔道口</span></span><br><span class="line">    <span class="built_in">DFS</span>(index + <span class="number">1</span>, sumw, sumc);     <span class="comment">//不选第index件物品</span></span><br><span class="line">    <span class="built_in">DFS</span>(index + <span class="number">1</span>, sumw + w[index], sumc + c[index]);       <span class="comment">//选择第index件物品</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;V);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);     <span class="comment">//每件物品的重量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);     <span class="comment">//每件物品的价值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, maxvalue);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-2优化时间复杂度-剪枝">1.3.2优化时间复杂度(剪枝)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n, V, maxvalue = <span class="number">0</span>; <span class="comment">//物品件数n，背包容量V，最大价值maxvalue</span></span><br><span class="line"><span class="type">int</span> w[maxn], c[maxn];   <span class="comment">//w[i]为每件物品的重量，c[i]为每件物品的价值</span></span><br><span class="line"><span class="comment">//DFS,index为当前处理物品的编号</span></span><br><span class="line"><span class="comment">//sumw和sumc为当前总重量和当前总价值ji</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> sumw, <span class="type">int</span> sumc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == n) &#123;   <span class="comment">//已经完成对n件物品的选择(死胡同)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(index + <span class="number">1</span>, sumw, sumc);     <span class="comment">//不选择第index件物品</span></span><br><span class="line">    <span class="comment">//只有加入第index件物品后未超过物品的容量V，才能继续</span></span><br><span class="line">    <span class="keyword">if</span> (sumw + w[index] &lt;= V) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumc + c[index] &gt; maxvalue) &#123;</span><br><span class="line">            maxvalue = sumc + c[index];     <span class="comment">//更新最大价值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">DFS</span>(index + <span class="number">1</span>, sumw + w[index], sumc + c[index]);       <span class="comment">//选择第index件物品</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;V);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);     <span class="comment">//每件物品的重量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);     <span class="comment">//每件物品的价值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, maxvalue);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>2.贪心算法</h1><h2 id="2-1-活动选择问题">2.1.活动选择问题</h2><p>有n个需要在同一天使用同一个教室的活动a1,a2,…,an，教室同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi 。一旦被选择后，活动ai就占据半开时间区间[si,fi)。如果[si,fi]和[sj,fj]互不重叠，ai和aj两个活动就可以被安排在这一天。该问题就是要安排这些活动使得尽量多的活动能不冲突的举行。例如下图所示的活动集合S，其中各项活动按照结束时间单调递增排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">aa</span> &#123;</span><br><span class="line"><span class="type">int</span> start;</span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(aa x, aa y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.end &lt; y.end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">src</span><span class="params">(<span class="type">int</span> n, aa s[], <span class="type">bool</span> a[])</span> </span>&#123;</span><br><span class="line">a[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i].start &gt; s[j].end) &#123;</span><br><span class="line">a[i] = <span class="literal">true</span>;</span><br><span class="line">j = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">a[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">aa s[maxn];</span><br><span class="line"><span class="type">bool</span> a[maxn] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; s[i].start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; s[i].end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(s + <span class="number">1</span>, s + <span class="number">1</span> + n, cmp);</span><br><span class="line"><span class="built_in">src</span>(n, s, a);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-最优装载问题">2.2.最优装载问题</h2><p>有一批集装箱要装上一艘载重量为c的轮船。其中集装箱i的重量为Wi。最优装载问题要求确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。(意思就是在不超过载重量的情况下最多能装多少)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">300</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> weigh[maxn];<span class="comment">//集装箱重量的数组</span></span><br><span class="line"><span class="type">int</span> num;<span class="comment">//定义集装箱的总数</span></span><br><span class="line"><span class="type">int</span> max;<span class="comment">//定义船的最大载重量</span></span><br><span class="line"><span class="type">int</span> result[maxn];<span class="comment">//定义可装载集装箱的数组</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;<span class="comment">//计数器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入船的最大载重量&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; max;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入集装箱的数量&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入每个集装箱的重量&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">cin &gt;&gt; weigh[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(weigh + <span class="number">1</span>, weigh + <span class="number">1</span> + num);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">sum = sum + weigh[i];</span><br><span class="line"><span class="keyword">if</span> (sum &lt;= max) &#123;</span><br><span class="line">result[count] = weigh[i];</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;可装载货物的重量分别为:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>3.递归与分治问题</h1><h2 id="3-1-n皇后问题">3.1.n皇后问题</h2><p>N皇后问题是一个经典的问题，在一个N*N的棋盘上放置N个皇后，每行一个并使其不能互相攻击（同一行、同一列、同一斜线上的皇后都会自动攻击）。</p><h3 id="3-1-1暴力法">3.1.1暴力法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> count1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n, p[maxn], hashtable[maxn] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generatep</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == n + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(i - j) == <span class="built_in">abs</span>(p[i] - p[j])) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">count1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line"><span class="keyword">if</span> (hashtable[x] == <span class="literal">false</span>) &#123;</span><br><span class="line">p[index] = x;</span><br><span class="line">hashtable[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">generatep</span>(index + <span class="number">1</span>);</span><br><span class="line">hashtable[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入棋盘的行列数&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">generatep</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2回溯法">3.1.2回溯法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> count1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n, p[maxn], hashtable[maxn] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generatep</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == n + <span class="number">1</span>) &#123;</span><br><span class="line">count1++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line"><span class="keyword">if</span> (hashtable[x] == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> pre = <span class="number">1</span>; pre &lt; index; pre++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(index - pre) == <span class="built_in">abs</span>(x - p[pre])) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">p[index] = x;</span><br><span class="line">hashtable[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">generatep</span>(index + <span class="number">1</span>);</span><br><span class="line">hashtable[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入棋盘的行列数&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">generatep</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-二分搜索">3.2.二分搜索</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarysearch</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> mid;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] == x) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123; <span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="comment">//quicksort(a, 0, 7);</span></span><br><span class="line"><span class="comment">/*bubblesort(a, 8);</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; 8; i++) &#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">x = <span class="built_in">binarysearch</span>(a, <span class="number">0</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-棋盘覆盖问题">3.3.棋盘覆盖问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">int</span> tile=<span class="number">1</span>;                   <span class="comment">//L型骨牌的编号(递增)  </span></span><br><span class="line"><span class="type">int</span> board[<span class="number">100</span>][<span class="number">100</span>];  <span class="comment">//棋盘  </span></span><br><span class="line"><span class="comment">/***************************************************** </span></span><br><span class="line"><span class="comment">* 递归方式实现棋盘覆盖算法 </span></span><br><span class="line"><span class="comment">* 输入参数： </span></span><br><span class="line"><span class="comment">* tr--当前棋盘左上角的行号 </span></span><br><span class="line"><span class="comment">* tc--当前棋盘左上角的列号 </span></span><br><span class="line"><span class="comment">* dr--当前特殊方格所在的行号 </span></span><br><span class="line"><span class="comment">* dc--当前特殊方格所在的列号 </span></span><br><span class="line"><span class="comment">* size：当前棋盘的:2^k </span></span><br><span class="line"><span class="comment">*****************************************************/</span>  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chessBoard</span> <span class="params">( <span class="type">int</span> tr, <span class="type">int</span> tc, <span class="type">int</span> dr, <span class="type">int</span> dc, <span class="type">int</span> size )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( size==<span class="number">1</span> )    <span class="comment">//棋盘方格大小为1,说明递归到最里层  </span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    <span class="type">int</span> t=tile++;     <span class="comment">//每次递增1  </span></span><br><span class="line">    <span class="type">int</span> s=size/<span class="number">2</span>;    <span class="comment">//棋盘中间的行、列号(相等的)  </span></span><br><span class="line">    <span class="comment">//检查特殊方块是否在左上角子棋盘中  </span></span><br><span class="line">    <span class="keyword">if</span> ( dr&lt;tr+s &amp;&amp; dc&lt;tc+s )              <span class="comment">//在  </span></span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr, tc, dr, dc, s );  </span><br><span class="line">    <span class="keyword">else</span>         <span class="comment">//不在，将该子棋盘右下角的方块视为特殊方块  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        board[tr+s<span class="number">-1</span>][tc+s<span class="number">-1</span>]=t;  </span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr, tc, tr+s<span class="number">-1</span>, tc+s<span class="number">-1</span>, s );  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//检查特殊方块是否在右上角子棋盘中  </span></span><br><span class="line">    <span class="keyword">if</span> ( dr&lt;tr+s &amp;&amp; dc&gt;=tc+s )               <span class="comment">//在  </span></span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr, tc+s, dr, dc, s );  </span><br><span class="line">    <span class="keyword">else</span>          <span class="comment">//不在，将该子棋盘左下角的方块视为特殊方块  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        board[tr+s<span class="number">-1</span>][tc+s]=t;  </span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr, tc+s, tr+s<span class="number">-1</span>, tc+s, s );  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//检查特殊方块是否在左下角子棋盘中  </span></span><br><span class="line">    <span class="keyword">if</span> ( dr&gt;=tr+s &amp;&amp; dc&lt;tc+s )              <span class="comment">//在  </span></span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr+s, tc, dr, dc, s );  </span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">//不在，将该子棋盘右上角的方块视为特殊方块  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        board[tr+s][tc+s<span class="number">-1</span>]=t;  </span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr+s, tc, tr+s, tc+s<span class="number">-1</span>, s );  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//检查特殊方块是否在右下角子棋盘中  </span></span><br><span class="line">    <span class="keyword">if</span> ( dr&gt;=tr+s &amp;&amp; dc&gt;=tc+s )                <span class="comment">//在  </span></span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr+s, tc+s, dr, dc, s );  </span><br><span class="line">    <span class="keyword">else</span>         <span class="comment">//不在，将该子棋盘左上角的方块视为特殊方块  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        board[tr+s][tc+s]=t;  </span><br><span class="line">        <span class="built_in">chessBoard</span> ( tr+s, tc+s, tr+s, tc+s, s );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> size;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输入棋盘的size(大小必须是2的n次幂): &quot;</span>;  </span><br><span class="line">    cin&gt;&gt;size;  </span><br><span class="line">    <span class="type">int</span> index_x,index_y;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输入特殊方格位置的坐标: &quot;</span>;  </span><br><span class="line">    cin&gt;&gt;index_x&gt;&gt;index_y;  </span><br><span class="line">    <span class="built_in">chessBoard</span> ( <span class="number">0</span>,<span class="number">0</span>,index_x,index_y,size );  </span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++ )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> j=<span class="number">0</span>; j&lt;size; j++ )  </span><br><span class="line">            cout&lt;&lt;board[i][j]&lt;&lt;<span class="string">&#x27;/t&#x27;</span>;  </span><br><span class="line">        cout&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-4-循环赛日程表">3.4.循环赛日程表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 50</span></span><br><span class="line"><span class="comment">//打印盒子 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> game[][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cout &lt;&lt; game[i][j] &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归函数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">arrange</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> t, <span class="type">int</span> arr[][N])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//规格为4及以上，它的左上角和右上角要递归</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">arrange</span>(p, q, t / <span class="number">2</span>, arr);</span><br><span class="line">        <span class="built_in">arrange</span>(p, q + t / <span class="number">2</span>, t / <span class="number">2</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填左下角</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = p + t / <span class="number">2</span>; i &lt; p + t; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = q; j &lt; q + t / <span class="number">2</span>; j++) &#123;</span><br><span class="line">            arr[i][j] = arr[i - t / <span class="number">2</span>][j + t / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填右下角 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = p + t / <span class="number">2</span>; i &lt; p + t; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = q + t / <span class="number">2</span>; j &lt; q + t; j++) &#123;</span><br><span class="line">            arr[i][j] = arr[i - t / <span class="number">2</span>][j - t / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> game[N][N];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入选手人数:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//初始化第一行,其他全为0 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                game[i][j] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                game[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归 </span></span><br><span class="line">    <span class="built_in">arrange</span>(<span class="number">0</span>, <span class="number">0</span>, n, game);</span><br><span class="line">    <span class="comment">//打印输出循环赛日程表 </span></span><br><span class="line">    <span class="built_in">print</span>(n, game);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-马拦过河卒">3.5.马拦过河卒</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> total;  <span class="comment">//记录路径总数</span></span><br><span class="line"><span class="type">int</span> end_r,end_c;  <span class="comment">//记录B点</span></span><br><span class="line"><span class="type">int</span> hourse_r,hourse_c;  <span class="comment">//记录马所在位置</span></span><br><span class="line"><span class="type">int</span> wayr[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,wayc[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;  <span class="comment">//用于移动卒</span></span><br><span class="line"><span class="type">int</span> territory[<span class="number">9</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;&#125;;  <span class="comment">//协助标记马的控制范围</span></span><br><span class="line"><span class="type">bool</span> map[<span class="number">20</span>][<span class="number">20</span>];  <span class="comment">//用于标记马的控制范围</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>  <span class="comment">//判断是否出界</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;end_r||y&gt;end_c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(r+wayr[i],c+wayc[i])&amp;&amp;!map[r+wayr[i]][c+wayc[i]])  <span class="comment">//判断能否到达该点，即是否出界或者被马占领</span></span><br><span class="line">&#123;</span><br><span class="line">r+=wayr[i];  <span class="comment">//移动行</span></span><br><span class="line">c+=wayc[i];  <span class="comment">//移动列</span></span><br><span class="line"><span class="keyword">if</span>(r==end_r&amp;&amp;c==end_c) total++;  <span class="comment">//若到达B点，计数</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">dfs</span>(r,c);  <span class="comment">//递归调用，继续搜索</span></span><br><span class="line">r-=wayr[i];  <span class="comment">//回溯</span></span><br><span class="line">c-=wayc[i];  <span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;end_r&gt;&gt;end_c&gt;&gt;hourse_r&gt;&gt;hourse_c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)   <span class="comment">//标记马的控制范围</span></span><br><span class="line">map[hourse_r+territory[i][<span class="number">0</span>]][hourse_c+territory[i][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">//开始回溯</span></span><br><span class="line">cout&lt;&lt;total;  <span class="comment">//输出结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4,动态规划</h1><h2 id="4-1-矩阵连乘问题">4.1.矩阵连乘问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> A[N];<span class="comment">//矩阵规模</span></span><br><span class="line"><span class="type">int</span> m[N][N];<span class="comment">//最优解</span></span><br><span class="line"><span class="type">int</span> s[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MatrixChain</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> r, i, j, k;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)<span class="comment">//初始化对角线</span></span><br><span class="line">&#123;</span><br><span class="line">m[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">2</span>; r &lt;= n; r++)<span class="comment">//r个矩阵连乘</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - r + <span class="number">1</span>; i++)<span class="comment">//r个矩阵的r-1个空隙中依次测试最优点</span></span><br><span class="line">&#123;</span><br><span class="line">j = i + r - <span class="number">1</span>;</span><br><span class="line">m[i][j] = m[i][i]+m[i + <span class="number">1</span>][j] + A[i - <span class="number">1</span>] * A[i] * A[j];</span><br><span class="line">s[i][j] = i;</span><br><span class="line"><span class="keyword">for</span> (k = i + <span class="number">1</span>; k &lt; j; k++)<span class="comment">//变换分隔位置，逐一测试</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = m[i][k] + m[k + <span class="number">1</span>][j] + A[i - <span class="number">1</span>] * A[k] * A[j];</span><br><span class="line"><span class="keyword">if</span> (t &lt; m[i][j])<span class="comment">//如果变换后的位置更优，则替换原来的分隔方法。</span></span><br><span class="line">&#123;</span><br><span class="line">m[i][j] = t;</span><br><span class="line">s[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(i, s[i][j]);</span><br><span class="line"><span class="built_in">print</span>(s[i][j] + <span class="number">1</span>, j);<span class="comment">//递归1到s[1][j]</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n个矩阵</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MatrixChain</span>(n);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最佳添加括号的方式为：&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>, n);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n最小计算量的值为：&quot;</span> &lt;&lt; m[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-最长公共子序列">4.2.最长公共子序列</h2><p>给定两个字符串（或数字序列）A和B，求一个字符串，使得这个字符串是A和B的最长公共部分（子序列可以不连续）</p><p>eg：字符串&quot;sadstory&quot;和&quot;adminsorry&quot;的最长公共子序列为&quot;adsory&quot;,长度为6</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">gets_s</span>(a + <span class="number">1</span>, maxn);</span><br><span class="line"><span class="built_in">gets_s</span>(b + <span class="number">1</span>, maxn);</span><br><span class="line"><span class="type">int</span> lena = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> lenb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lena; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= lenb; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lena; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lenb; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[lena][lenb] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-数塔问题">4.3.数塔问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[maxn][maxn], dp[maxn][maxn];</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">cin &gt;&gt; f[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">dp[n][j] = f[n][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + f[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-最大连续子序列和">4.4.最大连续子序列和</h2><p>给定一个数字序列A1,A2,…,An,求i，j(1&lt;=i&lt;=j&lt;=n),使得Ai+…+Aj最大，输出这个最大和</p><p>eg:-2 11 -4 13 -5 -2 显然最大和为20</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> src[maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; src[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>] = src[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(src[i], dp[i - <span class="number">1</span>] + src[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i] &gt; dp[k]) &#123;</span><br><span class="line">k = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>5.常见排序</h1><h2 id="5-1-选择排序">5.1.选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectsort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> k = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[k]) &#123;</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(a[i], a[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[maxn] = &#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">selectsort</span>(a, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-插入排序">5.2.插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> temp = a[i], j = i;</span><br><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; temp &lt; a[j - <span class="number">1</span>]) &#123;</span><br><span class="line">a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[maxn] = &#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">insertsort</span>(a, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-冒泡排序">5.3.冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubblesort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123; <span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">bubblesort</span>(a, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-快速排序">5.4.快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a[left];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt; temp) right--;</span><br><span class="line">a[left] = a[right];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= temp) left++;</span><br><span class="line">a[right] = a[left];</span><br><span class="line">&#125;</span><br><span class="line">a[left] = temp;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> pos = <span class="built_in">partition</span>(a, left, right);</span><br><span class="line"><span class="built_in">quicksort</span>(a, left, pos - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">quicksort</span>(a, pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123; <span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">quicksort</span>(a, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;</span><br><span class="line">       <span class="number">8</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-归并排序">5.5.归并排序</h2><h3 id="5-5-1递归实现">5.5.1递归实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = l1, j = l2;</span><br><span class="line"><span class="type">int</span> temp[maxn], index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= r1 &amp;&amp; j &lt;= r2) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">temp[index++] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp[index++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= r1) temp[index++] = a[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r2) temp[index++] = a[j++];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">a[l1 + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">mergesort</span>(a, left, mid);</span><br><span class="line"><span class="built_in">mergesort</span>(a, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="built_in">merge</span>(a, left, mid, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[maxn] = &#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">mergesort</span>(a, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-2非递归实现">5.5.2非递归实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = l1, j = l2;</span><br><span class="line"><span class="type">int</span> temp[maxn], index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= r1 &amp;&amp; j &lt;= r2) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">temp[index++] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp[index++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= r1) temp[index++] = a[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r2) temp[index++] = a[j++];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">a[l1 + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort2</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">2</span>; step / <span class="number">2</span> &lt;= n; step *= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += step) &#123;</span><br><span class="line"><span class="type">int</span> mid = i + step / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mid + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line"><span class="built_in">merge</span>(a, i, mid, mid + <span class="number">1</span>, <span class="built_in">min</span>(i + step - <span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[maxn] = &#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">mergesort2</span>(a, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Robocup3d比赛环境的搭建及常用函数简介</title>
      <link href="/posts/58ee31e2.html"/>
      <url>/posts/58ee31e2.html</url>
      
        <content type="html"><![CDATA[<!-- # Robocup3d比赛环境的搭建及常用函数简介 --><h2 id="1-比赛环境的搭建">1.比赛环境的搭建</h2><h3 id="1-1-查看本机wsl子系统的版本号">1.1 查看本机wsl子系统的版本号</h3><p><mark>wsl -l -v</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63afeecbd02aa.png" alt="wsl.png"></p><h3 id="1-2-导入命令">1.2 导入命令</h3><p>首先进入想要导入的目录，如图我在E盘中创建了wslstorage目录，将压缩包移到此目录下，打开cmd输入以下代码</p><p><mark>wsl --import ubuntu ./wsl ./Ubuntu.tar</mark></p><p><img src="https://bu.dusays.com/2022/12/31/63afeecbd0260.png" alt="daoru.png"></p><blockquote><p>补充:</p><p>注销wsl子系统：<mark>wsl --unregister Ubuntu</mark></p></blockquote><p>成功导入以后，我们就基本完成了比赛环境的搭建，这之后我们还需要一个roboviz，可以让我们用肉眼观察到仿真足球赛中发生的状况，详细的下载地址可以看学长的博客，上面写的很详细https://blog.flyme.tech/2020/11/29/robocup3d_wsl/</p><p>一切完成后,大功告成</p><p>下面我给大家演示以下如何进入我们的比赛环境，在cmd中输入<mark>wsl</mark>命令进入wsl子系统，进入后，输入<mark>rcsoccersim3d</mark>命令，如下所示</p><p><img src="https://bu.dusays.com/2022/12/31/63afeecbd028e.png" alt="cwrc.png"></p><p>接着打开roboviz，这样我们环境的搭建就完成了。</p><p><img src="https://bu.dusays.com/2022/12/31/63afeecc15838.png" alt="play.png"></p><h2 id="2-常用函数简介">2.常用函数简介</h2><h3 id="WorldModel类">WorldModel类</h3><p>WorldModel类保存了场上许多的信息，是机器人利用场上信息的重要途径，它在机器人NaoBehavior中实例化了一个对象指针WorldModel。</p><p>在机器人策略中使用时，应使用worldmodel-&gt;方法名([参数列表])的形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前机器人的编号</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getUNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用于判断自己是几号，可以在策略中设定类似“如果是几号球员，就执行什么动作”</p><p>例如在初始化beam函数中，根据unum来分配球员位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是一号球员则它的位置是</span></span><br><span class="line"><span class="keyword">if</span> (worldModel -&gt; <span class="built_in">getUNum</span>() == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  beamX = <span class="number">-15</span>;</span><br><span class="line">  beamY = <span class="number">0</span>;</span><br><span class="line">  beamAngel = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ... (其他情况)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回比赛当前时间(距离开始的秒数)(返回的是一个浮点数)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">getGameTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gametime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前比赛的周期数(每一秒是20个周期，一个周期agent和server进行通讯,server进行仿真处理后将场上的信息返回发送给agent)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title">getCycle</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cycle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取编号为i的对象的位置(以下两函数仅名称不同，效果是一样的)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VecPosition <span class="title">getOpponent</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> worldObjects[i].pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> VecPosition <span class="title">getTeammate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> worldObjects[i].pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何利用这个函数来检索指定的球员的位置呢?</p><p>在头文件WorldObject.h中，定义了一个枚举worldObjType内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">WorldObjType</span> &#123;   <span class="comment">// Types of objects</span></span><br><span class="line">    WO_BALL,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Self and Teammates</span></span><br><span class="line">    WO_TEAMMATE1,</span><br><span class="line">    WO_TEAMMATE2,</span><br><span class="line">    WO_TEAMMATE3,</span><br><span class="line">    WO_TEAMMATE4,</span><br><span class="line">    WO_TEAMMATE5,</span><br><span class="line">    WO_TEAMMATE6,</span><br><span class="line">    WO_TEAMMATE7,</span><br><span class="line">    WO_TEAMMATE8,</span><br><span class="line">    WO_TEAMMATE9,</span><br><span class="line">    WO_TEAMMATE10,</span><br><span class="line">    WO_TEAMMATE11,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Opponents</span></span><br><span class="line">    WO_OPPONENT1,</span><br><span class="line">    WO_OPPONENT2,</span><br><span class="line">    WO_OPPONENT3,</span><br><span class="line">    WO_OPPONENT4,</span><br><span class="line">    WO_OPPONENT5,</span><br><span class="line">    WO_OPPONENT6,</span><br><span class="line">    WO_OPPONENT7,</span><br><span class="line">    WO_OPPONENT8,</span><br><span class="line">    WO_OPPONENT9,</span><br><span class="line">    WO_OPPONENT10,</span><br><span class="line">    WO_OPPONENT11,</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 后面还有很多比如关节什么的枚举量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>众所周知枚举类其实就是给整数起了个别名，例如此处第一个枚举WO_BALL</p><p>在代码中和0作用一样，此后的每一个枚举在前一个的基础上加1，所以检索球员的代码可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = WO_OPPONENT; i&lt;WO_OPPONENT + OPPONENT_NUM; i++)&#123;</span><br><span class="line">  VecPosition pos = worldModel-&gt;<span class="built_in">getOpponent</span>(i);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取编号为index的WorldObject的指针</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> WorldObject* <span class="title">getWorldObject</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;worldObjects[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文的getOpponent与此函数内容类似，都是在worldObjects数组中获取对应下标的对象</p><p>WorldObjects类描述了某物体(球，球员等)的一些基本属性，可以说，是WorldObject们构成了WorldModel。</p><p>关于WorldObjects类此处不展开介绍，其方法与属性都浅显易懂，有兴趣自行学习。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下还有一些常用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取此球员的位置</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VecPosition <span class="title">getMyPosition</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> myPosition;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取球的位置</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VecPosition <span class="title">getBall</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> worldObjects[WO_BALL].pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前比赛模式(比赛进行到不同阶段会有不同模式，比如任意球，门球...有兴趣可以查看源码自行观看)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VecPosition <span class="title">getPlayMode</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> playMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取机器人是否摔跤</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isFallen</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fFallen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Naobehaviors类">Naobehaviors类</h3><p>Naobehaviors类中有许许多多机器人可以执行的高级动作，怎么使用只要关注他的返回值即可，返回值为SkillType的可以直接在selectskill()中return（或者在其他返回值为SkillType的函数中return，比如gototarget()调用了gototargetrelative(),gototargetrelative调用了getwalk()等），返回值为VecPosition的可以用表达式和判断条件中，Bool类型的判断情况的函数，多用于条件判断。下面是一些常用的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NaoBehavior::beam</span><span class="params">( <span class="type">double</span>&amp; beamX, <span class="type">double</span>&amp; beamY, <span class="type">double</span>&amp; beamAngle )</span></span>;</span><br></pre></td></tr></table></figure><p>决定球员上场位置的函数，可以依次对不同的number给其beamX和beamY赋值，也可以都设为default</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">trim</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; value,<span class="type">const</span> <span class="type">double</span>&amp; min, <span class="type">const</span> <span class="type">double</span>&amp; max)</span></span>;</span><br></pre></td></tr></table></figure><p>trim:修剪。返回值为经过判断修改的value，满足大于min，小于max</p><p>---------------------------分割线(持续更新中)----------------------------</p>]]></content>
      
      
      <categories>
          
          <category> Robocup3d </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robocup3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令总结</title>
      <link href="/posts/1fe3367f.html"/>
      <url>/posts/1fe3367f.html</url>
      
        <content type="html"><![CDATA[<p>Linux的命令有几百个，但是常用的并不多，这些命令我们并不需要全部掌握。如果在学习和工作中遇到了陌生的Linux命令，多查手册，多多使用，久而久之就能熟能生巧</p><p><mark>在这给大家推荐一个Linux命令在线中文手册，方便大家在遇到没见过的命令时查看</mark></p><p><a href="http://linux.51yip.com/">点我获取地址</a></p><p>本文介绍了Linux最基础的25个命令。</p><h2 id="1、重启和关机">1、重启和关机</h2><p>重启和关机需要系统管理员用户权限。</p><p>1）重启</p><p><mark>init 6 或 reboot</mark></p><p>2）关机</p><p><mark>init 0 或 halt</mark></p><p>如果没有执行关机命令，强制断电或关闭本地虚拟机的窗口，会导致Linux操作系统文件的损坏，严重的可能导致系统无法正常启动。</p><h2 id="2、清屏">2、清屏</h2><p><mark>clear</mark></p><p>清除当前屏幕上显示的内容。</p><p><mark>Ctrl+l</mark></p><p>换页，不清屏</p><h2 id="3、查看服务器的ip地址">3、查看服务器的ip地址</h2><p><mark>ip addr</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebe6469f06.png" alt="图片1.png"></p><p>上图中，框中显示的就是IP地址。</p><h2 id="4、时间操作">4、时间操作</h2><p>普通用户可以查看时间，但设置时区和时间要系统管理员用户登录 。</p><p>1）查看时间。</p><p><mark>date</mark></p><p>2）设置时区为中国上海时间（注意不是北京时间）。</p><p><mark>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</mark></p><p>3）设置时间。</p><p><mark>date -s “yyyy-mm-dd hh:mi:ss”</mark></p><p>例如：date -s “2020-01-02 12:35:28”</p><h2 id="5、查看日历">5、查看日历</h2><p><strong>基本语法</strong></p><p><mark>cal [选项] （功能描述：不加选项，显示本月日历）</mark></p><p>选项说明：具体某一年，显示当年的日历</p><p>1）查看当前月的日历</p><p><mark>cal</mark></p><p>2）查看2017年的日历</p><p><mark>cal 2017</mark></p><h2 id="6、目录和文件">6、目录和文件</h2><p>文件系统是像一棵树，树干是/（根）目录，树枝是子目录，树枝后面还有树枝（子目录中还有子目录），树枝最后是树叶，目录的最后是文件。</p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98af19f.png" alt="图片2.png"></p><p>严谨的说，文件名是由<strong>目录+文件名</strong>组成的。</p><p>对于目录和文件，有一些约定的表述，我们以/usr/etc/readme.txt为例。</p><p>1）<strong>全路径文件名</strong>包含了完整的目录名和文件名，即/usr/etc/readme.txt，还有一个称呼是“<strong>绝对路径文件名</strong>”。</p><p>2）readme.txt是文件名，它在/usr/etc目录中。</p><p>3）目录和文件的<strong>绝对路径</strong>是从根（/）算起，在任何时候都不会有岐义。</p><p>4）登录Linux后，一定处在目录树的某个目录中，这个目录称之为当前工作目录，简称<strong>当前目录</strong>。</p><p>5）目录和文件的<strong>相对路径</strong>是从当前工作目录算起，如果当前工作目录是/usr，etc/readme.txt等同于/usr/etc/readme.txt；如果当前工作目录是/usr/etc，readme.txt等同于/usr/etc/readme.txt。</p><p>6）用Linux的命令操作目录和文件的时候，采用绝对路径和相对路径都可以。</p><p>7）一个圆点.表示当前工作目录；</p><p>8）两个圆点…表示当前工作目录的上一级目录。</p><p><strong>理解绝对路径和相对路径的概念非常重要，在日常操作中，绝对路径和相对路径会同时使用，但是程序员在编写的程序中极少使用相对路径。</strong></p><p><mark>Linux具体目录结构</mark></p><table><thead><tr><th style="text-align:left"><strong>/lib</strong></th><th style="text-align:left">系统开机所需要最基本的动态链接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</th></tr></thead><tbody><tr><td style="text-align:left"><strong>/lost+found</strong></td><td style="text-align:left"><strong>一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</strong></td></tr><tr><td style="text-align:left"><strong>/etc [重点]</strong></td><td style="text-align:left"><strong>所有系统管理所需要的配置文件和子目录。my.conf</strong></td></tr><tr><td style="text-align:left"><strong>/usr</strong></td><td style="text-align:left"><strong>用户的很多应用程序和文件都放在这个目录下。类似于Windows下的program.files目录</strong></td></tr><tr><td style="text-align:left"><strong>/bin (重点)(usr/bin,/usr/local/bin)</strong></td><td style="text-align:left"><strong>是Binary的缩写，这个目录存放着经常使用的命令</strong></td></tr><tr><td style="text-align:left"><strong>/sbin (usr/sbin、/usr/local/sbin)</strong></td><td style="text-align:left"><strong>s就是 super user的意思，这里存放的是系统管理员使用的系统管理程序</strong></td></tr><tr><td style="text-align:left"><strong>/home [重点]</strong></td><td style="text-align:left"><strong>存放普通用户的主目录，在Linux中的每个用户都有一个自己的目录，一般该目录以用户的账号名命名</strong></td></tr><tr><td style="text-align:left"><strong>/root [重点]</strong></td><td style="text-align:left"><strong>该目录为系统管理员，超级权限者的用户目录</strong></td></tr><tr><td style="text-align:left"><strong>/boot</strong></td><td style="text-align:left"><strong>存放的启动Linux时使用的一些核心文件，包括一些链接文件和镜像文件</strong></td></tr><tr><td style="text-align:left"><strong>/proc</strong></td><td style="text-align:left"><strong>虚拟目录，是系统内存的映射，访问这个目录来获取系统信息。</strong></td></tr><tr><td style="text-align:left"><strong>/srv</strong></td><td style="text-align:left"><strong>service 的缩写，该目录是存放一些服务启动之后需要提取的数据</strong></td></tr><tr><td style="text-align:left"><strong>/sys</strong></td><td style="text-align:left"><strong>Linux2.6内核的一个很大变化，该目录安装了2.6内核中新出现的一个文件系统</strong></td></tr><tr><td style="text-align:left"><strong>/tmp</strong></td><td style="text-align:left"><strong>存放临时文件</strong></td></tr><tr><td style="text-align:left"><strong>/dev</strong></td><td style="text-align:left"><strong>类似于 windows的设备管理器,把所有的硬件用文件的形式存储</strong></td></tr><tr><td style="text-align:left"><strong>/media [重点]</strong></td><td style="text-align:left"><strong>Linux系统会自动识别一些设备,例如U盘、光驱等等,当识别后,Linux 会把识别的设备挂载到这个目录下。</strong></td></tr><tr><td style="text-align:left"><strong>/mnt [重点]</strong></td><td style="text-align:left"><strong>系统提供该目录是为了让用户临时挂载别的文件系统的,我们可以将外部的存储挂载在/mnt/上,然后进入该目录就可以查看里的内容了。d:/ myshare</strong></td></tr><tr><td style="text-align:left"><strong>/opt</strong></td><td style="text-align:left"><strong>这是给主机额外安装软件所摆放的目录。如安装 ORACLE数据库就可放到该目录下。默认为空。</strong></td></tr><tr><td style="text-align:left"><strong>/usr/local [重点]</strong></td><td style="text-align:left"><strong>这是另个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</strong></td></tr><tr><td style="text-align:left"><strong>/var [重点]</strong></td><td style="text-align:left"><strong>这个目录中存放着在不断扩充着的东西,习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</strong></td></tr><tr><td style="text-align:left"><strong>/selinux [security-enhanced linux] 类似 360</strong></td><td style="text-align:left"><strong>Selinux是一种安全子系统,它能控制程序只能访同特定文件。</strong></td></tr></tbody></table><h2 id="7、链接命令">7、链接命令</h2><p><strong>命令名称：ln</strong></p><p>命令英文原意：link</p><p>命令所在路径：/bin/ln</p><p>执行权限：所有用户</p><p><strong>语法：ln  -s  [原文件]  [目标文件]</strong></p><p><strong>-s  创建软链接(也称符号链接)</strong></p><p><strong>ln命令不带参数默认创建硬链接</strong></p><p>功能描述：生成链接文件</p><p>范例：</p><p><mark>ln -s  /etc/issue  /tmp/issue.soft</mark></p><p>创建文件/etc/issue的软链接/tmp/issue.soft</p><p><mark>ln  /etc/issue  /tmp/issue.hard</mark></p><p>创建文件/etc/issue的硬链接/tmp/issue.hard</p><p><strong>硬链接特征：</strong></p><p>1、相当于创建了源文件的副本，如果硬链接文件的内容修改了，那么源文件的内容也会改变。</p><p>2、通过文件的索引节点链接</p><p>3、只有在同一文件系统的文件才能创建硬链接，不能跨分区创建</p><p>4、不能针对目录使用</p><p><strong>软链接特征：</strong></p><p>1、软链接可以实现文件或者目录的共享，它就像Windows下的快捷方式一样</p><p>2、 软链接文件可以是指向任意一个文件系统下的任意文件或目录，不仅如此，软链接还可以指向一个不存在的文件，但是不能对不存在的文件创建硬链接</p><p>3、硬链接只能在同一文件系统下创建，那么软链接就不会有这个限制，可以理解为软链接的产生就是为了摆脱这个限制的</p><h2 id="8、查看当前工作目录">8、查看当前工作目录</h2><p><mark>pwd</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98b0ea6.png" alt="图片3.png"></p><h2 id="9、改变当前工作目录">9、改变当前工作目录</h2><p><mark>cd 目录名</mark></p><p>示例：</p><p>1）进入/tmp目录</p><p><mark>cd /tmp</mark></p><p>2）进入上一级目录</p><p><mark>cd …</mark></p><p>3）进入用户的主目录</p><p><mark>cd</mark></p><p><mark>cd~</mark></p><h2 id="10、列出目录和文件信息">10、列出目录和文件信息</h2><p><mark>语法：ls  选项[-ald]  [文件或目录]</mark></p><p><mark>-a    显示所有文件，包括隐藏文件</mark></p><p><mark>-l     详细信息显示</mark></p><p><mark>-d    查看目录属性</mark></p><p>ls是list的缩写，通过ls 命令不仅可以查看目录和文件信息，还可以目录和文件权限、大小、主人和组等信息。</p><p>选项-l列出目录和文件的详细信息。</p><p>选项-lt列出目录和文件的详细信息，按时间降序显示。</p><p>示例：</p><p>1）列出当前工作目录下全部的目录和文件名信息。</p><p><mark>ls</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98aff37.png" alt="图片4.png"></p><p>2）列出当前工作目录下全部的目录和文件名详细的信息。</p><p><mark>ls -l</mark></p><p>(下图信息内容会在文件权限那边详细介绍)</p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98b60e3.png" alt="图片5.png"></p><p>3）列出/home目录下全部的目录和文件。</p><p><mark>ls /home</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98afee8.png" alt="图片6.png"></p><p>4）正则表达式</p><p>正则表达式又称规则表达式、通配符，目录和文件名都支持正则表达式，正则表达式的规则比较多，在这里我只介绍最常用的两种：星号“*”和问号“?”。</p><p>星号“*”：匹配任意数量的字符。</p><p>问号“?”：匹配一个的字符。</p><p>5）列出/root/thread-cpp目录下以匹配*.cpp的目录和文件。</p><p><mark>ls /root/thread-cpp/*.cpp</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98b024b.png" alt="图片7.png"></p><p>6）列出/root/aaa目录下匹配*.sh的目录和文件，按时间降序显示。</p><p><mark>ls -lt /root/aaa/*.sh</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98b4709.png" alt="图片8.png"></p><h2 id="11、创建目录">11、创建目录</h2><p><mark>mkdir 目录名</mark></p><p>示例：</p><p>1）在当前工作目录下创建aaa目录。</p><p><mark>mkdir aaa</mark></p><p>2）在当前工作目录的aaa目录下创建bbb目录。</p><p><mark>mkdir aaa/bbb</mark></p><p>3）创建/tmp/aaa目录。</p><p><mark>mkdir /tmp/aaa</mark></p><h2 id="12、删除目录和文件">12、删除目录和文件</h2><p><mark>rm [-rf] 目录或文件列表</mark></p><p>选项-r可以删除目录，如果没有-r只能删除文件。</p><p>选项-f表示强制删除，不需要确认。</p><p>目录和文件列表中间用空格分隔。</p><p>示例：</p><p>1）删除当前工作目录下匹配*.log的文件。</p><p><mark>rm *.log</mark></p><p>2）强制删除当前工作目录下匹配*.log的文件。</p><p><mark>rm -f *.log</mark></p><p>3）删除/tmp/aaa目录和文件。</p><p><mark>rm -r /tmp/aaa</mark></p><p>4）强制删除/tmp目录下匹配exp*的全部目录和文件。</p><p><mark>rm -rf /tmp/exp*</mark></p><p>5）强制删除当前工作目录下的book和book.c文件</p><p><mark>rm -rf book book.c</mark></p><h2 id="13、移动目录和文件">13、移动目录和文件</h2><p><mark>mv 旧目录或文件名 新目录或文件名</mark></p><p>如果第二个参数是已经存在的目录，则把第一个参数（旧目录或文件名）移动到该目录中。</p><p>示例：</p><p>1）把当前工作目录中的book.c文件重命名为book1.c</p><p><mark>mv book.c book1.c</mark></p><p>2）如果/tmp/test3是一个已经存在的目录，以下命令将把当前工作目录下的book.c文件移动到/tmp/test3目录中。</p><p><mark>mv book.c /tmp/test3</mark></p><p>3）如果/tmp/test3目录不存在，以下命令将把当前工作目录下的book.c文件改名为/tmp/test3。</p><p><mark>mv book.c /tmp/test3</mark></p><h2 id="14、复制目录和文件">14、复制目录和文件</h2><p><mark>cp [-r] 旧目录或文件名 新目录或文件名</mark></p><p>选项-r可以复制目录，如果没有选项-r只能复制文件。</p><p>示例：</p><p>1）把当前工作目录下的book1.c文件复制为book2.c</p><p><mark>cp book1.c book2.c</mark></p><p>2）把当前工作目录下的aaa目录复制为bbb</p><p><mark>cp -r aaa bbb</mark></p><p>3）把当前工作目录下的book1.c文件复制为/tmp/book1.c</p><p><mark>cp book1.c /tmp/book1.c</mark></p><p><mark>cp book1.c /tmp/.</mark></p><p>以上两个命令的效果相同。</p><p>4）把当前工作目录下的aaa目录复制为/tmp/aaa</p><p><mark>cp -r aaa /tmp/aaa</mark></p><p><mark>cp -r aaa /tmp/.</mark></p><p>以上两个命令的效果相同。</p><h2 id="15、打包压缩和解包解压">15、打包压缩和解包解压</h2><p>tar命令用来打包压缩和解包解压文件，类似windows的winrar工具。</p><p><strong>语法：tar  选项[-zcf] [压缩后文件名] [目录]</strong></p><p><strong>-c    打包</strong></p><p><strong>-v    显示详细信息</strong></p><p><strong>-f     指定文件名</strong></p><p><strong>-z     打包同时压缩</strong></p><p>示例：</p><p>1）把当前工作目录的aaa、bbb和ccc目录打包压缩成123.tgz文件。</p><p><mark>tar zcvf 123.tgz aaa bbb ccc</mark></p><p>2）把/home/oracle/aaa、/home/oracle/bbb和/home/oracle/ccc目录打包压缩成/tmp/123.tgz文件。</p><p><mark>tar zcvf /tmp/123.tgz /home/oracle/aaa /home/oracle/bbb /home/oracle/ccc</mark></p><p><strong>tar命令解压缩语法：</strong></p><p><strong>-x     解包</strong></p><p><strong>-v    显示详细信息</strong></p><p><strong>-f     指定解压文件</strong></p><p><strong>-z     解压缩</strong></p><p>示例：</p><p>1）把/tmp/123.tgz压缩包文件在当前工作目录下解压。</p><p><mark>tar zxvf /tmp/123.tgz</mark></p><p>2）把/tmp/123.tgz压缩包文件在/tmp/aaa目录下解压。</p><p><mark>cd /tmp/aaa</mark></p><p><mark>tar zxvf /tmp/123.tgz</mark></p><p>注意：</p><p>1）用tar命令打包和解包的目录和文件没有绝对路径的说法，都成了相对的，在包中相对的。</p><p>2）用tar命令打包的文件，用winrar可以解开。</p><p>3）在Linux系统中，还有其它的打包压缩和解包解压命令，例如zip/unzip和gzip/gunzip。</p><h2 id="16、判断网络是否连通">16、判断网络是否连通</h2><p>Windows系统：</p><p><mark>ping -n 包的个数 ip地址或域名</mark></p><p>Linux系统：</p><p><mark>ping -c 包的个数 ip地址或域名</mark></p><p>ping用于确定本地主机是否能与另一台主机成功交换数据包，判断网络是否通畅。</p><p>127.0.0.1是指本地的ip地址，ping 127.0.0.1总是可以通的。</p><p>示例：</p><p>1）向本地主机（127.0.0.1）ping五个包。</p><p><mark>ping -c 5 127.0.0.1</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98b3a77.png" alt="图片9.png"></p><p>2）向百度（<a href="http://www.baidu.com">www.baidu.com</a>）的服务器ping五个包。</p><p><img src="https://bu.dusays.com/2022/12/30/63aebd98b4709.png" alt="图片10.png"></p><p>百度的服务器是可以ping通的。</p><p>3）向谷歌（<a href="http://www.google.com">www.google.com</a>）的服务器ping五个包。</p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9968bae.png" alt="图片11.png"></p><p>谷歌的服务器是ping不通的。</p><h2 id="17、显示文本文件的内容">17、显示文本文件的内容</h2><p>显示文本文件的内容有三个命令：cat、more和tail。</p><p>1）cat命令</p><p><mark>cat 文件名</mark></p><p>cat命令一次显示整个文件的内容。</p><p><mark>cat main.cpp</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9989936.png" alt="图片12.png"></p><p>2）more命令</p><p><mark>more 文件名</mark></p><p>为了方便阅读，more命令分页显示文件的内容，按空格键显示下一页，按b键显上一页，按q键退出。</p><p>3）tail命令</p><p><mark>tail -f 文件名</mark></p><p>tail -f用于显示文本文件的最后几行，如果文件的内容有增加，就实时的刷新。对程序员来说，tail -f极其重要，可以动态显示后台服务程序的日志，用于调试和跟踪程序的运行。</p><h2 id="18、统计文本文件的行数、单词数和字节数">18、统计文本文件的行数、单词数和字节数</h2><p><mark>wc 文件名</mark></p><p>示例：</p><p>1）统计当前工作目录处book2*.c文件的行数、单词数和字节数。</p><p><mark>wc book2*.c</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd99a4327.png" alt="图片13.png"></p><h2 id="19、搜索文件中的内容">19、搜索文件中的内容</h2><p><mark>grep “内容” 文件名</mark></p><p>注意，如果内容中没有空格等特殊字符，可以不用双引号括起来。</p><p>示例：</p><p>1）在*.cpp文件中搜索thread</p><p><mark>grep thread *.cpp</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd99d076e.png" alt="图片14.png"></p><h2 id="20、搜索文件">20、搜索文件</h2><p><mark>find 目录名 -name 文件名 -print</mark></p><p>参数说明：</p><p>目录名：待搜索的目录，搜索文件的时候，除了这个目录名，还包括它的各级子目录。</p><p>文件名：待搜索的文件名匹配的规则。</p><p>示例：</p><p>1）从/tmp目录开始搜索，把全部的*.c文件显示出来。</p><p><mark>find /tmp -name *.c -print</mark></p><p>2）从当前工作目录开始搜索，把全部的*.c文件显示出来。</p><p><mark>find . -name *.c -print</mark></p><h2 id="21-、文件权限类">21 、文件权限类</h2><h3 id="21-1-文件属性">21.1 文件属性</h3><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属 的用户和组。</p><p><strong>1）从左到右的 10个字符表示，如图所示</strong></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9a03a67.png" alt="图片15.png"><br>如果没有权限，就会出现减号[ - ]。从左至右用0-9这些数字来表示:</p><p>（1）0首位表示类型 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等</p><ul class="lvl-0"><li class="lvl-2"><p>-代表文件</p></li><li class="lvl-2"><p>d 代表目录</p></li><li class="lvl-2"><p>l 链接文档(link file)；</p></li></ul><p>（2）第1-3位确定属主（该文件的所有者）拥有该文件的权限。—User</p><p>（3）第4-6位确定属组（所有者的同组用户）拥有该文件的权限，—Group</p><p>（4）第7-9位确定其他用户拥有该文件的权限 —Other<br><strong>2）rwx作用文件和目录的不同解释</strong></p><p>（1）作用到文件：</p><ul class="lvl-0"><li class="lvl-2"><p>[ r ]代表可读(read): 可以读取，查看</p></li><li class="lvl-2"><p>[ w ]代表可写(write): 可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.</p></li><li class="lvl-2"><p>[ x ]代表可执行(execute):可以被系统执行</p></li></ul><p>（2）作用到目录：</p><ul class="lvl-0"><li class="lvl-2"><p>[ r ]代表可读(read): 可以读取，可以ls查看目录内容</p></li><li class="lvl-2"><p>[ w ]代表可写(write): 可以修改，目录内创建+删除+重命名目录</p></li><li class="lvl-2"><p>[ x ]代表可执行(execute):可以进入该目录</p></li></ul><p><img src="https://bu.dusays.com/2022/12/30/63aebd9a2c723.png" alt="图片16.png"></p><p>（1）如果查看到是文件：链接数指的是硬链接个数。 （2）如果查看的是文件夹：链接数指的是子文件夹个数。</p><h3 id="21-2-chmod-改变权限">21.2 chmod 改变权限</h3><p>1）基本语法 如图 所示<img src="https://bu.dusays.com/2022/12/30/63aebd9a4b220.png" alt="图片17.png"><br>第一种方式变更权限</p><p><mark>chmod [{ugoa}{±=}{rwx}] 文件或目录</mark>第二种方式变更权限</p><p><mark>chmod [mode=421 ] [文件或目录]</mark><br>2）参数含义<br><mark>u:所属用户  g:所属组  o:其他人用户 a:所有人(u、g、o的总和)</mark></p><p>r=4 w=2 x=1 rwx=4+2+1=7<br>3）案例</p><p>(1)让houge.txt文件的所属用户具有执行权限<br><mark>chmod u+x houge.txt</mark><br>(2)让houge.txt文件的所属组具有执行权限<br><mark>chmod g+x houge.txt</mark></p><p>(3)去除houge.txt所属用户的执行权限,使其他用户具有执行权限<br><mark>chmod u-x,o+x houge.txt</mark></p><p>(4)采用数字的方式，设置文件所有者、所属组、其他用户都具有可读可写可执行权限。</p><p><mark>chmod 777 houge.txt</mark></p><p>(5)修改整个文件夹里面的所有文件的所有者、所属组、其他用户都具有可读可写可执行权限。</p><p><mark>chmod -R 777 xiyou/</mark></p><h2 id="22、用户组管理命令">22、用户组管理命令</h2><h3 id="22-1-增加用户组">22.1 增加用户组</h3><p><mark>groupadd 组名</mark></p><p>例如：</p><p><mark>groupadd dba</mark></p><h3 id="22-2-删除用户组">22.2 删除用户组</h3><p><mark>groupdel 组名</mark></p><p>例如：</p><p><mark>groupdel dba</mark></p><h3 id="22-3-查看创建了哪些组">22.3 查看创建了哪些组</h3><p><mark>cat /etc/group</mark></p><h2 id="23、用户管理命令">23、用户管理命令</h2><h3 id="23-1-增加用户">23.1 增加用户</h3><p><mark>useradd -n 用户名 -g 组名 -d 用户的主目录</mark></p><p>例如增加一个用户，用户名为jay，属于dba组，用户的主目录是/home/jay</p><p><mark>useradd -n jay -g dba -d /home/jay</mark></p><h3 id="23-2-删除用户">23.2 删除用户</h3><p><mark>userdel 用户名</mark></p><p>例如删除wucz用户。</p><p><mark>userdel jay</mark></p><h3 id="23-3-passwd设置用户密码">23.3 passwd设置用户密码</h3><p><mark>passwd [用户名]</mark></p><p>修改用户的密码，按提示两次输入新密码，如果两次输入的密码相同就修改成功。</p><p>普通用户只能修改自己的密码，只输入passwd就可以了，不能指定用户名。</p><p>系统管理员可以修改任何用户的密码，passwd后需要指定用户名。</p><p>例如设置用户jay的密码</p><p><mark>passwd jay</mark></p><h3 id="23-4-id查看用户是否存在">23.4 id查看用户是否存在</h3><p>例如查看用户jay是否存在</p><p><mark>id jay</mark></p><h3 id="23-5-查看创建了哪些用户">23.5 查看创建了哪些用户</h3><p><mark>cat /etc/passwd</mark></p><h3 id="23-6-切换用户">23.6 切换用户</h3><p>在命令提示符下输入： <mark>su</mark>，然后按提示输入root的密码后将切换到root用户。</p><p>从root用户切换到其它普通用户不需要输入密码，从普通用户切换到任何用户都需要输入密码。</p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9a63506.png" alt="图片18.png"></p><h2 id="24、修改目录和文件的主人和组">24、修改目录和文件的主人和组</h2><p><strong>chown 改变所有者</strong></p><p><mark>chown [-R] 用户名:组名 目录或文件名列表</mark></p><p>chown将目录或文件的拥有者修改为参数指定的用户名和组，目录或文件名列表用空格分隔。</p><p>-R 选项表示递归处理各级子目录。</p><p>示例：</p><p>1）将main.cpp的所有者改为jay</p><p><mark>chown jay main.cpp</mark></p><p>2）把/oracle/home和/oracle/base及其子目录的主人改为oracle，组改为dba。</p><p><mark>chown -R oracle:dba /oracle/home /oracle/base</mark></p><p><strong>chgrp 改变所属组</strong></p><p><mark>基本语法 chgrp [最终用户组] [文件或目录] （功能描述：改变文件或者目录的所属组）</mark></p><p>示例：</p><p>1）将main.cpp的组改为root</p><p><mark>chgrp root main.cpp</mark></p><h2 id="25、-磁盘查看和分区类">25、 磁盘查看和分区类</h2><h3 id="25-1-df查看磁盘空间使用情况">25.1 df查看磁盘空间使用情况</h3><p><mark>df  [选项] [挂载点</mark></p><p>选项：</p><p>-a 显示所有的文件系统信息，包括特殊文件系统，如 /proc、/sysfs</p><p>-h 使用习惯单位显示容量，如KB，MB或GB等</p><p>-T 显示文件系统类型</p><p>-m 以MB为单位显示容量</p><p>-k 以KB为单位显示容量。默认就是以KB为单位</p><p>示例：</p><p>查看磁盘使用情况:</p><p><mark>df -h</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9a87532.png" alt="图片19.png"></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9aad16b.png" alt="图片20.png"></p><h3 id="25-2-du查看文件和目录占用的磁盘空间">25.2 du查看文件和目录占用的磁盘空间</h3><p><mark>du [选项] [目录或文件名]</mark></p><p>选项：</p><p>-a 显示每个子文件的磁盘占用量。默认只统计 子目录的磁盘占用量</p><p>-h 使用习惯单位显示磁盘占用量，如KB，MB  或GB等</p><p>-s 统计总占用量，而不列出子目录和子文件的 占用量</p><p>示例：</p><p>查看当前用户主目录占用的磁盘空间大小:</p><p><mark>du -sh</mark></p><p><img src="https://bu.dusays.com/2022/12/30/63aebd9ac8cf6.png" alt="图片21.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法快速入门</title>
      <link href="/posts/1bca9758.html"/>
      <url>/posts/1bca9758.html</url>
      
        <content type="html"><![CDATA[<!-- #                    Markdown语法快速入门 --><h2 id="1-代码块：">1.代码块：</h2><p>三个飘号组成：```+语言</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//代码块语法：</span><br><span class="line"><span class="code">```+语言</span></span><br><span class="line"><span class="code">```</span>java</span><br><span class="line"><span class="code">```shell</span></span><br></pre></td></tr></table></figure><h2 id="2-标题">2.标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题    </span></span><br><span class="line"><span class="section">###### 六级标题   </span></span><br><span class="line">CTRL+shift+1能看到大纲</span><br></pre></td></tr></table></figure><h2 id="3-字体">3.字体</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//加粗</span><br><span class="line"><span class="strong">**加粗的语言**</span></span><br><span class="line">//代码高亮显示</span><br><span class="line">==具体高亮的内容==</span><br><span class="line">//删除线</span><br><span class="line">~~被删除的文字~~</span><br><span class="line">//斜体</span><br><span class="line"><span class="emphasis">*斜体的内容*</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//加粗</p><p><strong>加粗的语言</strong></p><p>//代码高亮显示</p><p><mark>具体高亮的内容</mark></p><p>//删除线</p><p><s>被删除的文字</s></p><p>//斜体</p><p><em>斜体的内容</em></p><h2 id="4-引用">4.引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\\引用语法</span><br><span class="line">&gt;作者:billysturate</span><br><span class="line">&gt;&gt;作者:billysturate</span><br><span class="line">&gt;&gt;&gt;作者:billysturate</span><br><span class="line">&gt;&gt;&gt;&gt;作者:billysturate </span><br></pre></td></tr></table></figure><blockquote><p>作者:billysturate</p><blockquote><p>作者:billysturate</p><blockquote><p>作者:billysturate</p><blockquote><p>作者:billysturate</p></blockquote></blockquote></blockquote></blockquote><h2 id="5-分割线">5.分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">//分割线</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line">//分割线2</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><hr><hr><h2 id="6-图片插入">6.图片插入</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在线图片/本地图片</span><br><span class="line">![<span class="string">我的照片</span>](<span class="link">图片的路径</span>)</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2022/12/30/63aebaf125b6f.jpg" alt="jay.jpg"></p><h2 id="7-超链接">7.超链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//超链接语法</span><br><span class="line">[<span class="string">我的GitHub</span>](<span class="link">https://github.com/</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/">我的GitHub</a></p><h2 id="8-列表语法">8.列表语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//无需列表</span><br><span class="line"><span class="bullet">+</span> 目录1</span><br><span class="line"><span class="bullet">+</span> 目录2</span><br><span class="line"><span class="bullet">+</span> 目录3  </span><br><span class="line">  </span><br><span class="line">//有序列表</span><br><span class="line"><span class="bullet">1.</span> 序号1</span><br><span class="line"><span class="bullet">2.</span> 序号2</span><br><span class="line"><span class="bullet">3.</span> 序号3</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>目录1</p></li><li class="lvl-2"><p>目录2</p></li><li class="lvl-2"><p>目录3</p></li></ul><ol><li class="lvl-3"><p>序号1</p></li><li class="lvl-3"><p>序号2</p></li><li class="lvl-3"><p>序号3</p></li></ol><h2 id="9-表格">9.表格</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl+/显示源码</span><br><span class="line">ctrl+shift+1 显示目录 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>VR</title>
      <link href="/VR/index.html"/>
      <url>/VR/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="VR">VR</h2><div style ="position: relative ; width :100%; height: 0; padding-bottom:75%;"><iframe src ="https://www.jsvry.com/p/WoXD212z9m?scene_id=87152" scrolling ="no" border="0" frameborder="no" framespacing ="0" allowfullscreen ="true" style =" position: absolute; width :100%; height :100%; left:0; top:0;" ></iframe></div > I ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Vlog分享</title>
      <link href="/Vlog/index.html"/>
      <url>/Vlog/index.html</url>
      
        <content type="html"><![CDATA[<div style ="position: relative ; width :100%; height: 0; padding-bottom:75%;"><iframe src ="//player.bilibili.com/player.html?aid=855383917&bvid=BV1KL4y1w7rm&cid=758916509&page=1" scrolling ="no" border="0" frameborder="no" framespacing ="0" allowfullscreen ="true" style =" position: absolute; width :100%; height :100%; left:0; top:0;" ></iframe></div > I ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: "ZhuZiAYuanJWD";  }  h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }  .bangumi-info-item {    border-right: 1px solid #f2b94b;  }  .bangumi-info-item span {    color: #f2b94b;  }  .bangumi-info-item em {    color: #f2b94b;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme="dark"] .card-widget {    background: #121212 !important;  }    [data-theme="dark"] div#post {    background: #121212 !important;  }    [data-theme="dark"] div#tag {    background: #121212 !important;  }    [data-theme="dark"] div#archive {    background: #121212 !important;  }    [data-theme="dark"] div#page {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }    #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #3b70fc;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* 鼠标图标 */  body {    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur), auto;  }  a,  [type="button"]:not(:disabled),  [type="reset"]:not(:disabled),  [type="submit"]:not(:disabled),  button:not(:disabled) {    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/pointer.cur), auto !important;  }  /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    #home_top {    margin: 1rem auto 0;    padding: 0px 15px;    max-width: 1450px;    width: 100%;  }  /* 翻页按钮居中 */  #pagination {    width: 100%;    margin: auto;  }  /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }  ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>便携小空调 - 为你的夏日带去清凉!</title>
      <link href="/air-conditioner/index.html"/>
      <url>/air-conditioner/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>终于为博客安装上了便携小空调</p></blockquote><style>.copyright-box a {  border-bottom: none !important;  padding: 0 !important;}</style><div id="air-conditioner-vue"></div><script defer data-pjax src='https://alist.anzhiy.cn/d/anzhiyu/air-conditioner-dev/index.2d8c3a3f.js'></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/head_wave.css"/>
      <url>/css/head_wave.css</url>
      
        <content type="html"><![CDATA[/* 波浪css */.main-hero-waves-area {    width: 100%;    position: absolute;    left: 0;    bottom: -11px;    z-index: 5;  }  .waves-area .waves-svg {    width: 100%;    height: 5rem;  }  /* Animation */    .parallax > use {    animation: move-forever 25s cubic-bezier(0.55, 0.5, 0.45, 0.5) infinite;  }  .parallax > use:nth-child(1) {    animation-delay: -2s;    animation-duration: 7s;    fill: #f7f9febd;  }  .parallax > use:nth-child(2) {    animation-delay: -3s;    animation-duration: 10s;    fill: #f7f9fe82;  }  .parallax > use:nth-child(3) {    animation-delay: -4s;    animation-duration: 13s;    fill: #f7f9fe36;  }  .parallax > use:nth-child(4) {    animation-delay: -5s;    animation-duration: 20s;    fill: #f7f9fe;  }  /* 黑色模式背景 */  [data-theme="dark"] .parallax > use:nth-child(1) {    animation-delay: -2s;    animation-duration: 7s;    fill: #18171dc8;  }  [data-theme="dark"] .parallax > use:nth-child(2) {    animation-delay: -3s;    animation-duration: 10s;    fill: #18171d80;  }  [data-theme="dark"] .parallax > use:nth-child(3) {    animation-delay: -4s;    animation-duration: 13s;    fill: #18171d3e;  }  [data-theme="dark"] .parallax > use:nth-child(4) {    animation-delay: -5s;    animation-duration: 20s;    fill: #18171d;  }    @keyframes move-forever {    0% {      transform: translate3d(-90px, 0, 0);    }    100% {      transform: translate3d(85px, 0, 0);    }  }  /*Shrinking for mobile*/  @media (max-width: 768px) {    .waves-area .waves-svg {      height: 40px;      min-height: 40px;    }  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/color.css"/>
      <url>/css/color.css</url>
      
        <content type="html"><![CDATA[/* 颜色 */:root {    --anzhiyu-theme-op: #4259ef23;    --anzhiyu-gray-op: #9999992b;    --anzhiyu-theme-top: var(--anzhiyu-theme);    --anzhiyu-white: #fff;    --anzhiyu-white-op: rgba(255, 255, 255, 0.2);    --anzhiyu-black: #000;    --anzhiyu-black-op: rgba(0, 0, 0, 0.2);    --anzhiyu-none: rgba(0, 0, 0, 0);    --anzhiyu-gray: #999999;    --anzhiyu-yellow: #ffc93e;    --anzhiyu-border-radius: 8px;    --anzhiyu-main: var(--anzhiyu-theme);    --anzhiyu-main-op: var(--anzhiyu-theme-op);    --anzhiyu-shadow-theme: 0 8px 12px -3px var(--anzhiyu-theme-op);    --anzhiyu-shadow-main: 0 8px 12px -3px var(--anzhiyu-main-op);    --anzhiyu-shadow-blue: 0 8px 12px -3px rgba(40, 109, 234, 0.2);    --anzhiyu-shadow-white: 0 8px 12px -3px rgba(255, 255, 255, 0.2);    --anzhiyu-shadow-black: 0 0 12px 4px rgba(0, 0, 0, 0.05);    --anzhiyu-shadow-yellow: 0px 38px 77px -26px rgba(255, 201, 62, 0.12);    --anzhiyu-shadow-red: 0 8px 12px -3px #ee7d7936;    --anzhiyu-shadow-green: 0 8px 12px -3px #87ee7936;    --anzhiyu-shadow-border: 0 8px 16px -4px #2c2d300c;    --anzhiyu-shadow-blackdeep: 0 2px 16px -3px rgba(0, 0, 0, 0.15);    --anzhiyu-logo-color: linear-gradient(215deg, #4584ff 30%, #ff7676 70%);    --style-border: 1px solid var(--anzhiyu-card-border);    --anzhiyu-blue-main: #3b70fc;    --style-border-hover: 1px solid var(--anzhiyu-main);    --style-border-dashed: 1px dashed var(--anzhiyu-theme-op);    --style-border-avatar: 4px solid var(--anzhiyu-background);    --style-border-always: 1px solid var(--anzhiyu-card-border);    --anzhiyu-white-acrylic1: #fefeff !important;    --anzhiyu-white-acrylic2: #fcfdff !important;    --anzhiyu-black-acrylic2: #08080a !important;    --anzhiyu-black-acrylic1: #0b0b0e !important;    --anzhiyu-main-none: #b8b8b800 !important;  }    [data-theme="light"] {    --anzhiyu-theme: #3b70fc;    --anzhiyu-theme-op: #4259ef23;    --anzhiyu-blue: #3b70fc;    --anzhiyu-red: #d8213c;    --anzhiyu-pink: #ff7c7c;    --anzhiyu-green: #57bd6a;    --anzhiyu-fontcolor: #363636;    --anzhiyu-background: #f7f9fe;    --anzhiyu-reverse: #000;    --anzhiyu-maskbg: rgba(255, 255, 255, 0.6);    --anzhiyu-maskbgdeep: rgba(255, 255, 255, 0.85);    --anzhiyu-hovertext: var(--anzhiyu-theme);    --anzhiyu-ahoverbg: #f7f7fa;    --anzhiyu-lighttext: var(--anzhiyu-main);    --anzhiyu-secondtext: rgba(60, 60, 67, 0.6);    --anzhiyu-scrollbar: rgba(60, 60, 67, 0.4);    --anzhiyu-card-btn-bg: #edf0f7;    --anzhiyu-post-blockquote-bg: #fafcff;    --anzhiyu-post-tabs-bg: #f2f5f8;    --anzhiyu-secondbg: #edf0f7;    --anzhiyu-shadow-nav: 0 5px 12px -5px rgba(102, 68, 68, 0.05);    --anzhiyu-card-bg: #fff;    --anzhiyu-shadow-lightblack: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-shadow-light2black: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-card-border: #c0c6d8;  }    [data-theme="dark"] {    --global-bg: #191919;    --anzhiyu-theme: #0084ff;    --anzhiyu-theme-op: #0084ff23;    --anzhiyu-blue: #0084ff;    --anzhiyu-red: #ff3842;    --anzhiyu-pink: #ff7c7c;    --anzhiyu-green: #57bd6a;    --anzhiyu-fontcolor: #f7f7fa;    --anzhiyu-background: #18171d;    --anzhiyu-reverse: #fff;    --anzhiyu-maskbg: rgba(0, 0, 0, 0.6);    --anzhiyu-maskbgdeep: rgba(0, 0, 0, 0.85);    --anzhiyu-hovertext: #0a84ff;    --anzhiyu-ahoverbg: #fff;    --anzhiyu-lighttext: #f2b94b;    --anzhiyu-secondtext: #a1a2b8;    --anzhiyu-scrollbar: rgba(200, 200, 223, 0.4);    --anzhiyu-card-btn-bg: #30343f;    --anzhiyu-post-blockquote-bg: #000;    --anzhiyu-post-tabs-bg: #121212;    --anzhiyu-secondbg: #30343f;    --anzhiyu-shadow-nav: 0 5px 20px 0px rgba(28, 28, 28, 0.4);    --anzhiyu-card-bg: #1d1b26;    --anzhiyu-shadow-lightblack: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-shadow-light2black: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-card-border: #42444a;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/home_top.css"/>
      <url>/css/home_top.css</url>
      
        <content type="html"><![CDATA[#home_top {    margin: 1rem auto 0;    padding: 0px 15px;    max-width: 1450px;    width: 100%;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/loading.css"/>
      <url>/css/loading.css</url>
      
        <content type="html"><![CDATA[.loading-img {    background: url(https://bu.dusays.com/2023/03/16/641320d8433fd.png) no-repeat center center;    background-size: cover;  }  ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/progress_bar.css"/>
      <url>/css/progress_bar.css</url>
      
        <content type="html"><![CDATA[.pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 10px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 4rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden;  }    .pace-inactive .pace-progress {    opacity: 0;    transition: 0.3s ease-in;  }    .pace .pace-progress {    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    -o-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);    animation: gradient 1.5s ease infinite;    background-size: 200%;  }    .pace.pace-inactive {    opacity: 0;    transition: 0.3s;    top: -8px;  }  @keyframes gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/rightmenu.css"/>
      <url>/css/rightmenu.css</url>
      
        <content type="html"><![CDATA[#rightMenu {    display: none;    position: fixed;    padding: 0 .25rem;    width: 9rem;    height: fit-content;    top: 10%;    left: 10%;    background-color: rgba(238, 255, 255, .85);    -webkit-backdrop-filter: blur(20px);    backdrop-filter: blur(20px);    color: #363636;    border-radius: 12px;    z-index: 99994;    border: #e3e8f7;    user-select: none;    box-shadow: rgba(0, 0, 0, .05);}#rightMenu a {    color: #363636;}#rightMenu .rightMenu-group {    padding: .35rem .3rem;    transition: .3s}#rightMenu .rightMenu-line {    border-top: 1px dashed #4259ef23}#rightMenu .rightMenu-group.rightMenu-small {    display: flex;    justify-content: space-between}#rightMenu .rightMenu-group .rightMenu-item {    border-radius: 8px;    transition: .3s;    cursor: pointer}#rightMenu .rightMenu-line .rightMenu-item {    margin: .25rem 0;    padding: .25rem 0}#rightMenu .rightMenu-group.rightMenu-line .rightMenu-item {    display: flex}#rightMenu .rightMenu-group .rightMenu-item:hover {    background-color: #6f42c1;    color: #fff;}#rightMenu .rightMenu-group .rightMenu-item:active {    transform: scale(.97)}#rightMenu .rightMenu-group .rightMenu-item i {    display: inline-block;    text-align: center;    line-height: 1.5rem;    width: 1.5rem;    padding: 0 .25rem}#rightMenu .rightMenu-line .rightMenu-item i {    margin: 0 .25rem}#rightMenu .rightMenu-group .rightMenu-item span {    line-height: 1.5rem}.rightMenu-small .rightMenu-item {    width: 30px;    height: 30px;    line-height: 30px}#rightmenu-mask {    position: fixed;    width: 100vw;    height: 100vh;    background: 0 0;    top: 0;    left: 0;    display: none;    z-index: 101;    margin: 0 !important;    z-index: 99993}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/nav_menu.css"/>
      <url>/css/nav_menu.css</url>
      
        <content type="html"><![CDATA[#nav a:hover {    background: var(--anzhiyu-main);    /* background: var(--anzhiyu-white); */    transition: 0.3s;  }    #nav-totop:hover .totopbtn i {    opacity: 1;  }  #nav-totop #percent {    font-size: 12px;    background: var(--anzhiyu-white);    color: var(--anzhiyu-main);    width: 25px;    height: 25px;    border-radius: 35px;    display: flex;    justify-content: center;    align-items: center;    transition: 0.3s;  }  .nav-fixed #nav-totop #percent,  .page #nav-totop #percent {    background: var(--font-color);    color: var(--card-bg);    font-size: 13px;  }    #nav-totop {    width: 35px;  }  #page-header:not(.is-top-bar) #percent {    transition: 0.3s;  }  #page-header:not(.is-top-bar) #nav-totop {    width: 0;    opacity: 0;    transition: width 0.3s, opacity 0.2s;    margin-left: 0 !important;  }  #nav-totop #percent {    font-weight: 700;  }  #nav-totop:hover #percent {    opacity: 0;    transform: scale(1.5);    font-weight: 700;  }  #page-header #nav #nav-right div {    margin-left: 0.5rem;    padding: 0;  }    #nav-totop {    display: flex;    align-items: center;    justify-content: center;    transition: 0.3s;  }  .nav-button {    cursor: pointer;  }  div#menus {    display: flex;    align-items: center;  }  #page-header #nav .nav-button a {    height: 35px;    width: 35px;    display: flex;    align-items: center;    justify-content: center;  }    #nav .site-page {    padding-bottom: 0px;  }  #nav *::after {    background-color: transparent !important;  }    /* 顶栏修改 */  #nav .menus_items .menus_item .menus_item_child li a {    padding: 2px 16px;  }  #nav .menus_items .menus_item .menus_item_child li:hover a {    color: white !important;  }    #nav .menus_items .menus_item .menus_item_child li {    margin: 6px;    border-radius: 5px;    transition: all 0.3s;    display: inline-block;    margin: 0 3px;  }  #nav .menus_items .menus_item .menus_item_child:before {    top: -19px;  }  #site-name,  .shuoshuo {    white-space: nowrap;    overflow: hidden;  }  #site-name {    padding: 0 8px;    position: relative;    display: flex;    align-items: center;    justify-content: center;    transition: 0.3s;  }    #blog_name #site-name i {    opacity: 0;    position: absolute;  }    #blog_name #site-name:hover .title {    opacity: 0;  }    #blog_name #site-name:hover i {    opacity: 1;    transform: scale(1.01);    color: white;  }  /* 圆角隐藏 */  ul.menus_item_child {    border-radius: 5px;  }    /* 一级菜单居中 */  #nav .menus_items {    font-size: 22px;    position: absolute;    width: fit-content;    left: 50%;    transform: translateX(-50%);    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    height: 60px;  }    #nav .menus_items .menus_item:hover .menus_item_child {    display: block;    transform: translateX(-50%);    right: auto;    left: auto !important;    padding: 6px 4px;    box-sizing: content-box;    line-height: 35px;  }  #nav .menus_items .menus_item:hover {    padding: 0 5px 27px 5px !important;    margin-bottom: -14.5px !important;  }    #nav .menus_items .menus_item .menus_item_child {    top: 44px;  }    @media screen and (min-width: 768px) {    .page .menus_item:hover > a.site-page {      color: var(--anzhiyu-white) !important;      background: var(--anzhiyu-main);      transition: 0.3s;      box-shadow: var(--anzhiyu-shadow-main);    }  }    .nav-fixed #nav {    transform: translateY(58px) !important;  }  #nav {    padding: 0 calc((100% - 1420px) / 2);    backdrop-filter: saturate(180%) blur(20px);  }    #nav a {    border-radius: 8px;    color: var(--font-color);  }  .page #nav a:hover {    color: var(--anzhiyu-white) !important;    background: var(--anzhiyu-main);    transition: 0.3s;    box-shadow: var(--anzhiyu-shadow-main);  }    #menus > div.menus_items > div > a {    letter-spacing: 0.3rem;    font-weight: 700;    padding: 0em 0.3em 0em 0.5em;    height: 35px;    line-height: 35px;  }  #nav .menus_items .menus_item {    padding: 0 5px;    display: flex;    flex-direction: column;    margin: auto;    align-items: center;  }    #nav div#toggle-menu {    padding: 2px 0 4px 6px;  }    #nav-totop .totopbtn i {    position: absolute;    display: flex;    opacity: 0;  }  #page-name::before {    font-size: 18px;    position: absolute;    width: 100%;    height: 100%;    border-radius: 8px;    color: white !important;    top: 0;    left: 0;    content: "回到顶部";    background-color: var(--anzhiyu-theme);    transition: all 0.3s;    -webkit-transition: all 0.3s;    -moz-transition: all 0.3s;    -ms-transition: all 0.3s;    -o-transition: all 0.3s;    opacity: 0;    box-shadow: 0 0 3px var(--anzhiyu-theme);    line-height: 45px; /*如果垂直位置不居中可以微调此值，也可以删了*/  }  #page-name:hover:before {    opacity: 1;  }  #name-container {    transition: all 0.3s;    -webkit-transition: all 0.3s;    -moz-transition: all 0.3s;    -ms-transition: all 0.3s;    -o-transition: all 0.3s;  }  #name-container:hover {    transform: translateX(-50%) scale(1.03);  }  #page-name {    position: relative;    padding: 10px 30px;  }    center#name-container {    position: absolute;    width: 100%;    left: 50%;    transform: translateX(-50%);    font-family: "ZhuZiAYuanJWD";  }  .nav-fixed.nav-visible #name-container {    transition: 0.3s;    transform: translate(-50%, 60px);  }  .nav-fixed.nav-visible #menus .menus_items {    transform: translate(-50%);    transition: 0.3s;    line-height: 60px;  }  .nav-fixed #menus .menus_items {    transform: translate(-50%, -60px);    transition: 0.3s;  }  .nav-fixed #name-container {    top: 15%;    transition: 0.3s;  }  #name-container {    bottom: 60px;  }    .mask-name-container {    max-width: 1200px;    width: 50%;    height: 100%;    position: absolute;    overflow: hidden;    left: 50%;    transform: translateX(-50%);  }    @media screen and (max-width: 992px) {    .mask-name-container {      width: 65%;    }  }    @media screen and (max-width: 768px) {    .mask-name-container {      display: none;    }  }  #sidebar #sidebar-menus .menus_items .site-page:hover {    color: var(--anzhiyu-white);    border-radius: var(--anzhiyu-border-radius);  }  #nav .menus_items .menus_item > a > i:last-child {    display: none;  }  #nav #search-button {    font-size: 1.3em;  }    @media screen and (min-width: 900px) {    #nav .back-home-button:hover {      box-shadow: var(--anzhiyu-shadow-main);    }  }    .back-home-button:hover {    background: var(--anzhiyu-main);    color: var(--anzhiyu-white) !important;  }  .back-home-button {    display: flex;    width: 35px;    height: 35px;    padding: 0 !important;    align-items: center;    justify-content: center;    margin-right: 4px;    transition: 0.3s;    border-radius: 8px;  }    .back-home-button:hover .back-menu-list-groups {    display: flex;    opacity: 1;    transition: 0.3s;    top: 55px;    pointer-events: auto;    left: 0;  }  .back-home-button .back-menu-list-groups {    position: absolute;    top: 65px;    left: 0;    background: var(--anzhiyu-card-bg);    border-radius: 12px;    border: var(--style-border);    flex-direction: column;    font-size: 12px;    color: var(--anzhiyu-secondtext);    box-shadow: var(--anzhiyu-shadow-border);    transition: 0s;    opacity: 0;    pointer-events: none;  }    .back-home-button .back-menu-list-group {    display: flex;    flex-direction: column;  }  .back-home-button .back-menu-list-group .back-menu-list-title {    margin: 8px 0 0 16px;    transition: 0.3s;  }  .back-home-button .back-menu-list {    display: flex;    flex-direction: column;  }  .back-home-button .back-menu-list::before {    position: absolute;    top: -22px;    left: 0px;    width: 100%;    height: 25px;    content: "";  }    .back-home-button .back-menu-list-group:hover .back-menu-list-title {    color: var(--anzhiyu-main);  }  .back-home-button .back-menu-list-groups:hover {    border: var(--style-border-hover);  }  .back-home-button .back-menu-list .back-menu-item {    display: flex;    align-items: center;    margin: 4px 8px;    padding: 4px 8px !important;    transition: 0.3s;    border-radius: 8px;  }  .back-home-button .back-menu-list .back-menu-item .back-menu-item-text {    font-size: var(--global-font-size);    margin-left: 0.5rem;    color: var(--anzhiyu-fontcolor);    white-space: nowrap;  }  #nav #blog_name {    flex-wrap: nowrap;    height: 60px;    display: flex;    align-items: center;    /* z-index: 102; */    transition: 0.3s;  }  .back-home-button .back-menu-list .back-menu-item .back-menu-item-icon {    width: 24px;    height: 24px;    border-radius: 24px;    background: var(--anzhiyu-secondbg);  }  #page-header #nav .back-home-button {    cursor: pointer;    position: relative;  }    @media screen and (min-width: 1300px) {    #nav a:hover {      transform: scale(1.03);    }  }  .back-home-button .back-menu-list .back-menu-item:hover .back-menu-item-text {    color: var(--anzhiyu-white);  }  .back-menu-item-icon.loading img {    width: 25px;  }    #page-header #nav #menus .nav-button.long a.totopbtn,  #page-header #nav #menus .nav-button.long,  #page-header #nav #menus .nav-button.long a.totopbtn span {    width: 70px;  }  #page-header #nav #menus .nav-button.long a.totopbtn span {    border-radius: 35px;    display: flex;    justify-content: center;    align-items: center;    transition: 0.3s;    white-space: nowrap;  }    #page-header #nav #menus .nav-button.long a.totopbtn:hover {    border-radius: 35px;    height: 30px;  }    #nav #search-button {    padding-left: 0;  }  #page-header #nav .nav-button {    margin-left: 0.5rem;    padding: 0;  }  #page-header:not(.is-top-bar) #nav-totop a {    display: none;  }  #search-button a.site-page.social-icon.search span {    display: none;  }  /* 颜色 */:root {    --anzhiyu-theme-op: #4259ef23;    --anzhiyu-white: #fff;    --anzhiyu-black: #000;    --anzhiyu-none: rgba(0, 0, 0, 0);    --anzhiyu-gray: #999999;    --anzhiyu-yellow: #ffc93e;    --anzhiyu-border-radius: 8px;    --anzhiyu-main: var(--anzhiyu-theme);    --anzhiyu-main-op: var(--anzhiyu-theme-op);    --anzhiyu-shadow-theme: 0 8px 12px -3px var(--anzhiyu-theme-op);    --anzhiyu-shadow-main: 0 8px 12px -3px var(--anzhiyu-main-op);    --anzhiyu-shadow-blue: 0 8px 12px -3px rgba(40, 109, 234, 0.2);    --anzhiyu-shadow-white: 0 8px 12px -3px rgba(255, 255, 255, 0.2);    --anzhiyu-shadow-black: 0 0 12px 4px rgba(0, 0, 0, 0.05);    --anzhiyu-shadow-yellow: 0px 38px 77px -26px rgba(255, 201, 62, 0.12);    --anzhiyu-shadow-red: 0 8px 12px -3px #ee7d7936;    --anzhiyu-shadow-green: 0 8px 12px -3px #87ee7936;    --anzhiyu-shadow-border: 0 8px 16px -4px #2c2d300c;    --anzhiyu-logo-color: linear-gradient(215deg, #4584ff 30%, #ff7676 70%);    --style-border: 1px solid var(--anzhiyu-card-border);    --anzhiyu-blue-main: #3b70fc;    --style-border-hover: 1px solid var(--anzhiyu-main);    --style-border-dashed: 1px dashed var(--anzhiyu-theme-op);    --style-border-avatar: 4px solid var(--anzhiyu-background);    --style-border-always: 1px solid var(--anzhiyu-card-border);    --anzhiyu-white-acrylic1: #fefeff !important;    --anzhiyu-white-acrylic2: #fcfdff !important;    --anzhiyu-black-acrylic2: #08080a !important;    --anzhiyu-black-acrylic1: #0b0b0e !important;  }    [data-theme="light"] {    --anzhiyu-theme: #3b70fc;    --anzhiyu-theme-op: #4259ef23;    --anzhiyu-blue: #3b70fc;    --anzhiyu-red: #d8213c;    --anzhiyu-pink: #ff7c7c;    --anzhiyu-green: #57bd6a;    --anzhiyu-fontcolor: #363636;    --anzhiyu-background: #f7f9fe;    --anzhiyu-reverse: #000;    --anzhiyu-maskbg: rgba(255, 255, 255, 0.6);    --anzhiyu-maskbgdeep: rgba(255, 255, 255, 0.85);    --anzhiyu-hovertext: var(--anzhiyu-theme);    --anzhiyu-ahoverbg: #f7f7fa;    --anzhiyu-lighttext: var(--anzhiyu-main);    --anzhiyu-secondtext: rgba(60, 60, 67, 0.6);    --anzhiyu-scrollbar: rgba(60, 60, 67, 0.4);    --anzhiyu-card-btn-bg: #edf0f7;    --anzhiyu-post-blockquote-bg: #fafcff;    --anzhiyu-post-tabs-bg: #f2f5f8;    --anzhiyu-secondbg: #edf0f7;    --anzhiyu-shadow-nav: 0 5px 12px -5px rgba(102, 68, 68, 0.05);    --anzhiyu-card-bg: #fff;    --anzhiyu-shadow-lightblack: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-shadow-light2black: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-card-border: #c0c6d8;  }    [data-theme="dark"] {    --anzhiyu-theme: #0084ff;    --anzhiyu-theme-op: #0084ff23;    --anzhiyu-blue: #0084ff;    --anzhiyu-red: #ff3842;    --anzhiyu-pink: #ff7c7c;    --anzhiyu-green: #57bd6a;    --anzhiyu-fontcolor: #f7f7fa;    --anzhiyu-background: #18171d;    --anzhiyu-reverse: #fff;    --anzhiyu-maskbg: rgba(0, 0, 0, 0.6);    --anzhiyu-maskbgdeep: rgba(0, 0, 0, 0.85);    --anzhiyu-hovertext: #0a84ff;    --anzhiyu-ahoverbg: #fff;    --anzhiyu-lighttext: #f2b94b;    --anzhiyu-secondtext: #a1a2b8;    --anzhiyu-scrollbar: rgba(200, 200, 223, 0.4);    --anzhiyu-card-btn-bg: #30343f;    --anzhiyu-post-blockquote-bg: #000;    --anzhiyu-post-tabs-bg: #121212;    --anzhiyu-secondbg: #30343f;    --anzhiyu-shadow-nav: 0 5px 20px 0px rgba(28, 28, 28, 0.4);    --anzhiyu-card-bg: #1d1b26;    --anzhiyu-shadow-lightblack: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-shadow-light2black: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-card-border: #42444a;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/countup.js"/>
      <url>/js/countup.js</url>
      
        <content type="html"><![CDATA[var CountUp = function (target, startVal, endVal, decimals, duration, options) {    var self = this;    self.version = function () {      return "1.9.2";    };    self.options = {      useEasing: true,      useGrouping: true,      separator: ",",      decimal: ".",      easingFn: easeOutExpo,      formattingFn: formatNumber,      prefix: "",      suffix: "",      numerals: [],    };    if (options && typeof options === "object") {      for (var key in self.options) {        if (options.hasOwnProperty(key) && options[key] !== null) {          self.options[key] = options[key];        }      }    }    if (self.options.separator === "") {      self.options.useGrouping = false;    } else {      self.options.separator = "" + self.options.separator;    }    var lastTime = 0;    var vendors = ["webkit", "moz", "ms", "o"];    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {      window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];      window.cancelAnimationFrame =        window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];    }    if (!window.requestAnimationFrame) {      window.requestAnimationFrame = function (callback, element) {        var currTime = new Date().getTime();        var timeToCall = Math.max(0, 16 - (currTime - lastTime));        var id = window.setTimeout(function () {          callback(currTime + timeToCall);        }, timeToCall);        lastTime = currTime + timeToCall;        return id;      };    }    if (!window.cancelAnimationFrame) {      window.cancelAnimationFrame = function (id) {        clearTimeout(id);      };    }    function formatNumber(num) {      num = num.toFixed(self.decimals);      num += "";      var x, x1, x2, x3, i, l;      x = num.split(".");      x1 = x[0];      x2 = x.length > 1 ? self.options.decimal + x[1] : "";      if (self.options.useGrouping) {        x3 = "";        for (i = 0, l = x1.length; i < l; ++i) {          if (i !== 0 && i % 3 === 0) {            x3 = self.options.separator + x3;          }          x3 = x1[l - i - 1] + x3;        }        x1 = x3;      }      if (self.options.numerals.length) {        x1 = x1.replace(/[0-9]/g, function (w) {          return self.options.numerals[+w];        });        x2 = x2.replace(/[0-9]/g, function (w) {          return self.options.numerals[+w];        });      }      return self.options.prefix + x1 + x2 + self.options.suffix;    }    function easeOutExpo(t, b, c, d) {      return (c * (-Math.pow(2, (-10 * t) / d) + 1) * 1024) / 1023 + b;    }    function ensureNumber(n) {      return typeof n === "number" && !isNaN(n);    }    self.initialize = function () {      if (self.initialized) {        return true;      }      self.error = "";      self.d = typeof target === "string" ? document.getElementById(target) : target;      if (!self.d) {        self.error = "[CountUp] target is null or undefined";        return false;      }      self.startVal = Number(startVal);      self.endVal = Number(endVal);      if (ensureNumber(self.startVal) && ensureNumber(self.endVal)) {        self.decimals = Math.max(0, decimals || 0);        self.dec = Math.pow(10, self.decimals);        self.duration = Number(duration) * 1000 || 2000;        self.countDown = self.startVal > self.endVal;        self.frameVal = self.startVal;        self.initialized = true;        return true;      } else {        self.error = "[CountUp] startVal (" + startVal + ") or endVal (" + endVal + ") is not a number";        return false;      }    };    self.printValue = function (value) {      var result = self.options.formattingFn(value);      if (self.d.tagName === "INPUT") {        this.d.value = result;      } else {        if (self.d.tagName === "text" || self.d.tagName === "tspan") {          this.d.textContent = result;        } else {          this.d.innerHTML = result;        }      }    };    self.count = function (timestamp) {      if (!self.startTime) {        self.startTime = timestamp;      }      self.timestamp = timestamp;      var progress = timestamp - self.startTime;      self.remaining = self.duration - progress;      if (self.options.useEasing) {        if (self.countDown) {          self.frameVal = self.startVal - self.options.easingFn(progress, 0, self.startVal - self.endVal, self.duration);        } else {          self.frameVal = self.options.easingFn(progress, self.startVal, self.endVal - self.startVal, self.duration);        }      } else {        if (self.countDown) {          self.frameVal = self.startVal - (self.startVal - self.endVal) * (progress / self.duration);        } else {          self.frameVal = self.startVal + (self.endVal - self.startVal) * (progress / self.duration);        }      }      if (self.countDown) {        self.frameVal = self.frameVal < self.endVal ? self.endVal : self.frameVal;      } else {        self.frameVal = self.frameVal > self.endVal ? self.endVal : self.frameVal;      }      self.frameVal = Math.round(self.frameVal * self.dec) / self.dec;      self.printValue(self.frameVal);      if (progress < self.duration) {        self.rAF = requestAnimationFrame(self.count);      } else {        if (self.callback) {          self.callback();        }      }    };    self.start = function (callback) {      if (!self.initialize()) {        return;      }      self.callback = callback;      self.rAF = requestAnimationFrame(self.count);    };    self.pauseResume = function () {      if (!self.paused) {        self.paused = true;        cancelAnimationFrame(self.rAF);      } else {        self.paused = false;        delete self.startTime;        self.duration = self.remaining;        self.startVal = self.frameVal;        requestAnimationFrame(self.count);      }    };    self.reset = function () {      self.paused = false;      delete self.startTime;      self.initialized = false;      if (self.initialize()) {        cancelAnimationFrame(self.rAF);        self.printValue(self.startVal);      }    };    self.update = function (newEndVal) {      if (!self.initialize()) {        return;      }      newEndVal = Number(newEndVal);      if (!ensureNumber(newEndVal)) {        self.error = "[CountUp] update() - new endVal is not a number: " + newEndVal;        return;      }      self.error = "";      if (newEndVal === self.frameVal) {        return;      }      cancelAnimationFrame(self.rAF);      self.paused = false;      delete self.startTime;      self.startVal = self.frameVal;      self.endVal = newEndVal;      self.countDown = self.startVal > self.endVal;      self.rAF = requestAnimationFrame(self.count);    };    if (self.initialize()) {      self.printValue(self.startVal);    }  };]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/style.css"/>
      <url>/css/style.css</url>
      
        <content type="html"><![CDATA[#universe {    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    z-index: 1;}@media screen and (max-width: 768px) {    #universe {        display: none;    }    /* 下面这个是切换手机背景的代码，有需要的可以使用，没需要的删了就行 */    #web_bg {        background-image: url("https://img.vm.laomishuo.com/image/2021/05/2021053107390019.jpeg");    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/rightmenu.js"/>
      <url>/js/rightmenu.js</url>
      
        <content type="html"><![CDATA[var rm = {};rm.showRightMenu = function (isTrue, x = 0, y = 0) {    let $rightMenu = $('#rightMenu');    $rightMenu.css('top', x + 'px').css('left', y + 'px');    if (isTrue) {        stopMaskScroll()        $rightMenu.show();    } else {        $rightMenu.hide();    }};let rmWidth = $('#rightMenu').width();let rmHeight = $('#rightMenu').height();rm.reloadrmSize = function () {    rmWidth = $("#rightMenu").width();    rmHeight = $("#rightMenu").height()};window.oncontextmenu = function (event) {    if (document.body.clientWidth > 768) {        let pageX = event.clientX + 10;        let pageY = event.clientY;        let $rightMenuNormal = $(".rightMenuNormal");        let $rightMenuOther = $(".rightMenuOther");        let $rightMenuReadmode = $("#menu-readmode");        $rightMenuNormal.show();        $rightMenuOther.show();        rm.reloadrmSize();        if (pageX + rmWidth > window.innerWidth) {            pageX -= rmWidth;        }        if (pageY + rmHeight > window.innerHeight) {            pageY -= rmHeight;        }        rm.showRightMenu(true, pageY, pageX);        $('#rightmenu-mask').attr('style', 'display: flex');        return false;    }};function removeRightMenu() {    rm.showRightMenu(false);    $('#rightmenu-mask').attr('style', 'display: none');}function stopMaskScroll() {    if (document.getElementById("rightmenu-mask")) {        let xscroll = document.getElementById("rightmenu-mask");        xscroll.addEventListener("mousewheel", function (e) {            removeRightMenu();        }, false);    };    if (document.getElementById("rightMenu")) {        let xscroll = document.getElementById("rightMenu");        xscroll.addEventListener("mousewheel", function (e) {            removeRightMenu();        }, false);    }}/** * @name:  切換模式 */function switchDarkMode() {    removeRightMenu();    const nowMode = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'    if (nowMode === 'light') {        activateDarkMode();        saveToLocal.set('theme', 'dark', 2);        GLOBAL_CONFIG.Snackbar !== undefined && btf.snackbarShow(GLOBAL_CONFIG.Snackbar.day_to_night);    } else {        activateLightMode();        saveToLocal.set('theme', 'light', 2);        GLOBAL_CONFIG.Snackbar !== undefined && btf.snackbarShow(GLOBAL_CONFIG.Snackbar.night_to_day);    }    typeof utterancesTheme === 'function' && utterancesTheme();    typeof FB === 'object' && window.loadFBComment();    window.DISQUS && document.getElementById('disqus_thread').children.length && setTimeout(() => window.disqusReset(), 200);};/* eslint-disable no-undef */document.addEventListener('DOMContentLoaded', function () {    translateInitialization();    document.addEventListener('pjax:complete', translateInitialization);});const translate = GLOBAL_CONFIG.translate;const snackbarData = GLOBAL_CONFIG.Snackbar;const defaultEncoding = translate.defaultEncoding; /* 網站默認語言，1: 繁體中文, 2: 簡體中文 */const translateDelay = translate.translateDelay; /* 延遲時間,若不在前, 要設定延遲翻譯時間, 如100表示100ms,默認為0 */const msgToTraditionalChinese = translate.msgToTraditionalChinese; /* 此處可以更改為你想要顯示的文字 */const msgToSimplifiedChinese = translate.msgToSimplifiedChinese; /* 同上，但兩處均不建議更改 */let currentEncoding = defaultEncoding;const targetEncodingCookie = 'translate-chn-cht';let targetEncoding =    saveToLocal.get(targetEncodingCookie) === undefined        ? defaultEncoding        : Number(saveToLocal.get('translate-chn-cht'));let translateButtonObjectconst isSnackbar = GLOBAL_CONFIG.Snackbar !== undefined;function translateText(txt) {    if (txt === '' || txt == null) return '';    if (currentEncoding === 1 && targetEncoding === 2) return Simplized(txt);    else if (currentEncoding === 2 && targetEncoding === 1) { return Traditionalized(txt) } else return txt;}function translateBody(fobj) {    let objs;    if (typeof fobj === 'object') objs = fobj.childNodes;    else objs = document.body.childNodes;    for (let i = 0; i < objs.length; i++) {        const obj = objs.item(i);        if (            '||BR|HR|'.indexOf('|' + obj.tagName + '|') > 0 ||            obj === translateButtonObject        ) { continue }        if (obj.title !== '' && obj.title != null) { obj.title = translateText(obj.title) };        if (obj.alt !== '' && obj.alt != null) obj.alt = translateText(obj.alt);        if (obj.placeholder !== '' && obj.placeholder != null) obj.placeholder = translateText(obj.placeholder);        if (            obj.tagName === 'INPUT' &&            obj.value !== '' &&            obj.type !== 'text' &&            obj.type !== 'hidden'        ) { obj.value = translateText(obj.value) }        if (obj.nodeType === 3) obj.data = translateText(obj.data);        else translateBody(obj);    }}function translatePage() {    if (targetEncoding === 1) {        currentEncoding = 1;        targetEncoding = 2;        saveToLocal.set(targetEncodingCookie, targetEncoding, 2);        translateBody();        if (isSnackbar) btf.snackbarShow(snackbarData.cht_to_chs);    } else if (targetEncoding === 2) {        currentEncoding = 2;        targetEncoding = 1;        saveToLocal.set(targetEncodingCookie, targetEncoding, 2);        translateBody();        if (isSnackbar) btf.snackbarShow(snackbarData.chs_to_cht);    }}function JTPYStr() {    return '万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾'}function FTPYStr() {    return '萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽'}function Traditionalized(cc) {    let str = '';    const ss = JTPYStr();    const tt = FTPYStr();    for (let i = 0; i < cc.length; i++) {        if (cc.charCodeAt(i) > 10000 && ss.indexOf(cc.charAt(i)) !== -1) { str += tt.charAt(ss.indexOf(cc.charAt(i))) } else str += cc.charAt(i)    };    return str;}function Simplized(cc) {    let str = '';    const ss = JTPYStr();    const tt = FTPYStr();    for (let i = 0; i < cc.length; i++) {        if (cc.charCodeAt(i) > 10000 && tt.indexOf(cc.charAt(i)) !== -1) { str += ss.charAt(tt.indexOf(cc.charAt(i))) } else str += cc.charAt(i)    }    return str;}function translateInitialization() {    translateButtonObject = document.getElementById('menu-translate');    if (translateButtonObject) {        if (currentEncoding !== targetEncoding) {            setTimeout(translateBody, translateDelay);        }        translateButtonObject.addEventListener('click', translatePage, false);    }}$('#menu-backward').on('click', function () { window.history.back(); });$('#menu-forward').on('click', function () { window.history.forward(); });$('#menu-refresh').on('click', function () { window.location.reload(); });$('#menu-darkmode').on('click', function () { switchDarkMode() });$('#menu-home').on('click', function () { window.location.href = window.location.origin; });/* 简体繁体切换 */$('#menu-translate').on('click', function () {    removeRightMenu();    translateInitialization();});$(".menu-link").on("click", function () {    removeRightMenu()});$("#rightmenu-mask").on("click", function () { removeRightMenu() });$("#rightmenu-mask").contextmenu(function () {    removeRightMenu();    return false;});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/menu.js"/>
      <url>/js/menu.js</url>
      
        <content type="html"><![CDATA[// 返回顶部 显示网页阅读进度window.onscroll = percent; // 执行函数// 页面百分比function percent() {  document.getElementById("page-name").innerText = document.title.split(" | ")[0];  let a = document.documentElement.scrollTop || window.pageYOffset, // 卷去高度    b =      Math.max(        document.body.scrollHeight,        document.documentElement.scrollHeight,        document.body.offsetHeight,        document.documentElement.offsetHeight,        document.body.clientHeight,        document.documentElement.clientHeight      ) - document.documentElement.clientHeight, // 整个网页高度 减去 可视高度    result = Math.round((a / b) * 100), // 计算百分比    btn = document.querySelector("#percent"); // 获取图标  result <= 99 || (result = 99), (btn.innerHTML = result);}document.getElementById("page-name").innerText = document.title.split(" | ")[0];]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.min.js"/>
      <url>/js/runtime.min.js</url>
      
        <content type="html"><![CDATA[var now = new Date; function createtime() {     var t = new Date("06/01/2022 00:00:00");     now.setTime(now.getTime() + 250);     var e = (now - t) / 1e3 / 60 / 60 / 24, a = Math.floor(e), n = (now - t) / 1e3 / 60 / 60 - 24 * a, r = Math.floor(n);     1 == String(r).length && (r = "0" + r);     var s = (now - t) / 1e3 / 60 - 1440 * a - 60 * r, i = Math.floor(s);     1 == String(i).length && (i = "0" + i);     var o = (now - t) / 1e3 - 86400 * a - 3600 * r - 60 * i, l = Math.round(o);     1 == String(l).length && (l = "0" + l);     let g = "";     g = r < 18 && r >= 9 ? `<span class='textTip'> 本站已在风风雨雨中走过了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>` : `<span class='textTip'> 本站已在风风雨雨中走过了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`, document.getElementById("workboard") && (document.getElementById("workboard").innerHTML = g) } setInterval((() => { createtime() }), 250);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/sun_moon.js"/>
      <url>/js/sun_moon.js</url>
      
        <content type="html"><![CDATA[function switchNightMode() {    document.querySelector('body').insertAdjacentHTML('beforeend', '<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>'),      setTimeout(function() {        document.querySelector('body').classList.contains('DarkMode') ? (document.querySelector('body').classList.remove('DarkMode'), localStorage.setItem('isDark', '0'), document.getElementById('modeicon').setAttribute('xlink:href', '#icon-moon')) : (document.querySelector('body').classList.add('DarkMode'), localStorage.setItem('isDark', '1'), document.getElementById('modeicon').setAttribute('xlink:href', '#icon-sun')),          setTimeout(function() {            document.getElementsByClassName('Cuteen_DarkSky')[0].style.transition = 'opacity 3s';            document.getElementsByClassName('Cuteen_DarkSky')[0].style.opacity = '0';            setTimeout(function() {              document.getElementsByClassName('Cuteen_DarkSky')[0].remove();            }, 1e3);          }, 2e3)      })    const nowMode = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'    if (nowMode === 'light') {      activateDarkMode()      saveToLocal.set('theme', 'dark', 2)      GLOBAL_CONFIG.Snackbar !== undefined && btf.snackbarShow(GLOBAL_CONFIG.Snackbar.day_to_night)      document.getElementById('modeicon').setAttribute('xlink:href', '#icon-sun')    } else {      activateLightMode()      saveToLocal.set('theme', 'light', 2)      document.querySelector('body').classList.add('DarkMode'), document.getElementById('modeicon').setAttribute('xlink:href', '#icon-moon')    }    // handle some cases    typeof utterancesTheme === 'function' && utterancesTheme()    typeof FB === 'object' && window.loadFBComment()    window.DISQUS && document.getElementById('disqus_thread').children.length && setTimeout(() => window.disqusReset(), 200)  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/random/index.html"/>
      <url>/random/index.html</url>
      
        <content type="html"><![CDATA[<html><body onload="dogo()">    <script>        function dogo() {            var h = [                "https://tzy1997.com/articles/hexo1600",                "https://tzy1997.com/articles/hexo1601",                "https://tzy1997.com/articles/hexo1602",                "https://tzy1997.com/articles/hexo1603",                "https://tzy1997.com/articles/hexo1604",                "https://tzy1997.com/articles/hexo1605",                "https://tzy1997.com/articles/hexo1606",                "https://tzy1997.com/articles/hexo541u",                "https://tzy1997.com/articles/Ha5487ng",                "https://tzy1997.com/articles/io0411sc",            ]            n = Math.floor(Math.random() * h.length), location.href = h[n]        }    </script></body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;    var n, e, i, h, t = .05,        s = document.getElementById("universe"),        o = !0,        a = "180,184,240",        r = "226,225,142",        d = "226,225,224",        c = [];    function f() {        n = window.innerWidth, e = window.innerHeight, i = .216 * n, s.setAttribute("width", n), s.setAttribute("height", e)    }    function u() {        h.clearRect(0, 0, n, e);        for (var t = c.length, i = 0; i < t; i++) {            var s = c[i];            s.move(), s.fadeIn(), s.fadeOut(), s.draw()        }    }    function y() {        this.reset = function() {            this.giant = m(3), this.comet = !this.giant && !o && m(10), this.x = l(0, n - 10), this.y = l(0, e), this.r = l(1.1, 2.6), this.dx = l(t, 6 * t) + (this.comet + 1 - 1) * t * l(50, 120) + 2 * t, this.dy = -l(t, 6 * t) - (this.comet + 1 - 1) * t * l(50, 120), this.fadingOut = null, this.fadingIn = !0, this.opacity = 0, this.opacityTresh = l(.2, 1 - .4 * (this.comet + 1 - 1)), this.do = l(5e-4, .002) + .001 * (this.comet + 1 - 1)        }, this.fadeIn = function() {            this.fadingIn && (this.fadingIn = !(this.opacity > this.opacityTresh), this.opacity += this.do)        }, this.fadeOut = function() {            this.fadingOut && (this.fadingOut = !(this.opacity < 0), this.opacity -= this.do /2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20 * t) + ")", h.rect(this.x - this.dx / 4 * t, this.y - this.dy / 4 * t - 2, 2, 2), h.fill()        } else h.fillStyle = "rgba(" + r + "," + this.opacity + ")", h.rect(this.x, this.y, this.r, this.r);            h.closePath(), h.fill()        }, this.move = function() {            this.x += this.dx, this.y += this.dy, !1 === this.fadingOut && this.reset(), (this.x > n - n / 4 || this.y < 0) && (this.fadingOut = !0)        }, setTimeout(function() {            o = !1        }, 50)    }    function m(t) {        return Math.floor(1e3 * Math.random()) + 1 < 10 * t    }    function l(t, i) {        return Math.random() * (i - t) + t    }    f(), window.addEventListener("resize", f, !1), function() {        h = s.getContext("2d");        for (var t = 0; t < i; t++) c[t] = new y, c[t].reset();        u()    }(), function t() {        document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark' && u(), window.requestAnimationFrame(t)    }()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener("visibilitychange", function () {  if (document.hidden) {    //离开当前页面时标签显示内容    document.title = "w(ﾟДﾟ)w 不要走！再看看嘛！";    clearTimeout(titleTime);  } else {    //返回当前页面时标签显示内容    document.title = "♪(^∇^*)欢迎肥来！" + OriginTitile;    //两秒后变回正常标题    titleTime = setTimeout(function () {      document.title = OriginTitile;    }, 2000);  }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
